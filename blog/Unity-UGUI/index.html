<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Unity-UGUI | blog-Chou</title><meta name="keywords" content="UGUI"><meta name="author" content="Chou"><meta name="copyright" content="Chou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="六大组件Unity中如何使用UGUIUGUI是Unity内置的UI，可以在Unity中直接使用  当我们创建UI对象时，都会创建在Canvas的子对象中  六大基础组件的作用  总结：  UGUI无需外部引用内容，直接右键使用 Canvas对象和EventSystem对象上的组件被合称为六大组件   Canvas(画布组件)Canvas 的意思是画布，它主要负责渲染自己的所有UI子对象 可以通过修">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity-UGUI">
<meta property="og:url" content="https://github.com/zYidian/zYidian.github.io/blog/Unity-UGUI/index.html">
<meta property="og:site_name" content="blog-Chou">
<meta property="og:description" content="六大组件Unity中如何使用UGUIUGUI是Unity内置的UI，可以在Unity中直接使用  当我们创建UI对象时，都会创建在Canvas的子对象中  六大基础组件的作用  总结：  UGUI无需外部引用内容，直接右键使用 Canvas对象和EventSystem对象上的组件被合称为六大组件   Canvas(画布组件)Canvas 的意思是画布，它主要负责渲染自己的所有UI子对象 可以通过修">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/zYidian/zYidian.github.io/media/top_img.jpg">
<meta property="article:published_time" content="2022-05-24T07:48:05.000Z">
<meta property="article:modified_time" content="2022-07-25T14:20:38.510Z">
<meta property="article:author" content="Chou">
<meta property="article:tag" content="UGUI">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/zYidian/zYidian.github.io/media/top_img.jpg"><link rel="shortcut icon" href="/media/favicon.png"><link rel="canonical" href="https://github.com/zYidian/zYidian.github.io/blog/Unity-UGUI/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Unity-UGUI',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-25 22:20:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img1.baidu.com/it/u=223483055,1110828441&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=400&amp;h=400" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/media/top_img.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">blog-Chou</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Unity-UGUI</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-24T07:48:05.000Z" title="发表于 2022-05-24 15:48:05">2022-05-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-25T14:20:38.510Z" title="更新于 2022-07-25 22:20:38">2022-07-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Unity/">Unity</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Unity-UGUI"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="六大组件"><a href="#六大组件" class="headerlink" title="六大组件"></a>六大组件</h2><h3 id="Unity中如何使用UGUI"><a href="#Unity中如何使用UGUI" class="headerlink" title="Unity中如何使用UGUI"></a>Unity中如何使用UGUI</h3><p>UGUI是Unity内置的UI，可以在Unity中直接使用</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/blog/Unity-UGUI/image-20220412155303158.png" class="" title="image-20220412155303158">
<p>当我们创建UI对象时，都会创建在Canvas的子对象中</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/blog/Unity-UGUI/image-20220412155516996.png" class="" title="image-20220412155516996">
<p><strong>六大基础组件的作用</strong></p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/blog/Unity-UGUI/image-20220412155727066.png" class="" title="image-20220412155727066">
<p>总结：</p>
<ul>
<li>UGUI无需外部引用内容，直接右键使用</li>
<li><strong>Canvas</strong>对象和<strong>EventSystem</strong>对象上的组件被合称为六大组件</li>
</ul>
<hr>
<h3 id="Canvas-画布组件"><a href="#Canvas-画布组件" class="headerlink" title="Canvas(画布组件)"></a>Canvas(画布组件)</h3><p>Canvas 的意思是画布，它主要负责<strong>渲染</strong>自己的所有<strong>UI子对象</strong></p>
<p>可以通过修改Canvas组件上的参数 来修改渲染方式</p>
<p>特点：</p>
<p>场景中允许多个Canvas对象存在，可以<strong>分别管理不同画布的渲染方式</strong>，<strong>分辨率适应方式</strong>等参数</p>
<p>但，如果没有特殊需求，一个场景上一个Canvas即可</p>
<p>三种渲染方式(Render Mode)：</p>
<ul>
<li>Overlay：屏幕空间下的覆盖模式，<strong>UI始终显示在前面</strong></li>
<li>Camera：屏幕空间下的摄像机模式，<strong>3D物体可以显示在UI前</strong></li>
<li>World Space：世界空间下的3D模式，一般用于UI围绕着人物旋转，VR场景使用较多</li>
</ul>
<p><strong>Overlay</strong>(覆盖模式)：覆盖整个场景中的游戏画面，显示在最前方</p>
<ul>
<li>Pixel Perfect：开启无锯齿精确渲染，用性能换效果</li>
<li><strong>SortOrder</strong>：排序层编号(数字越大的画面，显示在越前方)</li>
<li>TargetDisplay：在哪个显示设备上显示，用于多显示器游戏</li>
</ul>
<p><strong>Camera</strong>(摄像机模式)：常用于将人物模型面板显示在UI之前</p>
<ul>
<li><strong>RenderCamera</strong>：用户渲染UI的摄像机(如果不设置 则类似于覆盖模式)</li>
<li><p><strong>Plane Distance</strong>：UI平面在摄像机的前方距离，类似于Z轴的感觉</p>
</li>
<li><p><strong>Sorting Layer</strong>：所在排序层，<strong>排序层越靠后，显示越前面</strong></p>
</li>
<li><strong>Order in Layer</strong>：排序层的序号，当<strong>排序层相同</strong>时，<strong>序号越大，显示越前</strong></li>
</ul>
<blockquote>
<p>第二种模式一般会专门新建一个摄像机来渲染UI</p>
<p>1、新建摄像机，并更改其Culling Mask参数为UI，让其只渲染UI层</p>
<p>2、然后主摄像机的Culling Mask参数 不渲染UI层</p>
<p>3、将新建摄像机关联到Render Camera</p>
<p>4、并修改新建摄像机的Clear Flags参数为Deaph only，让新摄像机只渲染UI层</p>
</blockquote>
<p>World Space(3D模式)：常用于VR或AR</p>
<blockquote>
<p>还可以用于制作对话框，以及跟随人物的血条等</p>
</blockquote>
<ul>
<li>Event Camera：用于处理UI事件的摄像机，通过关联主摄像机</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>游戏开发中常用<strong>Camera</strong>(摄像机模式)渲染</p>
<h3 id="CanvasScaler-分辨率自适应组件"><a href="#CanvasScaler-分辨率自适应组件" class="headerlink" title="CanvasScaler(分辨率自适应组件)"></a>CanvasScaler(分辨率自适应组件)</h3><p>CanvasScaler是 <strong>画布缩放控制器</strong>，它用于<strong>分辨率自适应组件</strong></p>
<p>主要负责 不同分辨率下<strong>UI控件大小的自适应</strong>，并不负责位置自适应</p>
<p>它提供了<strong>三种用于分辨率自适应的模式</strong></p>
<p>必备知识</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/blog/Unity-UGUI/image-20220412165527842.png" class="" title="image-20220412165527842">
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/blog/Unity-UGUI/image-20220412165548923.png" class="" title="image-20220412165548923">
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/blog/Unity-UGUI/image-20220412165839246.png" class="" title="image-20220412165839246">
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/blog/Unity-UGUI/image-20220412165905764.png" class="" title="image-20220412165905764">
<p><strong>三种适配模式</strong></p>
<ul>
<li>Constant Pixel Size(恒定像素模式)：无论屏幕大小如何，<strong>UI始终保持相同像素大小</strong></li>
<li><strong>Scale With Screen Size</strong>(缩放模式)：<strong>随屏幕尺寸进行缩放大小</strong></li>
<li>Constant Physical Size(恒定物理模式)：无论屏幕大小和分辨率如何，UI元素<strong>始终保持相同物理大小</strong></li>
</ul>
<h4 id="恒定像素模式"><a href="#恒定像素模式" class="headerlink" title="恒定像素模式"></a><strong>恒定像素模式</strong></h4><ul>
<li><p>Scale Factor：缩放系数，会<strong>按照此系数缩放画布中的所有UI元素</strong></p>
</li>
<li><p>Reference Pixels Per Unit：单位参考像素，多少个像素对应Unity中的一个单位(默认为100像素)。会与图片设置中的Pixels Per Unit设置，一起参与计算</p>
</li>
</ul>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/blog/Unity-UGUI/image-20220412171705063.png" class="" title="image-20220412171705063">
<p>注意：</p>
<p>恒定像素模式<strong>不会让UI控件进行分辨率自适应</strong>，使用较少</p>
<h4 id="缩放模式"><a href="#缩放模式" class="headerlink" title="缩放模式"></a><strong>缩放模式</strong></h4><p>最常用的模式，会根据屏幕尺寸进行缩放大小</p>
<ul>
<li><strong>Reference Resolution</strong>：参考分辨率。用于参与分辨率自适应计算</li>
<li><strong>Screen Match Mode</strong>：屏幕匹配模式，当前屏幕分辨率宽高比，不适用参考分辨率时，用分辨率大小自适应的匹配模式</li>
</ul>
<p><strong>三种匹配模式</strong></p>
<ul>
<li>Expand：水平或垂直<strong>拓展画布</strong>区域，会根据宽高比的变化来放大缩小画布，可能会有黑边</li>
</ul>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/blog/Unity-UGUI/image-20220420205431975.png" class="" title="image-20220420205431975">
<ul>
<li><p>Shrink：水平或垂直<strong>裁剪画布</strong>区域，会根据宽高比的变化来放大缩小画布，可能会裁剪</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/blog/Unity-UGUI/image-20220420210022044.png" class="" title="image-20220420210022044">
</li>
<li><p>Match Width Or Height：默认模式，以<strong>宽高或二者的平均值作为参考</strong>，来缩放画布区域</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/blog/Unity-UGUI/image-20220420210351615.png" class="" title="image-20220420210351615">
</li>
</ul>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/blog/Unity-UGUI/image-20220420210511767.png" class="" title="image-20220420210511767">
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>游戏开发中一般使用<strong>Scale With Screen Size</strong> 缩放模式</p>
<p>若游戏存在横竖屏切换</p>
<ul>
<li>则选择<strong>Expand</strong>(拓展匹配，有黑边)和<strong>Shrink</strong>(收缩匹配，有裁剪)</li>
</ul>
<p>若游戏不存在横竖屏切换</p>
<ul>
<li>则使用<strong>Match Width or Height</strong>(宽高匹配)</li>
<li><strong>横屏游戏 Match = 1</strong>，<strong>竖屏游戏 Match = 0</strong></li>
</ul>
<hr>
<h3 id="Graphic-Raycaster-射线事件交互组件"><a href="#Graphic-Raycaster-射线事件交互组件" class="headerlink" title="Graphic Raycaster(射线事件交互组件)"></a>Graphic Raycaster(射线事件交互组件)</h3><p>Graphic Raycaster意思是<strong>图形射线投射器</strong>，用于<strong>检测UI输入事件的射线发射器</strong></p>
<p>作用：</p>
<p>主要<strong>通过射线检测</strong> <strong>判断玩家是否点击到了UI元素</strong></p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/blog/Unity-UGUI/image-20220725215852986.png" class="" title="image-20220725215852986">
<p>参数：</p>
<ul>
<li><p>Ignore Reversed Graphics：是否忽略反转图，默认勾选，则忽略反转图</p>
<blockquote>
<p>勾选后，若图形的 Rotation发生反转，则不能发生交互响应</p>
</blockquote>
</li>
<li><p>Blocking Object：<strong>射线被哪些类型的碰撞器阻挡</strong>(覆盖渲染模式下无效)</p>
<blockquote>
<p>None：不被阻挡</p>
<p>Two D：被2D碰撞器阻挡，即不能通过2D碰撞器去跟图形进行交互</p>
<p>Three D：被3D碰撞器阻挡</p>
<p>All：都阻挡</p>
</blockquote>
</li>
<li><p>Blocking Mask：<strong>射线被哪些层级的碰撞器阻挡</strong>(覆盖渲染模式下无效)</p>
<blockquote>
<p>该参数一般与第二个参数配合使用，为2D或者3D碰撞器添加专门的层级，使其单独生效</p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="EventSystem和Standalone-Input-Module"><a href="#EventSystem和Standalone-Input-Module" class="headerlink" title="EventSystem和Standalone Input Module"></a>EventSystem和Standalone Input Module</h3><h4 id="EventSystem组件"><a href="#EventSystem组件" class="headerlink" title="EventSystem组件"></a><strong>EventSystem组件</strong></h4><ul>
<li><p>EventSystem是<strong>事件系统</strong>。它用于<strong>管理玩家输入事件并分发给各UI控件</strong></p>
</li>
<li><p>它是事件逻辑处理模块。<strong>所有的UI事件都通过EventSystem组件，进行检测并做相应的执行</strong></p>
</li>
<li><p><strong>它类似于一个中转站，和许多模块一起共同协作</strong></p>
</li>
</ul>
<blockquote>
<p>如果没有它，所有的点击、拖拽等等行为都不会被响应</p>
</blockquote>
<h4 id="EventSystem组件参数"><a href="#EventSystem组件参数" class="headerlink" title="EventSystem组件参数"></a><strong>EventSystem组件参数</strong></h4><p>参数面板如图</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/blog/Unity-UGUI/image-20220524160805691.png" class="" title="image-20220524160805691">
<ul>
<li>First Selected：<strong>首先选择的游戏对象，可以设置游戏一开始的默认选择</strong></li>
</ul>
<blockquote>
<p>将一个UI对象与其关联，可以让该UI对象变为默认选中状态</p>
<p>比如我们创建三个Button按钮，更改其选中后的颜色</p>
<p>之后将其中一个按钮于First Selected进行关联，程序运行后，被关联的对象默认选中</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/blog/Unity-UGUI/image-20220524162044548.png" class="" title="image-20220524162044548">
<ul>
<li>Send Navigation Events：<strong>是否允许导航事件(移动/按下/取消)</strong></li>
</ul>
<blockquote>
<p>该参数的功能是通过键盘上的<strong>方向键</strong>或<strong>W/S/A/D键</strong>更改当前UI控件被选中的对象</p>
<p>通过<strong>回车</strong>和<strong>空格</strong>键来点击按钮</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/blog/Unity-UGUI/image-20220524162349648.png" class="" title="image-20220524162349648">
<ul>
<li>Drag Threshold：<strong>拖拽操作的阈值(移动多少像素算拖拽)</strong></li>
</ul>
<blockquote>
<p> 我们可以长按UI控件进行拖拽处理，这里会写上相应的逻辑代码，该处的设置就是拖拽多少各像素算拖拽</p>
</blockquote>
<h4 id="Standalone-Input-Module组件"><a href="#Standalone-Input-Module组件" class="headerlink" title="Standalone Input Module组件"></a>Standalone Input Module组件</h4><p>它是<strong>独立输入模块</strong>，主要针对<strong>处理鼠标/键盘/控制器/触屏(新版Unity)的输入</strong></p>
<p>而<strong>输入的事件是通过EventSystem进行分发</strong>，所以<strong>它依赖于EventSystem组件</strong>，他们两缺一不可</p>
<h4 id="Standalone-Input-Module组件参数"><a href="#Standalone-Input-Module组件参数" class="headerlink" title="Standalone Input Module组件参数"></a><strong>Standalone Input Module组件参数</strong></h4><p>参数面板如图</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/blog/Unity-UGUI/image-20220524163602204.png" class="" title="image-20220524163602204">
<ul>
<li>Input Actions Per Second：<strong>每秒运允许键盘/控制器输入的数量</strong></li>
</ul>
<blockquote>
<p>当我们对键盘或者控制器进行长按时，对输入检测进行限制，每秒最多输入10次</p>
</blockquote>
<ul>
<li><p>Repeat Delay：<strong>当输入操作有重复操作时，在生效前会有一个延迟时间</strong></p>
</li>
<li><p>ForceModule Active：是否强制模块处于激活状态</p>
</li>
</ul>
<blockquote>
<p>该组件的所有参数了解即可，一般不会进行修改</p>
</blockquote>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>EventSystem还在<strong>右下角提供了调试信息</strong></p>
</li>
<li><p>若场景中的UI控件不能被点击，先检查EventSystem是否被误删</p>
</li>
<li>若Canvas中的<strong>Graphic Raycaster组件</strong>未开启，UI控件也不能进行点击</li>
</ul>
<hr>
<h3 id="RectTransform-矩形变换"><a href="#RectTransform-矩形变换" class="headerlink" title="RectTransform(矩形变换)"></a>RectTransform(矩形变换)</h3><p>RectTransfrom意思是矩形变换，它<strong>继承于Transfrom</strong>是专门<strong>用于处理UI元素位置大小的相关组件</strong></p>
<p>RectTransfrom在Transfrom的基础上加入了矩形相关，<strong>将UI元素当作一个矩形来处理</strong></p>
<p>加入了<strong>中心点、锚点、长宽等属性</strong></p>
<p>其目的是<strong>更加方便的控制其大小</strong>以及<strong>分辨率自适应中的位置适应</strong></p>
<h4 id="RectTransfrom参数"><a href="#RectTransfrom参数" class="headerlink" title="RectTransfrom参数"></a>RectTransfrom参数</h4><p>参数如图</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/blog/Unity-UGUI/image-20220725220411016.png" class="" title="image-20220725220411016">
<blockquote>
<p>Rect Transfrom是继承与Transfrom，所以有些属性与Transfrom类似</p>
</blockquote>
<ul>
<li>Pivot：<strong>轴心(中心)点</strong>，取值范围0~1</li>
</ul>
<blockquote>
<p>一般位于组件中央的蓝色小圆圈，如果看不到。则可以选中组件，然后按下键盘的T键</p>
<p>我们创建一个Image，它左下角坐标为(0,0)、右上角坐标为(1,1)，中心点的取值范围在这之间</p>
<p>作用：</p>
<p>1、轴心点会做为旋转的中心</p>
<p>2、轴心点所在位置，会影响图片拉伸时向两边拉伸的比例</p>
</blockquote>
<ul>
<li>Anchors：<strong>相对父矩形的锚点</strong></li>
</ul>
<blockquote>
<p>锚点是由四个小三角形组成的点，一般位于Canvas的中央</p>
<p>Canvas中的白框就是Image中的父矩形，同样左下角坐标为(0,0)，右上角坐标为(1,1)</p>
<p>Min是矩形锚点范围X和Y的最小值</p>
<p>Max是矩形锚点范围X和Y的最大值</p>
<p><strong>当锚点是一个点时，它就相当于image中心点的原点</strong></p>
<p>image的Pos坐标就相当于image中心点与锚点之间的<strong>偏移距离</strong></p>
<p>作用：用于分辨率自适应，能够保持图片在Canvas中的相对位置</p>
<p>将锚点放在Canvas的左上角，并且将image也移动到Canvas左上角，就能完成分辨率自适应</p>
<p>当锚点是一个<strong>范围</strong>时，是<strong>基于锚点位置和image四个点位置进行计算</strong>，即image四个点所构成的矩形和Canvas所构成的矩形进行对比</p>
<p>这时的Pos位置将会变为Left/Top/Right/Bottom，来表示四个点之间所对应的距离</p>
<p>作用：制作背景图时，会image会根据Canvas的变化而进行变化</p>
</blockquote>
<ul>
<li>蓝图模式：开启后，编辑<strong>旋转</strong>和<strong>缩放</strong>不会影响矩形，只会影响显示内容</li>
</ul>
<blockquote>
<p>即开启蓝图模式后，当我们改变image的旋转和缩放时，image的白框并不会改变。一般不开启</p>
</blockquote>
<ul>
<li>原始编辑模式：开启后，改变<strong>轴心点</strong>和<strong>锚点</strong>不会改变矩形位置</li>
</ul>
<blockquote>
<p>image的Pos位置是根据轴心点和锚点进行计算的</p>
<p>当我们改变轴心点或锚点后，计算出的位置就会进行改变</p>
<p>当我们开启原始编辑模式后，就能保证image的Pos位置保持不变</p>
</blockquote>
<h4 id="快速设置中心点和锚点"><a href="#快速设置中心点和锚点" class="headerlink" title="快速设置中心点和锚点"></a>快速设置中心点和锚点</h4><p>通过点击左上角方框，可以快捷设置锚点和中心点</p>
<ul>
<li>按住Shift点击鼠标左键，可以同时设置中心点(相对自身矩形)</li>
<li>按照Alt键点击鼠标左键，可以同时设置image的位置</li>
</ul>
<hr>
<h2 id="AnChor锚点"><a href="#AnChor锚点" class="headerlink" title="AnChor锚点"></a>AnChor锚点</h2><hr>
<h2 id="三大基础控件"><a href="#三大基础控件" class="headerlink" title="三大基础控件"></a>三大基础控件</h2><h3 id="Image图片控件"><a href="#Image图片控件" class="headerlink" title="Image图片控件"></a>Image图片控件</h3><p>Image是图像组件，是UGUI中<strong>用于精灵图片的关键组件</strong></p>
<p>除了背景图等大图，一般都用Image来显示UI中的图片元素</p>
<blockquote>
<p>多个Image的渲染顺序问题</p>
<p>若我们创建了多个Image控件，那么越后创建的Image就会显示在越前方</p>
<p>我们可以改变Hierarchy面板下Image的顺序来改变不同Image的渲染</p>
</blockquote>
<h4 id="Image参数"><a href="#Image参数" class="headerlink" title="Image参数"></a>Image参数</h4><p> 参数面板如图</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="Unity-UGUI/image-20220525092144579.png" alt="image-20220525092144579" style="zoom:100%;" /></p>
<ul>
<li><strong>Source Image</strong>：图片来源</li>
</ul>
<blockquote>
<p>将需要显示的图片与Source Image相关联，图片的类型必须为Sprite</p>
</blockquote>
<ul>
<li>Color：图像的颜色</li>
</ul>
<blockquote>
<p>这里会给图像添加一个叠加色</p>
<p>图像最终呈现效果是 图像原本颜色与添加颜色后叠加的结果</p>
</blockquote>
<ul>
<li><p>Material：图像的材质(一般不修改，使用UI的默认材质)</p>
</li>
<li><p><strong>Raycast Target</strong>：是否作为射线检测的目标</p>
</li>
</ul>
<blockquote>
<p>默认开启，开启该参数后，射线检测会被Image所阻挡</p>
<p>若此时Image后方还有一个Button，则Button被Image所遮挡的部分不能点击</p>
<p>取消Raycast Target后才能穿过Image，去点击后方的Button</p>
</blockquote>
<ul>
<li><p><strong>Maskable</strong>：是否能被遮罩</p>
</li>
<li><p><strong>Image Type</strong>：<strong>图片类型</strong></p>
</li>
</ul>
<blockquote>
<p>1、Simple(普通模式)：均匀缩放整个图片</p>
<p>该模式下，当我们拉伸图片时，这个图片上的像素都会被均匀的拉伸，图片会产生形变。一般当我们的图片不需要改变尺寸时，才会用到普通模式</p>
<p>2、Sliced(切片模式)：九宫格拉伸，只拉伸中央十字区域</p>
<p>该模式下，我们先需要编辑图片的Sprite Editor，移动图片中的小绿点，将其划分为九宫格。</p>
<p>之后再拉伸图片的过程中，只有九宫格内的十字区域被拉伸，而九宫格边缘的四个角则不会被拉伸</p>
<p>一般作为面板背景图时，将一个小图通过九宫格拉伸的方式改为大图，能够起到节约资源的效果</p>
<p>3、Tiled(平铺模式)：重复平铺中央部分</p>
<p>该模式下，通过编辑图片的九宫格，可以使图片拥有底纹的效果</p>
<p>4、Filled(填充模式)：通过改变填充量，图片会不断填充出现</p>
<p>该模式下有许多参数，一般用于制作进度条类的效果</p>
<p>Fill Method：填充方式。图片以哪种形式进行填充</p>
<p>Fill Origin：填充原点。图片从上/下/左/右 开始填充</p>
<p>Preserve Aspect：保持宽高比</p>
</blockquote>
<ul>
<li><strong>Set Native Size</strong>：设置为图片资源的原始大小</li>
</ul>
<blockquote>
<p>当我们导入一张图时，就可以点击该按钮，就能自动的将图片设置为图片像素大小的 原始尺寸</p>
<p>但它会根据Canvas中的适配模式不同，效果也会有所不同</p>
</blockquote>
<h4 id="代码控制"><a href="#代码控制" class="headerlink" title="代码控制"></a>代码控制</h4><p>Image常用API</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用前需要引入UnityEngine.UI</span></span><br><span class="line">Image img = <span class="keyword">this</span>.GetComponent&lt;Image&gt;();</span><br><span class="line"><span class="comment">//动态加载图片的路径</span></span><br><span class="line">img.sprite = Resources.Load&lt;Sprite&gt;(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//g</span></span><br><span class="line">img.color = Color.red;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Text文本控件"><a href="#Text文本控件" class="headerlink" title="Text文本控件"></a>Text文本控件</h3><p>Text是UGUI中用于显示文本的关键组件</p>
<h4 id="Text参数相关"><a href="#Text参数相关" class="headerlink" title="Text参数相关"></a>Text参数相关</h4><p>参数面板如图</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="Unity-UGUI/image-20220525162735745.png" alt="image-20220525162735745" style="zoom:100%;" /></p>
<ul>
<li>Text：文本框内显示的内容</li>
<li>Font：文本字体样式</li>
</ul>
<blockquote>
<p>此处可以将电脑上的字体导入到Unity中，就能给Unity添加额外的字体</p>
</blockquote>
<ul>
<li>FontStyle：字体样式</li>
</ul>
<blockquote>
<p>Normal：默认</p>
<p>Bold：加粗</p>
<p>Italic：斜体</p>
<p>Bold And Italic：加粗+协调</p>
</blockquote>
<ul>
<li>Font Size：字体大小</li>
</ul>
<blockquote>
<p>当我们字体大小足够大时，可能会出现看不到字体的qingk</p>
<p>这时可以更改Rect Transform中的宽高，也就是更改Text中的白框大小即可</p>
</blockquote>
<ul>
<li>Line Spacing：每一行之间的间距</li>
<li>Rich Text：是否开启富文本</li>
</ul>
<blockquote>
<p>开启富文本后，就能在文本框中实现类似HTML的效果</p>
<p>加粗：<b></b></p>
<p>斜体：<i></i></p>
<p>大小：<size=50></size></p>
</blockquote>
<ul>
<li>Alignment：对齐方式</li>
<li><strong>Horizontal Overflow</strong>：处理<strong>文本太宽</strong>无法放入矩形范围时的问题</li>
</ul>
<blockquote>
<p>Wrap：包裹模式，字体始终在矩形范围内，超出会自动换行</p>
<p>Overflow：溢出模式，字体可以溢出矩形框，只能通过回车换行</p>
</blockquote>
<ul>
<li><strong>Vertical Overflow</strong>：处理<strong>文本太高</strong>无法放入矩形范围时的问题</li>
</ul>
<blockquote>
<p>Truncate：截断模式，字体始终在矩形范围内，超出部分会裁剪</p>
<p>Overflow：溢出模式，字体可以溢出矩形框</p>
</blockquote>
<ul>
<li>Best Fit：忽略字体大小，始终把内容完全显示在矩形框中，会自动调整大小</li>
</ul>
<blockquote>
<p>MinSize：当字数过少时，字体大小最小为多小</p>
<p>MaxSize：当字数过多时，字体大小最大为多大</p>
</blockquote>
<ul>
<li>Raycast Target：射线检测</li>
</ul>
<blockquote>
<p>当文本框较大时，非常容易挡住后面的Button按钮</p>
<p>所以当我们不需要在文本中开启点击事件时，一般取消Raycast Target</p>
</blockquote>
<h4 id="边缘线和阴影"><a href="#边缘线和阴影" class="headerlink" title="边缘线和阴影"></a>边缘线和阴影</h4><p>UGUI中没有边缘性和阴影的设置，它是通过了两个脚本进行设置</p>
<ul>
<li>边缘线组件：Outline </li>
<li>阴影组件：Shadow</li>
</ul>
<blockquote>
<p>若想要Text控件中有边缘性和阴影的效果，需要手动Add Component</p>
</blockquote>
<h4 id="代码控制-1"><a href="#代码控制-1" class="headerlink" title="代码控制"></a>代码控制</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Text tex = <span class="keyword">this</span>.GetComponent&lt;Text&gt;();</span><br><span class="line">txt.text = <span class="string">&quot;123&quot;</span>;	<span class="comment">//动态改变文本框内容</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Rawimage原始图像控件"><a href="#Rawimage原始图像控件" class="headerlink" title="Rawimage原始图像控件"></a>Rawimage原始图像控件</h3><p>它是UGUI中用于<strong>显示任何纹理图片的关键组件</strong></p>
<blockquote>
<p>它和Image的区别是，一般RwaImage用于显示大图(背景图、不需要打入图集的图片、网络下载图等)</p>
<p>而Image一般是用来显示小的UI元素</p>
</blockquote>
<h4 id="Rawimage参数"><a href="#Rawimage参数" class="headerlink" title="Rawimage参数"></a>Rawimage参数</h4><p>它的外观上和Image无任何区别，仅在参数上有所不同</p>
<p>参数面板如图</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="Unity-UGUI/image-20220525172616185.png" alt="image-20220525172616185" style="zoom:100%;" /></p>
<ul>
<li><strong>Texture</strong>：图像纹理</li>
</ul>
<blockquote>
<p>它可以关联任何类型的图片，而不仅仅是Sprite</p>
</blockquote>
<h4 id="代码控制-2"><a href="#代码控制-2" class="headerlink" title="代码控制"></a>代码控制</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RawImage raw = <span class="keyword">this</span>.GetComponent&lt;RawImage&gt;();</span><br><span class="line">raw.texture = Resources.Load&lt;Texture&gt;(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="组合控件"><a href="#组合控件" class="headerlink" title="组合控件"></a>组合控件</h2><h3 id="Button按钮"><a href="#Button按钮" class="headerlink" title="Button按钮"></a>Button按钮</h3><p>Button是按钮组件，是UGUI中用于<strong>处理玩家按钮交互</strong>的关键组件</p>
<p>默认创建的Button是由2个对象组成</p>
<blockquote>
<p>父对象是Button组件所依附对象，同时挂载了一个Image组件，作为按钮图片</p>
<p>子对象是Text组件，用于显示按钮文本。该组件是可选项，若Button图片上以及做好了文字，则不需要Text组件</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/blog/Unity-UGUI/image-20220526190230847.png" class="" title="image-20220526190230847">
<h4 id="Button参数"><a href="#Button参数" class="headerlink" title="Button参数"></a>Button参数</h4><p>参数面板如图</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="Unity-UGUI/image-20220526190447920.png" alt="image-20220526190447920" style="zoom:100%;" /></p>
<ul>
<li><strong>Interactable</strong>：按钮是否能够被点击</li>
</ul>
<blockquote>
<p>该选项默认勾选，取消勾选后Button不能被点击</p>
</blockquote>
<ul>
<li><strong>Transition</strong>：按钮被点击时的过渡效果</li>
</ul>
<blockquote>
<p>该选项用来设置按钮被点击时所发生的反馈效果</p>
<p>1、<strong>默认为Color Tinr</strong>，点击按钮后用不同的颜色来反馈</p>
<p>Target Graphic：用于关联Button按钮上的图片</p>
<p>Normal Color：正常状态下的Button颜色</p>
<p>Highlighted Color：鼠标移动到Button按钮上时，所显示的颜色</p>
<p>Pressed Color：鼠标按下Button时，所显示的颜色</p>
<p>Selected Color：当鼠标上一次按下结束，下一次按下未开始时，当前鼠标的焦点就会处于Button上，也就是处于选中状态</p>
<p>Disabled Color：当鼠标取消Interactable时，所显示的颜色</p>
<p><strong>FadeDuration</strong>：Button从一种颜色变为另一种颜色所需时间</p>
<p>2、Sprite Swap：用图片表示不同状态时的变化</p>
<p>3、Animation：用动画表示不同状态时的变化</p>
</blockquote>
<ul>
<li><strong>Navigation</strong>：导航模式</li>
</ul>
<blockquote>
<p>可以用键盘的方向键或W/S/A/D去<strong>控制多个Button之间的切换</strong>。可以通过开启Visualize 来看到多个Button之间的导航线</p>
<p>None：不能通过键盘控制多个Button之间的切换</p>
<p>Everything：自动</p>
<p>Horizontal：只能控制水平方向之间的切换</p>
<p>Verticval：只能控制垂直方向之间的切换</p>
<p>Autiomatic：自动导航</p>
<p>Explicit：指定关联某个方向上的Button按钮</p>
</blockquote>
<h4 id="代码控制-3"><a href="#代码控制-3" class="headerlink" title="代码控制"></a>代码控制</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Button btn = <span class="keyword">this</span>.GetComponent&lt;Button&gt;();</span><br><span class="line"><span class="comment">//按钮可以被点击</span></span><br><span class="line">btn.interactable = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若想改变Button上的图片,可以直接改变Image组件</span></span><br><span class="line">Image img = <span class="keyword">this</span>.GetComponent&lt;Image&gt;();</span><br></pre></td></tr></table></figure>
<h4 id="监听点击事件的两种方式"><a href="#监听点击事件的两种方式" class="headerlink" title="监听点击事件的两种方式"></a>监听点击事件的两种方式</h4><p>点击事件是在Button区域抬起、按下一次，才算一次点击</p>
<blockquote>
<p>若在Button区域按下，区域外抬起 则不算点击</p>
</blockquote>
<p>方式1：拖动脚本</p>
<ul>
<li>通过点击面板On Click()上的”+”号，就会出现以下内容</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="Unity-UGUI/image-20220526195229707.png" alt="image-20220526195229707" style="zoom:100%;" /></p>
<ul>
<li>我们将需要监听的Button按钮拖动到None中，与之关联</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="Unity-UGUI/image-20220526195407828.png" alt="image-20220526195407828" style="zoom:100%;" /></p>
<ul>
<li>此时No Function就会被激活，我们就能选择依附在Button脚本上的函数</li>
</ul>
<blockquote>
<p>此时当我们再点击Button后，就会调用选择好的函数。不过此处只能选择公共函数，私有函数不能选择</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/blog/Unity-UGUI/image-20220526195716754.png" class="" title="image-20220526195716754">
<p>方式2：代码关联</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若面板上的按钮较多，则可以使用代码的方式完成关联</span></span><br><span class="line">Button btn = <span class="keyword">this</span>.GetComponent&lt;Button&gt;();</span><br><span class="line"><span class="comment">//通过获取的btn对象，来获取监听,并往其中传入一个委托函数即可</span></span><br><span class="line">btn.OnClick.AddListener(ClickBtn);</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除监听</span></span><br><span class="line">btn.OnClick.RemoveListener(ClickBtn);</span><br><span class="line"><span class="comment">//移除所有监听函数</span></span><br><span class="line">btn.OnClick.RemoveAllListener();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClickBtn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    print(<span class="string">&quot;按钮被点击&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例：点击按钮后发射子弹"><a href="#示例：点击按钮后发射子弹" class="headerlink" title="示例：点击按钮后发射子弹"></a>示例：点击按钮后发射子弹</h4><blockquote>
<p>思路：</p>
<p>1、创建游戏对象</p>
<p>2、创建子弹对象</p>
<p>3、拼UI面板</p>
</blockquote>
<ul>
<li>创建一个游戏对象，并在脚本中实现子弹的创建</li>
</ul>
<blockquote>
<p>该游戏对象和其脚本仅用于创建预设体子弹，而子弹的移动功能则写在子弹的脚本中</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Test脚本，作用于GamePlayer中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fire</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//动态创建子弹对象,并设置子弹出现的位置和角度</span></span><br><span class="line">        GameObject obj = Instantiate(Resources.Load&lt;GameObject&gt;(<span class="string">&quot;Bullet&quot;</span>), <span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.rotation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建子弹对象，并在脚本中实现子弹的移动功能</li>
</ul>
<blockquote>
<p>将子弹对象拖入到Resources文件夹下，将其做成预设体</p>
<p>之后再从BulletObject脚本中完成子弹移动功能</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Bulletobject脚本，作用于Bulletd</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BulletObject</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> moveSpeed = <span class="number">20</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//延迟3s后，删除子弹</span></span><br><span class="line">        Destroy(<span class="keyword">this</span>.gameObject, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//子弹移动</span></span><br><span class="line">        <span class="keyword">this</span>.transform.Translate(moveSpeed * Vector3.forward * Time.deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建面板Panel作为Button按钮的父对象</li>
</ul>
<blockquote>
<p>Panel的其实就是添加了一个Image组件，只不过锚点分布在全屏</p>
<p>所以它会随着分辨率的变化，面板大小也会随之变化</p>
<p>我们将Image组件移除后，就是一个随着屏幕变化的画布</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GamePanel脚本，作用于GamePanel对象中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GamePanel</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Button btnAtk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Test player;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//通过lambda表达式和匿名函数，调用开火方法</span></span><br><span class="line">        btnAtk.onClick.AddListener(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            player.Fire();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<blockquote>
<p>拼面板前，我们会添加一个Panel，它的锚点分布在全屏</p>
<p>这样面板的大小会随着屏幕的分辨率而自适应</p>
<p>并且拼面板前最重要的步骤</p>
<p>1、修改Canvas中的UI渲染模式，将其改为Scale With Screen Size</p>
<p>2、若是横屏游戏，就要将Match拖动到1</p>
</blockquote>
<hr>
<h3 id="Toggle开关控件"><a href="#Toggle开关控件" class="headerlink" title="Toggle开关控件"></a>Toggle开关控件</h3><p>Toggle是UGUI中用于<strong>处理玩家单选框或多选框相关交互</strong>的组件</p>
<p>Toggle组件<strong>默认为多选框</strong>，可以配合ToggleGrounp组件制作为单选框</p>
<p>默认创建的Toggle是由<strong>4个对象</strong>组成</p>
<blockquote>
<p>父对象中有一个Toggle组件</p>
<p>子对象Background中有一个Image组件表示背景图(必选)，还有一个Label对象中有一个Text组件表示说明文字(可选)</p>
<p>而Background组件中又有一个子对象Checkmark，它也挂载了一个Image组件用来表示选中时的图案</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="Unity-UGUI/image-20220527112300032.png" alt="image-20220527112300032" style="zoom:100%;" /></p>
<h4 id="Toggle参数"><a href="#Toggle参数" class="headerlink" title="Toggle参数"></a>Toggle参数</h4><p>参数面板如图</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="Unity-UGUI/image-20220527112440758.png" alt="image-20220527112440758" style="zoom:100%;" /></p>
<ul>
<li><strong>Interactable</strong>：是否能被点击，效果和Button相同</li>
<li>Transition：点击时的过渡效果，和Button类似</li>
<li>Navigation：通过键盘控制多个控件，和Button类型</li>
</ul>
<blockquote>
<p>以上的三个参数内容和作用都与Button类似</p>
</blockquote>
<ul>
<li><strong>Is On</strong>：控件默认的选中状态，若勾选，则运行时为勾选状态</li>
<li><strong>Toggle Transition</strong>：开关图片的过度效果</li>
</ul>
<blockquote>
<p>默认为Fade，当我们点击Toggle时，会出现淡入淡出的勾选图案</p>
<p>另一个参数为None，即没有过渡效果</p>
<p>此处若想节约性能，就关闭过渡效果</p>
</blockquote>
<ul>
<li><strong>Graphic</strong>：用于关联Toggle被选中时出现的图片</li>
</ul>
<blockquote>
<p>这里会默认关联Checkmark对象上的图片</p>
<p>而我们若想更换图片，也不会在Graphic参数中更换关联</p>
<p>而是直接更改Checkmark对象上的图片</p>
</blockquote>
<ul>
<li><strong>Group</strong>：用于关联挂载Toggle Group的对象，来制作单选框</li>
</ul>
<blockquote>
<p>当我们拥有多个Toggle时，其实就是一个多选框，它们之间不会进行影响</p>
<p>若我们想添加单选框</p>
<p>一般会创建一个空物体ToggleGroup作为多个Toggle的父对象</p>
<p>然后为空物体添加Toggle Group组件</p>
<p>最后再将挂载Toggle Group组件的空对象与其余子对象的Group进行关联</p>
<p>那么被关联的子对象就会处于互斥状态，即只能被勾选一个</p>
</blockquote>
<h4 id="代码控制-4"><a href="#代码控制-4" class="headerlink" title="代码控制"></a>代码控制</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Toggle tog = <span class="keyword">this</span>.GetComponent&lt;Toggle&gt;();</span><br><span class="line">tog.isOn = <span class="literal">true</span>;	<span class="comment">//改变Toggle当前的状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过ToggleGroup来得到当前处于激活状态时的控件</span></span><br><span class="line">ToggleGroup togGroup = <span class="keyword">this</span>.GetComponent&lt;ToggleGroup&gt;();</span><br><span class="line">togGroup.allowSwitchOff = <span class="literal">false</span>;	<span class="comment">//可以让开关一个都不勾选</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历ToggleGroup迭代器得到当前选中的 Toggle</span></span><br><span class="line"><span class="keyword">foreach</span>(Toggle item <span class="keyword">in</span> togGroup.ActiveToggles())&#123;</span><br><span class="line">    print(item.name + <span class="string">&quot;&quot;</span> + item.isOn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="监听事件的两种方式"><a href="#监听事件的两种方式" class="headerlink" title="监听事件的两种方式"></a>监听事件的两种方式</h4><p>方式1：托脚本</p>
<ul>
<li>点击On Value Changed面板上的 + 号，就会出现如下面板</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="Unity-UGUI/image-20220527142924368.png" alt="image-20220527142924368" style="zoom:100%;" /></p>
<ul>
<li>将需要相应的Toggle对象拖入None中，就能激活Toggle对象身上的脚本</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="Unity-UGUI/image-20220527143123639.png" alt="image-20220527143123639" style="zoom:100%;" /></p>
<ul>
<li>然后就能找到Toggle脚本上对应的函数，该函数参数必须为Boolean</li>
</ul>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/blog/Unity-UGUI/image-20220527143355841.png" class="" title="image-20220527143355841">
<blockquote>
<p>之后我们改变当前Toggle的状态，就能触发一次函数</p>
<p>注意：</p>
<p>在选择函数的过程中，应该选择上方的Dynamic bool函数</p>
</blockquote>
<p>方式2：代码添加</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    Toggle tog;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">         tog = <span class="keyword">this</span>.GetComponent&lt;Toggle&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//委托的方式添加</span></span><br><span class="line">        tog.onValueChanged.AddListener(ChangValue2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//lambda表达式方式添加，可以不用额外写函数</span></span><br><span class="line">        tog.onValueChanged.AddListener((a) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;代码监听 状态改变&quot;</span> + a);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ChangValue2</span>(<span class="params"><span class="built_in">bool</span> v</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        print(<span class="string">&quot;代码监听 状态改变&quot;</span> + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例：通过Toggle开关-控制音效"><a href="#示例：通过Toggle开关-控制音效" class="headerlink" title="示例：通过Toggle开关 控制音效"></a>示例：通过Toggle开关 控制音效</h4><p><a target="_blank" rel="noopener" href="https://www.taikr.com/course/1203/task/39576/show">https://www.taikr.com/course/1203/task/39576/show</a></p>
<hr>
<h3 id="InputField文本输入"><a href="#InputField文本输入" class="headerlink" title="InputField文本输入"></a>InputField文本输入</h3><p>InputField是输入字段组件，用于UGUI中<strong>处理玩家文本输入</strong>相关的组件</p>
<p>默认创建的InputField由3个对象组成</p>
<blockquote>
<p>父对象是挂载了InputField组件，还有一个Iamge组件作为背景图</p>
<p>子对象上Placeholder上挂载了Text组件，用来提示需要输入的文本</p>
<p>另一个子对象Text上挂载了Text组件，用于输入文本</p>
</blockquote>
<h4 id="InputField参数"><a href="#InputField参数" class="headerlink" title="InputField参数"></a>InputField参数</h4><p>参数面板如图</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="Unity-UGUI/image-20220527154632816.png" alt="image-20220527154632816" style="zoom:100%;" /></p>
<ul>
<li><strong>TextComponent</strong>：用于关联显示输入内容的文本组件</li>
</ul>
<blockquote>
<p>一般创建号InputFiled对象后，它会默认关联Text对象</p>
</blockquote>
<ul>
<li><strong>Text</strong>：输入框的起始默认值</li>
</ul>
<blockquote>
<p>在该处输入的值，在运行程序后会变成默认值</p>
</blockquote>
<ul>
<li><strong>Character Limit</strong>：可以输入字符长度的最大值</li>
</ul>
<blockquote>
<p>默认值为0.也就是没有限制。若将其改为11，则最多只能输入11个字符</p>
</blockquote>
<ul>
<li><strong>Content Type</strong>：输入文本的字符限制</li>
</ul>
<blockquote>
<p>默认为Standard：标准模式，可以输入任意字符</p>
<p>Autocorrected：自动更正模式。会自动提示或者替换某些词</p>
<p>Integer Number：整数模式。只能输入整数</p>
<p>Decimal Number：十进制模式。只能输入数字或者小数</p>
<p>Alphanumeric：字母数字模式。只能输入字母和数字</p>
<p>Name：名字模式。自动将每个单词首字母大写</p>
<p>Email Address：邮箱地址模式。允许最多输入一个@符合组成的字符</p>
<p>Password：密码模式。会用星号隐藏字符，<strong>允许使用符号</strong></p>
<p>Pin：类似密码模式，不过<strong>只能输入整数</strong></p>
</blockquote>
<ul>
<li>Line Type：行类型，用于定义文本格式</li>
</ul>
<blockquote>
<p>默认参数为Single Line：只允许单行显示，不允许空行</p>
<p>Multi Line Submit：允许使用多行。当宽度不够时，会自动空行</p>
<p>Multi Line NewLine：允许使用多行。用户按回车键空行</p>
</blockquote>
<ul>
<li>Placeholder：关联用于提示输入文本的对象</li>
</ul>
<blockquote>
<p>默认会关联Placeholder对象</p>
</blockquote>
<ul>
<li>Caret Blink Rate：光标闪烁速度</li>
</ul>
<blockquote>
<p>值越大，光标闪烁的越快，一般使用默认值</p>
</blockquote>
<ul>
<li><p>Custom Caret Color：自定义光标颜色</p>
</li>
<li><p>Selection Color：鼠标选中文本时所显示的颜色</p>
</li>
<li>Read Only：只读，不能修改</li>
</ul>
<blockquote>
<p>开启后，文本框的内容不能被修改。用于某些固定的文本，方便复制</p>
</blockquote>
<h4 id="代码控制-5"><a href="#代码控制-5" class="headerlink" title="代码控制"></a>代码控制</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputField input = <span class="keyword">this</span>.GetComponent&lt;InputField&gt;();</span><br><span class="line">input.text = <span class="string">&quot;123&quot;</span>;<span class="comment">//设置文本</span></span><br></pre></td></tr></table></figure>
<h4 id="监听事件的两种方式-1"><a href="#监听事件的两种方式-1" class="headerlink" title="监听事件的两种方式"></a>监听事件的两种方式</h4><p>InputFiled有两种事件监听</p>
<p>On Value Changed：当文本框中内容改变时，就会调用</p>
<p>On End edit：当文本框内容结束编辑后调用</p>
<blockquote>
<p>只要焦点不再文本框内，都算结束输入</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">InputField input = <span class="keyword">this</span>.GetComponent&lt;InputField&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//内容每次改变时调用</span></span><br><span class="line">input.onValueChanged.AddListener((str)=&gt;&#123;</span><br><span class="line">   print(<span class="string">&quot;代码监听&quot;</span>); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束编辑后调用</span></span><br><span class="line">input.OnEndEdit.AddListener((str)=&gt;&#123;</span><br><span class="line">   print(<span class="string">&quot;代码监听&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="示例：通过点击改名按钮完成改名"><a href="#示例：通过点击改名按钮完成改名" class="headerlink" title="示例：通过点击改名按钮完成改名"></a>示例：通过点击改名按钮完成改名</h4><p><a target="_blank" rel="noopener" href="https://www.taikr.com/course/1203/task/39580/show">https://www.taikr.com/course/1203/task/39580/show</a></p>
<h3 id="Slider滑动条"><a href="#Slider滑动条" class="headerlink" title="Slider滑动条"></a>Slider滑动条</h3><p>Slider是滑动条组件，用于UGUI中<strong>处理滑动条相关</strong>交互的组件</p>
<p>默认创建的Slider是由4组对象组成</p>
<blockquote>
<p>父对象 Slider上挂载了Slider组件</p>
<p>子对象 Background挂载了Image，用于显示背景图</p>
<p>Fill Area和 Handle Slide Area都是空物体，只是为了设置锚点范围，真正显示图片的是它们各自的子对象</p>
<p>Fill 挂载了Image，用于显示填充进度图</p>
<p>Handle挂载了Image，用于显示滑动块</p>
</blockquote>
<h4 id="Slider参数"><a href="#Slider参数" class="headerlink" title="Slider参数"></a>Slider参数</h4><p>参数面板如图</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="Unity-UGUI/image-20220527163611216.png" alt="image-20220527163611216" style="zoom:100%;" /></p>
<ul>
<li>FillRect：关联用于填充进度条的图像</li>
</ul>
<blockquote>
<p>默认关联Fill</p>
</blockquote>
<ul>
<li>Handle Rect：关联用于滑动的滑动块图像</li>
</ul>
<blockquote>
<p>默认关联Handle</p>
</blockquote>
<ul>
<li><strong>Direction</strong>：滑动条值增加的方向</li>
</ul>
<blockquote>
<p>默认从左到右增加</p>
</blockquote>
<ul>
<li><p><strong>Min Value、Max Value</strong>：设置滑动条在底端和顶端的最小值和最大值</p>
</li>
<li><p><strong>Whole Numbers</strong>：是否约束为整数值变化</p>
</li>
</ul>
<blockquote>
<p>开启后，滑动条的值只能在整数进行变化</p>
</blockquote>
<ul>
<li><strong>Value</strong>：当前滑动条代表的数值</li>
<li><strong>On Value Changed：滑动条值改变时执行的函数</strong></li>
</ul>
<h4 id="代码控制-6"><a href="#代码控制-6" class="headerlink" title="代码控制"></a>代码控制</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Slider s = <span class="keyword">this</span>.GetComponent&lt;Slider&gt;();</span><br><span class="line">s.<span class="keyword">value</span>;	<span class="comment">//得到当前滑动块的值</span></span><br></pre></td></tr></table></figure>
<h4 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h4><p>Slider控件监听函数需要float参数</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Slider s = <span class="keyword">this</span>.GetComponent&lt;Slider&gt;();</span><br><span class="line">s.onValueChanged.AddListener(()=&gt;&#123;</span><br><span class="line">    print(<span class="string">&quot;代码监听&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="示例：通过滑动条控制音量大小"><a href="#示例：通过滑动条控制音量大小" class="headerlink" title="示例：通过滑动条控制音量大小"></a>示例：通过滑动条控制音量大小</h4><hr>
<h3 id="Scrollbar滚动条"><a href="#Scrollbar滚动条" class="headerlink" title="Scrollbar滚动条"></a>Scrollbar滚动条</h3><p>Scrollbar是滚动条组件，是UGUI中<strong>用于处理滚动条相关</strong>的组件</p>
<p>默认是由2组对象组成</p>
<blockquote>
<p>父对象Scrollbar对象依附了Scrollbar组件，还有显示滑块的Image组件</p>
<p>子对象Sliding Area对象是空物体。设置了锚点范围</p>
<p>真正的底图是依附在Sliding Area的子对象 Handle对象上</p>
<p>一般情况下我们不会单独使用滚动条，都是配合ScrollView来使用</p>
</blockquote>
<h4 id="Scrollbar参数"><a href="#Scrollbar参数" class="headerlink" title="Scrollbar参数"></a>Scrollbar参数</h4><p>参数面板如图</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="Unity-UGUI/image-20220528150359235.png" alt="image-20220528150359235" style="zoom:100%;" /></p>
<ul>
<li>Handle Rect：关联滚动条底图对象</li>
<li><strong>Direction</strong>：滚动条滚动的方向</li>
<li><strong>Value</strong>：程序运行时，滚动条的初始位置(0~1)</li>
<li><strong>Size</strong>：滚动块占滚动条的大小比例(0~1)</li>
<li>Number Of Steps：设置滚动条可以滚动多少次</li>
</ul>
<blockquote>
<p>初始值为0，滚动时比较平滑。若将其设置为10，则表示将滚动条平均分为10等分，每次滚动10分之一</p>
</blockquote>
<h4 id="代码控制-7"><a href="#代码控制-7" class="headerlink" title="代码控制"></a>代码控制</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Scrollbar sb = <span class="keyword">this</span>.GetComponent&lt;Scrollbar&gt;();</span><br><span class="line"><span class="comment">//一般只能通过代码控制value 和 size的值</span></span><br><span class="line">sb.<span class="keyword">value</span>;</span><br><span class="line">sb.size;</span><br></pre></td></tr></table></figure>
<h4 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Scrollbar sb = <span class="keyword">this</span>.GetComponent&lt;Scrollbar&gt;();</span><br><span class="line"></span><br><span class="line">sb.OnValueChanged.AddListener((v)=&gt;&#123;</span><br><span class="line">    print(<span class="string">&quot;代码监听&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Scorll-View滚动视图"><a href="#Scorll-View滚动视图" class="headerlink" title="Scorll View滚动视图"></a>Scorll View滚动视图</h3><p>ScorllView是滚动视图组件，是UGUI中<strong>处理滚动视图相关</strong>的组件</p>
<p>默认创建的ScrollView是由4组对象构成</p>
<blockquote>
<p>父对象ScrollView上依附了ScorllRect组件，和一个用于显示背景图的Image</p>
<p>子对象</p>
<p>1、Viewport对象，其子对象Content用来控制滚动视图的范围和内容显示(必须保留)</p>
<p>2、Scrollbar Horizontal，水平滚动条(可选)</p>
<p>3、Scrollbar Vertical，竖直滚动条(可选)</p>
</blockquote>
<h4 id="Scorll-View参数"><a href="#Scorll-View参数" class="headerlink" title="Scorll View参数"></a>Scorll View参数</h4><p>参数面板如图</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="Unity-UGUI/image-20220528152154300.png" alt="image-20220528152154300" style="zoom:100%;" /></p>
<ul>
<li><strong>Content</strong>：用于关联<strong>滚动视图实际所能显示的内容范围</strong>对象</li>
</ul>
<blockquote>
<p>该参数会默认关联Viewport下的Content</p>
<p>它的范围就是滚动视图的容量范围，不是滚动视图的视口范围</p>
<p>若它的范围增大，则可以通过滑动滚动条，看到原本视口以外的东西</p>
<p>它会作为所有对象的父对象存在，Scroll View当中所有的视图都会放在它下面</p>
</blockquote>
<ul>
<li><strong>Horizontal &amp; Vertical</strong>：启用水平拖动 和 竖直拖动</li>
</ul>
<blockquote>
<p>默认都是开启状态。这里要注意的是</p>
<p>不管开启与否，都不会影响滚动条的存在，它只是限制了滚动条的作用</p>
</blockquote>
<ul>
<li><strong>Movement Type</strong>：滚动视图元素的运动类型</li>
</ul>
<blockquote>
<p>默认为<strong>Elastic</strong>(常用)：回弹效果，当滚出边缘后，会弹回边界</p>
<p><strong>Clamped</strong>：夹紧效果，始终限制在范围内，没有回弹效果</p>
</blockquote>
<ul>
<li><strong>Inertia</strong>：移动惯性，拖动时会有一个惯性效果</li>
</ul>
<blockquote>
<p>默认开启，通过Deceleration Rate来控制减速效果，0没有惯性，1不会停</p>
</blockquote>
<ul>
<li><strong>Scroll Sensitivity</strong>：鼠标中间控制滚动条的灵敏度</li>
</ul>
<blockquote>
<p>默认值为1，但实际体验效果偏慢，可以将值改为5较为合适</p>
</blockquote>
<ul>
<li><strong>Viewport</strong>：关联滚动视图<strong>内容视口</strong>对象</li>
</ul>
<blockquote>
<p>Viewport是用来控制滚动视图的视口，改变它的大小，可以改变视口大小</p>
<p>可以将Viewport理解为杯子的杯口，杯口多大，我们看到的东西就只有多大</p>
<p>而Content则是杯子的容量，表示实际上可以装多少东西</p>
</blockquote>
<ul>
<li>Horizontal &amp; Vertical Scrollbar：用于关联水平和竖直滚动条</li>
</ul>
<blockquote>
<p>若当前游戏不需要滚动条，可以直接删除Horizontal &amp; Vertical Scrollbar对象，并在参数中将其置空</p>
<p>最后调整Spacing参数，调整视口和滚动条的间距</p>
</blockquote>
<ul>
<li><strong>Visbility</strong>：根据Content的大小，来判断是否要隐藏滚动条</li>
</ul>
<blockquote>
<p>默认为Auto Hide And Expand View，</p>
<p>即当Content大于Viewport时，滚动条会自动出现，并会自动扩展Viewport</p>
<p>即当Content小于Viewport时，滚动条会自动消失</p>
<p>1、parmenent：始终显示滚动条，当Content小于Viewport时，滚动条也会显示，一般不常用</p>
<p>2、Auto Hide：自动隐藏滚动条，但不会拓展Viewport</p>
</blockquote>
<ul>
<li><strong>Spacing</strong>：滚动条和视口之间的间隔</li>
</ul>
<blockquote>
<p>默认值为-3，表示滚动条和视口之间有重叠</p>
</blockquote>
<h4 id="代码控制-8"><a href="#代码控制-8" class="headerlink" title="代码控制"></a>代码控制</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般是通过Scorll View来得到Content，然后再视图窗口中进行动态创建对象</span></span><br><span class="line"></span><br><span class="line">ScrollRect sr = <span class="keyword">this</span>.GetComponent&lt;ScrollRect&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变内容的大小，具体可以拖动多少，都是根据它的尺寸来的</span></span><br><span class="line">sr.content.sizeDelta = <span class="keyword">new</span> Vetor(<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变位置，范围是0~1</span></span><br><span class="line">sr.normalizedPosition = <span class="keyword">new</span> Vector2(<span class="number">0</span>,<span class="number">0.5f</span>);</span><br></pre></td></tr></table></figure>
<h4 id="监听事件-1"><a href="#监听事件-1" class="headerlink" title="监听事件"></a>监听事件</h4><p>监听函数的<strong>参数类型为Vector2</strong>，代表当前x、y方向上移动的位置</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sr.OnValueChanged.AddListener((ver)=&gt;)&#123;</span><br><span class="line">    print(ver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>一般用Scorll View来制作<strong>背包、商店、排行榜</strong>等功能</p>
<p>而我们动态创建的对象，都需要放到Content下面</p>
<hr>
<h3 id="Dropdown下拉列表"><a href="#Dropdown下拉列表" class="headerlink" title="Dropdown下拉列表"></a>Dropdown下拉列表</h3><p>Dropdown是UGUI中<strong>用于处理下拉列表</strong>相关的组件</p>
<p>默认创建的Dropdown是由4组对象组成</p>
<blockquote>
<p>父对象Dropdown上依附了Dropdowm组件和一个显示背景的Image组件</p>
<p>子对象</p>
<p>1、Lable对象上依附了Text组件，用来显示当前选项描述</p>
<p>2、Arrow对象上依附了Image组件，用来显示向下的箭头图片</p>
<p>3、Template对象默认失活，依附了Scroll Rect组件，用来表示下拉列表选单</p>
</blockquote>
<h4 id="Dropdowm相关参数"><a href="#Dropdowm相关参数" class="headerlink" title="Dropdowm相关参数"></a>Dropdowm相关参数</h4><p>参数面板如图</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="Unity-UGUI/image-20220528162227059.png" alt="image-20220528162227059" style="zoom:100%;" /></p>
<ul>
<li>Template：关联下拉列表对象</li>
<li>Caption Text：关联显示当前选择内容的文本组件</li>
<li>Caption Image：关联显示当前选择内容的图片组件</li>
</ul>
<blockquote>
<p>下拉列表除了关联文字，也还可以关联图片</p>
<p>当我们在这关联图片后，下拉列表就能关联到图片</p>
</blockquote>
<ul>
<li><strong>Value</strong>：当前所选项的索引值</li>
</ul>
<blockquote>
<p>若当前列表选中的是OptionA，则索引值为0，类似于数组下标</p>
</blockquote>
<ul>
<li>Alpha Fada Speed：下拉列表窗口时的过渡速度</li>
<li><strong>Options</strong>：存在的选项列表</li>
</ul>
<blockquote>
<p>通过修改其中的文本，就能修改下拉列表时的内容</p>
</blockquote>
<hr>
<h2 id="图集制作"><a href="#图集制作" class="headerlink" title="图集制作"></a>图集制作</h2><p>UGUI和NGUI使用上最大的不同 就是NGUI在<strong>使用前需要打图集</strong>，而UGUI可以之后再打图集</p>
<p>打图集的目的就是为了<strong>减少DrawCall 提高性能</strong></p>
<h3 id="Unity中自带的打图集功能"><a href="#Unity中自带的打图集功能" class="headerlink" title="Unity中自带的打图集功能"></a>Unity中自带的打图集功能</h3><p>Unity中默认的打包图集功能是关闭的，需要在</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/blog/Unity-UGUI/image-20220601213251796.png" class="" title="image-20220601213251796">
<p>Edit-&gt;Project Setting-&gt;Editor中寻找到<strong>Sprite Packer</strong></p>
<blockquote>
<p>参数如下</p>
<p>默认为Disabled：不会打包图集</p>
<p>Enabled For Bulids(Legacy Sprite Packer)：仅在构建时打包图集，编辑模式下不能打包图集</p>
<p>Always Enabled(Legacy Sprite Packer)：任何时候都能打包图集</p>
<p>其中(Legacy Sprite Packer)代表传统模式，它多了一个设置图片间隔的参数</p>
<ul>
<li>Padding Power：数字参数代表小图之间的间隔像素，为2的n次方</li>
</ul>
</blockquote>
<h3 id="Unity图集注意事项"><a href="#Unity图集注意事项" class="headerlink" title="Unity图集注意事项"></a>Unity图集注意事项</h3><p><strong>创建图集</strong>时需要注意Unity2020中Sprite Atals被拆分到了2D中</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/blog/Unity-UGUI/image-20220601213857765.png" class="" title="image-20220601213857765">
<p>Sprite Atlas参数面板如下</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="Unity-UGUI/image-20220601214059378.png" alt="image-20220601214059378" style="zoom:100%;" /></p>
<ul>
<li>Allow Rotation：打图集时是否会自动旋转角度</li>
</ul>
<blockquote>
<p>若有一大一小两张图片，在打图集时，为了节约性能，可能会将大图进行旋转到合适的角度进行打包。</p>
<p>但是在制作UI时不建议勾选，因为它在UI中的表现会将UI也一起旋转</p>
</blockquote>
<ul>
<li>Tight Packing：制作UI图集时也不建议勾选</li>
</ul>
<hr>
<h2 id="UI事件监听接口"><a href="#UI事件监听接口" class="headerlink" title="UI事件监听接口"></a>UI事件监听接口</h2><p>目前所有的控件都只提供了常用的事件监听列表</p>
<p>如果想要做一些类似<strong>长按、双击、拖拽</strong>等功能是无法制作的</p>
<p>或者想让<strong>Image、Text、RawImage</strong>等控件响应玩家输入也是无法制作的</p>
<p>所以事件接口就是用来处理类似问题，<strong>让所有控件都能够添加更多的事件监听来处理对应的逻辑</strong></p>
<blockquote>
<p>比如Button按钮中自带了onClick事件监听，所以它能处理点击事件</p>
<p>但它就处理不了长按、双击等更多的逻辑</p>
</blockquote>
<h3 id="有哪些事件接口"><a href="#有哪些事件接口" class="headerlink" title="有哪些事件接口"></a>有哪些事件接口</h3><p><strong>鼠标点击时调用事件</strong></p>
<ul>
<li>IPointerEnterHandler - OnPointerEnter：当鼠标<strong>进入</strong>对象时调用</li>
<li>IPointerExitHandler - OnPointerExit：当鼠标<strong>离开</strong>时调用</li>
<li>IPointerDownHandler - OnPointerDowm：当鼠标<strong>按下</strong>时调用</li>
<li><p>IPointerUpHandler - OnPointerUp：鼠标按下<strong>松开</strong>后调用</p>
</li>
<li><p>IPointerClickHandler - OnPointerClick：鼠标点击时调用</p>
</li>
</ul>
<p><strong>鼠标拖拽时调用事件</strong></p>
<ul>
<li>IBeginDragHandler - OnBeginDrag：开始拖拽时调用</li>
<li>IDragHandler - OnDrag：拖拽中调用</li>
<li>IEndDragHandler - OnEndDrag：结束拖动时调用</li>
</ul>
<blockquote>
<p>当我们想监听这些事件时，那就继承它们的接口，然后实现该方法。最后再将脚本挂载到想要监听的对象上</p>
<p>当我们对对象进行操作时，就会自动调用监听函数中的逻辑</p>
<p>注意：</p>
<p>鼠标进入事件，在移动端是不存在的，因为手机并没有鼠标</p>
</blockquote>
<h3 id="使用事件监听接口"><a href="#使用事件监听接口" class="headerlink" title="使用事件监听接口"></a>使用事件监听接口</h3><ol>
<li>引用UnityEngine.EventSystems命名空间，然后继承MonoBehavior的脚本 继承对应的事件接口</li>
<li>实现接口中的内容</li>
<li>讲该脚本挂载到想要监听自定义事件的UI控件上</li>
<li>最后要确保控件的<strong>Raycast Target开启</strong>，否则将不具备射线检测的功能</li>
</ol>
<blockquote>
<p>以添加鼠标进入这个接口为例</p>
<p>1、在Mono后面继承IPointerEnterHandler接口</p>
<p>2、在类中实现接口，并在接口中写逻辑</p>
<p>3、将脚本挂载到目标组件上</p>
<p>代码如下</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewBehaviourScript</span> : <span class="title">MonoBehaviour</span>,<span class="title">IPointerEnterHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//接口实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerEnter</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        print(<span class="string">&quot;鼠标进入&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="PointerEventDate参数相关"><a href="#PointerEventDate参数相关" class="headerlink" title="PointerEventDate参数相关"></a>PointerEventDate参数相关</h3><ul>
<li><strong>pointerId</strong>：通过打印Id来判断鼠标的左、中、右等按键的点击</li>
<li><strong>position</strong>：当前鼠标在屏幕坐标的实时位置</li>
<li>pressPosition：鼠标按下时的位置</li>
<li><strong>delta</strong>：鼠标移动的增量，即鼠标在移动过程中两点位置的偏移</li>
<li><strong>clickCout</strong>：鼠标连续点击的次数</li>
<li>clickTime：鼠标点击时获取当前系统时间。可以根据两次点击相减，来获得点击的间隔时间</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewBehaviourScript</span> : <span class="title">MonoBehaviour</span>,<span class="title">IPointerEnterHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerEnter</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        print(<span class="string">&quot;鼠标进入&quot;</span>);</span><br><span class="line">        <span class="comment">//左键点击是-1 中键是-2 右键是-3</span></span><br><span class="line">        print(eventData.pointerId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><strong>优点</strong>：可以自定义的监听控件，实现一些长按、双击、拖拽等特殊功能</p>
<p>缺点：不方便管理，需要自己写脚本继承接口挂载到对应控件上</p>
<hr>
<h2 id="EventTigger事件触发器"><a href="#EventTigger事件触发器" class="headerlink" title="EventTigger事件触发器"></a>EventTigger事件触发器</h2><p>事件触发器是EventTrigger组件，它是集成了所有UI事件接口的<strong>脚本</strong></p>
<p>方便我们为控件添加事件监听</p>
<h3 id="如何使用事件触发器"><a href="#如何使用事件触发器" class="headerlink" title="如何使用事件触发器"></a>如何使用事件触发器</h3><p><strong>1、拖拽脚本进行关联</strong></p>
<blockquote>
<p>1、创建控件后，在控件中添加EventTigger脚本</p>
<p>2、通过Event Trigger脚本中的Add New Event Type，选择监听事件</p>
<p>3、在自定义的脚本中完成对应的事件监听函数，逻辑写在该监听函数中</p>
<p>4、创建一个Panel面板，将控件设置为面板的子对象，然后将脚本挂在到面板上</p>
<p>5、点击 + 号，将Panel挂在到监听事件中，然后选择自定义脚本中的监听函数</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewBehaviourScript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestPointerEnter</span>(<span class="params">BaseEventData data</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//将父类转换为子类，得到子类中的eventData中的属性和方法</span></span><br><span class="line">        PointerEventData eventData = data <span class="keyword">as</span> PointerEventData;</span><br><span class="line">        print(<span class="string">&quot;鼠标进入&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="屏幕坐标转UI相对坐标"><a href="#屏幕坐标转UI相对坐标" class="headerlink" title="屏幕坐标转UI相对坐标"></a>屏幕坐标转UI相对坐标</h2><p><strong>RectTransformUtility</strong> 是 RectTransform下的一个辅助类</p>
<p>主要进行一些 坐标转换等操作</p>
<p>目前对于我们来说 最重要的函数是 <strong>将屏幕空间上的点， 转换成UI本地坐标下的点</strong></p>
<blockquote>
<p>作用：将鼠标在屏幕上的点，转换为UI相对于父对象下的点</p>
<p>一般需要配合UI事件监听中的拖拽事件使用</p>
<p>使用场景：</p>
<p>1、制作摇杆</p>
<p>2、实现装备拖拽</p>
</blockquote>
<p>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">参数1、相对父对象</span></span><br><span class="line"><span class="comment">参数2、屏幕点</span></span><br><span class="line"><span class="comment">参数3、摄像机</span></span><br><span class="line"><span class="comment">参数4、最终得到的点</span></span><br><span class="line"><span class="comment">//一般配合拖拽事件使用</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDrag</span><span class="params">(PointerEventDate eventDate)</span></span>&#123;</span><br><span class="line">    Vector2 nowPos;</span><br><span class="line">    RectTransformUtility.ScreenPointToLocalPointInRectangle(</span><br><span class="line">    <span class="keyword">this</span>.transform.parent as RectTransform,<span class="comment">//transform转换为RectTransform</span></span><br><span class="line">    eventData.position,<span class="comment">//鼠标在屏幕上的坐标</span></span><br><span class="line">    evenData.enterEventCamera,<span class="comment">//UI摄像机，而非主摄像机</span></span><br><span class="line">    out nowPos);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.transform.localPostion = nowPos;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/UGUI/">UGUI</a></div><div class="post_share"><div class="social-share" data-image="/media/top_img.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/Unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/media/top_img.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Unity入门基础</div></div></a></div><div class="next-post pull-right"><a href="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E6%A0%88/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/media/top_img.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">栈：如何实现浏览器的前进和后退功能？</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img1.baidu.com/it/u=223483055,1110828441&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=400&amp;h=400" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Chou</div><div class="author-info__description">这个人很懒，什么也没有写~</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" href="https://github.com/zYidian"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:a790623778@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">你这个年纪怎么睡得着jio？</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">1.</span> <span class="toc-text">六大组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Unity%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8UGUI"><span class="toc-number">1.1.</span> <span class="toc-text">Unity中如何使用UGUI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Canvas-%E7%94%BB%E5%B8%83%E7%BB%84%E4%BB%B6"><span class="toc-number">1.2.</span> <span class="toc-text">Canvas(画布组件)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CanvasScaler-%E5%88%86%E8%BE%A8%E7%8E%87%E8%87%AA%E9%80%82%E5%BA%94%E7%BB%84%E4%BB%B6"><span class="toc-number">1.3.</span> <span class="toc-text">CanvasScaler(分辨率自适应组件)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%81%92%E5%AE%9A%E5%83%8F%E7%B4%A0%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text">恒定像素模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%A9%E6%94%BE%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">缩放模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.3.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Graphic-Raycaster-%E5%B0%84%E7%BA%BF%E4%BA%8B%E4%BB%B6%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6"><span class="toc-number">1.4.</span> <span class="toc-text">Graphic Raycaster(射线事件交互组件)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventSystem%E5%92%8CStandalone-Input-Module"><span class="toc-number">1.5.</span> <span class="toc-text">EventSystem和Standalone Input Module</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EventSystem%E7%BB%84%E4%BB%B6"><span class="toc-number">1.5.1.</span> <span class="toc-text">EventSystem组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EventSystem%E7%BB%84%E4%BB%B6%E5%8F%82%E6%95%B0"><span class="toc-number">1.5.2.</span> <span class="toc-text">EventSystem组件参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Standalone-Input-Module%E7%BB%84%E4%BB%B6"><span class="toc-number">1.5.3.</span> <span class="toc-text">Standalone Input Module组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Standalone-Input-Module%E7%BB%84%E4%BB%B6%E5%8F%82%E6%95%B0"><span class="toc-number">1.5.4.</span> <span class="toc-text">Standalone Input Module组件参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">1.5.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RectTransform-%E7%9F%A9%E5%BD%A2%E5%8F%98%E6%8D%A2"><span class="toc-number">1.6.</span> <span class="toc-text">RectTransform(矩形变换)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RectTransfrom%E5%8F%82%E6%95%B0"><span class="toc-number">1.6.1.</span> <span class="toc-text">RectTransfrom参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E8%AE%BE%E7%BD%AE%E4%B8%AD%E5%BF%83%E7%82%B9%E5%92%8C%E9%94%9A%E7%82%B9"><span class="toc-number">1.6.2.</span> <span class="toc-text">快速设置中心点和锚点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AnChor%E9%94%9A%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">AnChor锚点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">三大基础控件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Image%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B6"><span class="toc-number">3.1.</span> <span class="toc-text">Image图片控件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Image%E5%8F%82%E6%95%B0"><span class="toc-number">3.1.1.</span> <span class="toc-text">Image参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6"><span class="toc-number">3.1.2.</span> <span class="toc-text">代码控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Text%E6%96%87%E6%9C%AC%E6%8E%A7%E4%BB%B6"><span class="toc-number">3.2.</span> <span class="toc-text">Text文本控件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Text%E5%8F%82%E6%95%B0%E7%9B%B8%E5%85%B3"><span class="toc-number">3.2.1.</span> <span class="toc-text">Text参数相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E7%BC%98%E7%BA%BF%E5%92%8C%E9%98%B4%E5%BD%B1"><span class="toc-number">3.2.2.</span> <span class="toc-text">边缘线和阴影</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6-1"><span class="toc-number">3.2.3.</span> <span class="toc-text">代码控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rawimage%E5%8E%9F%E5%A7%8B%E5%9B%BE%E5%83%8F%E6%8E%A7%E4%BB%B6"><span class="toc-number">3.3.</span> <span class="toc-text">Rawimage原始图像控件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Rawimage%E5%8F%82%E6%95%B0"><span class="toc-number">3.3.1.</span> <span class="toc-text">Rawimage参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6-2"><span class="toc-number">3.3.2.</span> <span class="toc-text">代码控制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%8E%A7%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text">组合控件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Button%E6%8C%89%E9%92%AE"><span class="toc-number">4.1.</span> <span class="toc-text">Button按钮</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Button%E5%8F%82%E6%95%B0"><span class="toc-number">4.1.1.</span> <span class="toc-text">Button参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6-3"><span class="toc-number">4.1.2.</span> <span class="toc-text">代码控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.3.</span> <span class="toc-text">监听点击事件的两种方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E5%90%8E%E5%8F%91%E5%B0%84%E5%AD%90%E5%BC%B9"><span class="toc-number">4.1.4.</span> <span class="toc-text">示例：点击按钮后发射子弹</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Toggle%E5%BC%80%E5%85%B3%E6%8E%A7%E4%BB%B6"><span class="toc-number">4.2.</span> <span class="toc-text">Toggle开关控件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Toggle%E5%8F%82%E6%95%B0"><span class="toc-number">4.2.1.</span> <span class="toc-text">Toggle参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6-4"><span class="toc-number">4.2.2.</span> <span class="toc-text">代码控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.3.</span> <span class="toc-text">监听事件的两种方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E9%80%9A%E8%BF%87Toggle%E5%BC%80%E5%85%B3-%E6%8E%A7%E5%88%B6%E9%9F%B3%E6%95%88"><span class="toc-number">4.2.4.</span> <span class="toc-text">示例：通过Toggle开关 控制音效</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InputField%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5"><span class="toc-number">4.3.</span> <span class="toc-text">InputField文本输入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#InputField%E5%8F%82%E6%95%B0"><span class="toc-number">4.3.1.</span> <span class="toc-text">InputField参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6-5"><span class="toc-number">4.3.2.</span> <span class="toc-text">代码控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F-1"><span class="toc-number">4.3.3.</span> <span class="toc-text">监听事件的两种方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E9%80%9A%E8%BF%87%E7%82%B9%E5%87%BB%E6%94%B9%E5%90%8D%E6%8C%89%E9%92%AE%E5%AE%8C%E6%88%90%E6%94%B9%E5%90%8D"><span class="toc-number">4.3.4.</span> <span class="toc-text">示例：通过点击改名按钮完成改名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Slider%E6%BB%91%E5%8A%A8%E6%9D%A1"><span class="toc-number">4.4.</span> <span class="toc-text">Slider滑动条</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Slider%E5%8F%82%E6%95%B0"><span class="toc-number">4.4.1.</span> <span class="toc-text">Slider参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6-6"><span class="toc-number">4.4.2.</span> <span class="toc-text">代码控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.4.3.</span> <span class="toc-text">监听事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E9%80%9A%E8%BF%87%E6%BB%91%E5%8A%A8%E6%9D%A1%E6%8E%A7%E5%88%B6%E9%9F%B3%E9%87%8F%E5%A4%A7%E5%B0%8F"><span class="toc-number">4.4.4.</span> <span class="toc-text">示例：通过滑动条控制音量大小</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scrollbar%E6%BB%9A%E5%8A%A8%E6%9D%A1"><span class="toc-number">4.5.</span> <span class="toc-text">Scrollbar滚动条</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Scrollbar%E5%8F%82%E6%95%B0"><span class="toc-number">4.5.1.</span> <span class="toc-text">Scrollbar参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6-7"><span class="toc-number">4.5.2.</span> <span class="toc-text">代码控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC"><span class="toc-number">4.5.3.</span> <span class="toc-text">事件监听</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scorll-View%E6%BB%9A%E5%8A%A8%E8%A7%86%E5%9B%BE"><span class="toc-number">4.6.</span> <span class="toc-text">Scorll View滚动视图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Scorll-View%E5%8F%82%E6%95%B0"><span class="toc-number">4.6.1.</span> <span class="toc-text">Scorll View参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6-8"><span class="toc-number">4.6.2.</span> <span class="toc-text">代码控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6-1"><span class="toc-number">4.6.3.</span> <span class="toc-text">监听事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">4.6.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dropdown%E4%B8%8B%E6%8B%89%E5%88%97%E8%A1%A8"><span class="toc-number">4.7.</span> <span class="toc-text">Dropdown下拉列表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dropdowm%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0"><span class="toc-number">4.7.1.</span> <span class="toc-text">Dropdowm相关参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E9%9B%86%E5%88%B6%E4%BD%9C"><span class="toc-number">5.</span> <span class="toc-text">图集制作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Unity%E4%B8%AD%E8%87%AA%E5%B8%A6%E7%9A%84%E6%89%93%E5%9B%BE%E9%9B%86%E5%8A%9F%E8%83%BD"><span class="toc-number">5.1.</span> <span class="toc-text">Unity中自带的打图集功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unity%E5%9B%BE%E9%9B%86%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.2.</span> <span class="toc-text">Unity图集注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UI%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.</span> <span class="toc-text">UI事件监听接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BA%8B%E4%BB%B6%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.1.</span> <span class="toc-text">有哪些事件接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.2.</span> <span class="toc-text">使用事件监听接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PointerEventDate%E5%8F%82%E6%95%B0%E7%9B%B8%E5%85%B3"><span class="toc-number">6.3.</span> <span class="toc-text">PointerEventDate参数相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">6.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EventTigger%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text">EventTigger事件触发器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">7.1.</span> <span class="toc-text">如何使用事件触发器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%8F%E5%B9%95%E5%9D%90%E6%A0%87%E8%BD%ACUI%E7%9B%B8%E5%AF%B9%E5%9D%90%E6%A0%87"><span class="toc-number">8.</span> <span class="toc-text">屏幕坐标转UI相对坐标</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/blog/Unity%E6%A8%AA%E6%9D%BF%E5%8D%B7%E8%BD%B4%E5%B0%84%E5%87%BB%E6%B8%B8%E6%88%8FDemo/" title="Unity横板卷轴射击游戏Demo"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/media/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity横板卷轴射击游戏Demo"/></a><div class="content"><a class="title" href="/blog/Unity%E6%A8%AA%E6%9D%BF%E5%8D%B7%E8%BD%B4%E5%B0%84%E5%87%BB%E6%B8%B8%E6%88%8FDemo/" title="Unity横板卷轴射击游戏Demo">Unity横板卷轴射击游戏Demo</a><time datetime="2022-07-28T16:04:24.000Z" title="发表于 2022-07-29 00:04:24">2022-07-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F/" title="十大排序"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/media/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="十大排序"/></a><div class="content"><a class="title" href="/blog/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F/" title="十大排序">十大排序</a><time datetime="2022-07-26T13:19:16.000Z" title="发表于 2022-07-26 21:19:16">2022-07-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/Unity%E7%AE%80%E5%8D%95%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F/" title="Unity简单对话系统"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/media/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity简单对话系统"/></a><div class="content"><a class="title" href="/blog/Unity%E7%AE%80%E5%8D%95%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F/" title="Unity简单对话系统">Unity简单对话系统</a><time datetime="2022-07-25T13:10:38.000Z" title="发表于 2022-07-25 21:10:38">2022-07-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/Json%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/" title="Json数据持久化"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/media/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Json数据持久化"/></a><div class="content"><a class="title" href="/blog/Json%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/" title="Json数据持久化">Json数据持久化</a><time datetime="2022-07-06T13:33:49.000Z" title="发表于 2022-07-06 21:33:49">2022-07-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/Unity-Demo/" title="Unity-Demo"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/media/top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity-Demo"/></a><div class="content"><a class="title" href="/blog/Unity-Demo/" title="Unity-Demo">Unity-Demo</a><time datetime="2022-07-04T23:29:10.000Z" title="发表于 2022-07-05 07:29:10">2022-07-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Chou</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      true && mermaid.init()
    })
  }
}</script></div><div class="aplayer no-destroy" data-id="7675104902" data-server="tencent" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2d_models/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2d_models/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2d_models/assets/wanko.model.json"},"display":{"position":"left","width":100,"height":150,"hOffset":-10,"vOffset":40},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body></html>