<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Unity常用设计模式</title>
      <link href="blog/Unity%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>blog/Unity%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>当我们制作一款游戏时，往往会出现这种情况</p><p>当玩家的HP = 0时；</p><p>动画系统会播放死亡动画，音效系统会播放死亡音效，场景需要重置等</p><p>一般的情况下，我们进行一个if判断，当HP == 0时，我们会找到上述组件的引用，然后再调用它们的方法</p><img src="/blog/Unity%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220812133113872.png" class="" title="image-20220812133113872"><p>但这样就会出现一个问题，代码的耦合性过高，我们在一个脚本中关联了其它的四个脚本，但凡其中一个脚本内容的丢失，都会影响到当前脚本</p><img src="/blog/Unity%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220812133343224.png" class="" title="image-20220812133343224"><p>所以，这时候观察者模式的优势就体现出来了，它可以降低代码之间的耦合</p><blockquote><p>我们可以写一个死亡事件，当HP = 0时，执行死亡事件</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Action&lt;&gt; 人物死亡事件;</span><br><span class="line"><span class="keyword">if</span>(HP == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//我们只需要在人物脚本中执行死亡事件即可</span></span><br><span class="line">    人物死亡时事件.执行();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们只需要将<strong>对于玩家死亡产生反应的系统</strong>确定为观察者，然后再<strong>添加对应的函数到玩家死亡事件中</strong>即可</p><img src="/blog/Unity%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220812134100718.png" class="" title="image-20220812134100718">]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>帧同步、状态同步、状态帧同步</title>
      <link href="blog/Unity%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5/"/>
      <url>blog/Unity%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="帧同步"><a href="#帧同步" class="headerlink" title="帧同步"></a>帧同步</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h4><p>有明确的逻辑帧概念，按照<strong>固定的逻辑帧间隔</strong>同步数据</p><blockquote><p>比如以30FPS作为逻辑帧进行同步和Tick，那么每帧就有30次的同步和Tick行为</p></blockquote><h4 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h4><p>首先<strong>定点数</strong>在<strong>操作系统</strong>中：小数点位置不变，通常为纯整数或纯小数</p><p>而<strong>浮点数</strong>在<strong>操作系统</strong>中：用尾数和阶码表示的一种小数点位置可变的数据</p><blockquote><p>虽然浮点数采用了IEEE 754标准，但各家对于浮点运算的舍入实现却不同，所以就导致了浮点数的误差</p><p>而由于帧同步一般<strong>只转发玩家的操作指令</strong>，让客户端自己根据指令进行Tick得到一直的画面表现，但由于<strong>浮点数存在误差</strong>，就会出现不同步的情况</p><p>所以我们就使用操作系统的定点数模拟了一种浮点数，用来<strong>避免不同平台的浮点误差</strong></p></blockquote><p>帧同步中的定点数是指：使用确定精度的整形、长整型实现浮点精度的一种<strong>数据结构</strong>，它用来避免不同平台的浮点误差，在任意<strong>编程语言</strong>、<strong>编译器</strong>、<strong>CPU指令集</strong>上的计算结果都是一致的</p><h3 id="状态同步"><a href="#状态同步" class="headerlink" title="状态同步"></a>状态同步</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>只有当<strong>状态数据发生变化</strong>的时候才进行同步</p><blockquote><p>只有当状态发生改变(属性、Buff、释放技能等)时，服务器才会进行同步操作</p><p>而且状态同步其实是<strong>没有严格的逻辑帧概念</strong>的，它并<strong>没有帧号</strong>的信息</p></blockquote><h3 id="状态帧同步"><a href="#状态帧同步" class="headerlink" title="状态帧同步"></a>状态帧同步</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>按<strong>固定的逻辑帧</strong>搜集<strong>变化的状态数据</strong>并进行网络同步。它是状态同步和帧同步的结合</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity知识点复习</title>
      <link href="blog/Unity%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/"/>
      <url>blog/Unity%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Unity知识点复习"><a href="#Unity知识点复习" class="headerlink" title="Unity知识点复习"></a>Unity知识点复习</h2><h3 id="Unity脚本生命周期函数"><a href="#Unity脚本生命周期函数" class="headerlink" title="Unity脚本生命周期函数"></a>Unity脚本生命周期函数</h3><ul><li>Awake：当<strong>脚本对象创建时调用</strong>，它会做一些对象创建的初始化操作</li><li>OnEnable：<strong>脚本依附的对象激活时调用</strong></li><li>Start：游戏开始时执行一次，主要也是进行一些初始化</li><li>FixedUpdate：物理帧更新，固定间隔事件调用，用于物理更新方面</li><li>Update：游戏运行后<strong>每帧调用</strong>，游戏的主逻辑一般写在这个函数中</li><li>LateUpdate：一般用于处理<strong>摄像机位置变化</strong>的相关内容</li><li>OnDisable：游戏对象<strong>失活</strong>后调用</li><li>OnDestory：游戏对象<strong>销毁</strong>时调用</li></ul><h3 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h3><p>协程是在<strong>主线程运行的同时</strong>，<strong>开启另一段代码分时执行</strong>。且不会造成主线程卡顿。</p><p>常用于异步加载文件、异步加载场景、批量创建对象时防止卡顿等方便</p><blockquote><p>注意：</p><ul><li><p>协程只有当<strong>组件失活</strong>时不受影响，其它情况协程都会停止</p></li><li><p>协程与线程的区别：协程是在原线程上开启，进行逻辑的<strong>分时分布</strong>执行。而线程是一个独立的管道，和主线程<strong>并行</strong>执行</p></li><li>Unity中是支持多线程的，但关于<strong>对象的操作</strong>，只能在主线程中执行。所以多线程一般用来处理复杂的<strong>算法运算</strong>和<strong>网络相关</strong>的内容，之后再将结果放到<strong>公共的内存</strong>中<strong>等待主线程的调用</strong></li></ul></blockquote><h3 id="协程的本质"><a href="#协程的本质" class="headerlink" title="协程的本质"></a>协程的本质</h3><p>协程是由 <strong>协程函数本体</strong>，以及<strong>协程调度器</strong>组成</p><p>而协程函数的本质是由<strong>C#迭代器</strong>的方法实现的。</p><blockquote><p>开始时会得到yield return返回的内容</p><p>然哈通过MoveNext()函数访问迭代器中的内容，直到遇见yield return</p></blockquote><h3 id="ArrayList和List的主要区别"><a href="#ArrayList和List的主要区别" class="headerlink" title="ArrayList和List的主要区别"></a><strong>ArrayList和List的主要区别</strong></h3><p>ArrayList存在不安全类型（ArrayList会把所有插入其中的数据都当做Object来处理），装箱拆箱的操作（费时）。</p><p>List是泛型类，功能跟ArrayList相似，但不存在ArrayList所说的问题</p><h3 id="Unity提供了几种光源，分别是什么"><a href="#Unity提供了几种光源，分别是什么" class="headerlink" title="Unity提供了几种光源，分别是什么"></a><strong>Unity提供了几种光源，分别是什么</strong></h3><p>四种。</p><p>平行光：Directional Light</p><p>点光源：Point Light</p><p>聚光灯：Spot Light</p><p>区域光源：Area Light</p><h3 id="Unity实现帧数锁定"><a href="#Unity实现帧数锁定" class="headerlink" title="Unity实现帧数锁定"></a>Unity实现帧数锁定</h3><p>在菜单栏中点击Edit-&gt;Project Setting</p><p>打开打开 “Quality” 分栏，在 “Other” 分区中，调整 V Sync Count（垂直同步计数）</p><ul><li>Don’t Sync：不作垂直同步</li><li>Every V Blank：每帧垂直同步</li><li>Every Second V Blank：每帧垂直同步一半的值</li></ul><h3 id="多个Mono脚本执行顺序"><a href="#多个Mono脚本执行顺序" class="headerlink" title="多个Mono脚本执行顺序"></a>多个Mono脚本执行顺序</h3><p>假设有两个类Test1和Test2都继承了MonoBehaviour。那么使用<strong>Script Execution Order</strong> 指定多个Mono脚本的执行顺序</p><blockquote><p>具体可以在Edit-&gt;Project Setting，找到Script Execution Order，然后点击”+”号，添加需要设置执行顺序的脚本，后面的数字越小，表示越先执行，最后不要忘记Apply应用</p></blockquote><img src="/blog/Unity%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bKz5bCP5a6F,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center.png" class="" title="在这里插入图片描述">]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity横板卷轴射击游戏Demo</title>
      <link href="blog/Unity%E6%A8%AA%E6%9D%BF%E5%8D%B7%E8%BD%B4%E5%B0%84%E5%87%BB%E6%B8%B8%E6%88%8FDemo/"/>
      <url>blog/Unity%E6%A8%AA%E6%9D%BF%E5%8D%B7%E8%BD%B4%E5%B0%84%E5%87%BB%E6%B8%B8%E6%88%8FDemo/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><h2 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h2><h3 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h3><ol><li>选择Unity2020.3.2 或 更高的版本</li><li>创建项目时选择URP模板</li></ol></li></ol><h3 id="创建默认配置"><a href="#创建默认配置" class="headerlink" title="创建默认配置"></a>创建默认配置</h3><ol><li>进入场景后创建一个新的场景，将其命名为Gameplay</li><li><strong>删除</strong>Scenes文件夹下的<strong>原场景</strong>以及<strong>URP模板</strong>自带的样本文件</li><li>创建Resources、ArtUI、Script等文件夹</li></ol><h3 id="导入资源素材"><a href="#导入资源素材" class="headerlink" title="导入资源素材"></a>导入资源素材</h3><ol><li>将下载好的素材直接导入Unity中</li><li>将<strong>Prefab</strong>文件夹下人物素材拖动到Hierarchy窗口中，并为其重命名为Player</li></ol><h3 id="更改默认设置"><a href="#更改默认设置" class="headerlink" title="更改默认设置"></a>更改默认设置</h3><ol><li>由于是2D游戏，所有将主相机中的Projection参数改为<strong>Orthographic</strong>(正交模式)</li><li>观察相机的x、y轴变化，将其都设置为0，并开始2D模式</li></ol><h3 id="场景补光"><a href="#场景补光" class="headerlink" title="场景补光"></a>场景补光</h3><ol><li>复制场景中的Directional Light对象，为其命名为Directional Light Fill(补光)</li><li>将新建的补光对象的Tranform置0</li><li>修改其<strong>Intensity</strong>(光照强度)到3，并修改颜色，让其更符合背景</li></ol><h3 id="整理窗口"><a href="#整理窗口" class="headerlink" title="整理窗口"></a>整理窗口</h3><ol><li>创建一个Environment空对象，并为其创建一个子对象Light</li><li>将场景中的两个环境光拖动到Light中</li></ol><hr><h2 id="卷轴背景移动"><a href="#卷轴背景移动" class="headerlink" title="卷轴背景移动"></a>卷轴背景移动</h2><blockquote><p>思路：</p><p>1、将背景图赋值给材质球，将材质赋值到背景上</p><p>2、通过脚本修改Mesh Collider组件中的Offset参数(偏移值)实现卷轴移动效果</p><p>要求：需要背景是无缝连接的图片</p></blockquote><h3 id="卷轴背景设置"><a href="#卷轴背景设置" class="headerlink" title="卷轴背景设置"></a>卷轴背景设置</h3><ol><li>在Environment创建一个Quad(四边形)，为其命名为Background，然后选中背景图片，查看它的分辨率大</li><li>根据背景图片的比例，为Quad的Size设置为(41,16.4)</li><li>在Materials文件夹下创建一个Background，用于<strong>存放背景材质球</strong></li><li>在Background下创建一个材质球，为其命名为Background Materials。并将其Shader设置为Unlit/Texture</li><li>将背景图片的Type设置为Default，并图片拖动到材质球上</li><li><p>最后将材质球拖动到Quad上即可</p><blockquote><p>如果第5步没有更改Type为Defalut，那么卷轴在移动过程中将会有拖影</p></blockquote></li></ol><h3 id="脚本实现背景移动"><a href="#脚本实现背景移动" class="headerlink" title="脚本实现背景移动"></a>脚本实现背景移动</h3><ol><li><p>在Scripts文件夹下创建BackgoundScroller脚本</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BackgoundScroller</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    Material material;  <span class="comment">//声明材质对象</span></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    Vector2 scrollSpeed;    <span class="comment">//卷轴移动速度</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        material = GetComponent&lt;Renderer&gt;().material;   <span class="comment">//获取材质组件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//更改卷轴材质的偏移值</span></span><br><span class="line">        material.mainTextureOffset += scrollSpeed * Time.deltaTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>将实现的脚本关联到Background上</p></li><li><p>最后再面板上设置Scroll Speed的参数即可</p></li></ol><hr><h2 id="角色移动"><a href="#角色移动" class="headerlink" title="角色移动"></a>角色移动</h2><ol><li><p>创建PlayerController脚本</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="built_in">float</span> moveSpeed;</span><br><span class="line">    <span class="built_in">float</span> hor, ver;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Move();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Move</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        hor = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        ver = Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.transform.Translate(Vector3.right * moveSpeed * Time.deltaTime * hor);</span><br><span class="line">        <span class="keyword">this</span>.transform.Translate(Vector3.up * moveSpeed * Time.deltaTime * ver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>将实现的脚本拖动到Player上</p></li></ol><h3 id="限制角色在相机范围移动-单例"><a href="#限制角色在相机范围移动-单例" class="headerlink" title="限制角色在相机范围移动(单例)"></a>限制角色在相机范围移动(单例)</h3><blockquote><p>思路：</p><p>通过写一个伪单例模式，确定人物和敌人的视口和移动范围</p><p>由于我们在整个项目中可能会用到多个单例模式，所以可以写一个单例模式基类，以后单例模式只需要继承基类即可</p><p>对于单例模式的基类，我们一般写的是伪单例模式基类，因为它继承MonoBehaviour，可以挂载到对象上，这样更方便后续脚本的继承</p></blockquote><ol><li><p>创建一个SingletonBase脚本，它是单例模式的基类</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SingletonBase</span>&lt;<span class="title">T</span>&gt; : <span class="title">MonoBehaviour</span> <span class="keyword">where</span> <span class="title">T</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个项目中用这个方法即可</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;    </span><br><span class="line">           instance = <span class="keyword">this</span> <span class="keyword">as</span> T;       </span><br><span class="line">           DontDestroyOnLoad(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在这个项目中，我们只有一个场景，所以不会有新场景中挂载了相同脚本的游戏对象出现静态实例冲突情况</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;    </span><br><span class="line">     <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">           instance = <span class="keyword">this</span> <span class="keyword">as</span> T;</span><br><span class="line">           &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(instance != <span class="keyword">this</span>)&#123;</span><br><span class="line">               Destroy(gameObject);</span><br><span class="line">           &#125;</span><br><span class="line">        DontDestroyOnLoad(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="视口边界"><a href="#视口边界" class="headerlink" title="视口边界"></a>视口边界</h3><ol><li><p>创建一个<strong>View</strong>脚本，让其继承单例模式基类，里面写上<strong>视口的边界</strong>。最后不要忘记将View脚本挂载到场景的空对象上</p><blockquote><p>这里如果忘记将View脚本挂载到场景的对象上，那么它将不能实例化对象    </p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">View</span> : <span class="title">SingletonBase</span>&lt;<span class="title">View</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> minX = <span class="number">-8</span>, maxX = <span class="number">8</span>, minY = <span class="number">-4.72f</span>, maxY = <span class="number">4.72f</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>在<strong>PlayerController</strong>脚本类中，限制移动</p><blockquote><p>思路：利用Clamp函数，将角色的坐标限制在相机视口内</p><p>Mathf.Clamp(float value, float min, float max)</p><p>参数1：当前值</p><p>参数2：最值</p><p>参数3：最大值</p><p>返回结果，当前值要在最值和最大值之间</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="built_in">float</span> moveSpeed;</span><br><span class="line">    <span class="built_in">float</span> hor, ver;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="built_in">float</span> minX, maxX, minY, maxY;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Move();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Move</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        hor = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        ver = Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.transform.Translate(Vector3.right * moveSpeed * Time.deltaTime * hor);</span><br><span class="line">        <span class="keyword">this</span>.transform.Translate(Vector3.up * moveSpeed * Time.deltaTime * ver);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将人物的位置限制在相机视口范围内</span></span><br><span class="line">         <span class="keyword">this</span>.transform.position = <span class="keyword">new</span> Vector3(Mathf.Clamp(transform.position.x, View.instance.minX, View.instance.maxX),</span><br><span class="line">    Mathf.Clamp(transform.position.y, View.instance.minY, View.instance.maxY), <span class="keyword">this</span>.transform.position.z);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="角色移动时倾斜"><a href="#角色移动时倾斜" class="headerlink" title="角色移动时倾斜"></a>角色移动时倾斜</h3><blockquote><p>思路：通过四元数让角色在上下移动时，机翼倾斜</p><p>四元数：表示3D空间中的旋转量</p><p>利用Quaternion.<strong>AngleAxis</strong>(角度,轴)可以让物体绕着某一个轴旋转</p><p>再使用Slerp插值运算，让旋转时更加平滑</p><p>Quaternion.Slerp(Quaternion a, Quaternion b , float t)</p><p>参数1：当前四元数</p><p>参数2：旋转后的四元数</p><p>参数3：帧间隔时间</p></blockquote><ol><li><p>在PlayerController脚本中新增一个方法，用于实现角色上下移动时倾斜</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="built_in">float</span> moveSpeed;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="built_in">float</span> rotationSpeed;</span><br><span class="line">    <span class="built_in">float</span> hor, ver;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="built_in">float</span> minX, maxX, minY, maxY;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Move();</span><br><span class="line">        Rotation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Move</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        hor = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        ver = Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.transform.Translate(Vector3.right * moveSpeed * Time.deltaTime * hor);</span><br><span class="line">        <span class="keyword">this</span>.transform.Translate(Vector3.up * moveSpeed * Time.deltaTime * ver,Space.World);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将人物的位置限制在相机视口范围内</span></span><br><span class="line">         <span class="keyword">this</span>.transform.position = <span class="keyword">new</span> Vector3(Mathf.Clamp(transform.position.x, View.instance.minX, View.instance.maxX),</span><br><span class="line">    Mathf.Clamp(transform.position.y, View.instance.minY, View.instance.maxY), <span class="keyword">this</span>.transform.position.z);</span><br><span class="line">        print(ver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Rotation</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetKey(KeyCode.W))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//让x轴在空间中旋转45°</span></span><br><span class="line">            Quaternion q = Quaternion.AngleAxis(<span class="number">45</span>,Vector3.right);</span><br><span class="line">            <span class="comment">//Slerp()插值计算，让旋转更加平滑</span></span><br><span class="line">            <span class="keyword">this</span>.transform.rotation = Quaternion.Slerp(<span class="keyword">this</span>.transform.rotation, q, Time.deltaTime * rotationSpeed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Input.GetKey(KeyCode.S))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//让x轴在空间中负方向旋转45°</span></span><br><span class="line">            Quaternion q = Quaternion.AngleAxis(<span class="number">-45</span>, Vector3.right);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">this</span>.transform.rotation = Quaternion.Slerp(<span class="keyword">this</span>.transform.rotation, q, Time.deltaTime * rotationSpeed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Quaternion q = Quaternion.AngleAxis(<span class="number">0</span>, Vector3.right);</span><br><span class="line">            <span class="keyword">this</span>.transform.rotation = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="添加子弹"><a href="#添加子弹" class="headerlink" title="添加子弹"></a>添加子弹</h2><h3 id="导入资源素材-1"><a href="#导入资源素材-1" class="headerlink" title="导入资源素材"></a>导入资源素材</h3><ol><li>将子弹素材导入</li><li><p>选中Player Projectile文件夹下的<strong>ProjectileMesh_Texture</strong>的纹理贴图，将其<strong>Type</strong>类型改为<strong>Sprite</strong>，之后点击Apply</p><h3 id="创建子弹粒子"><a href="#创建子弹粒子" class="headerlink" title="创建子弹粒子"></a>创建子弹粒子</h3></li><li><p>在场景中新建一个空对象，为其命名为Player Projectile，并将<strong>Transform</strong>改为和角色一致。再从Player Projectile中新建一个Effects/<strong>Particle System</strong>，为其命名为Particle</p><p>​    </p></li><li><p>选中Particle，从Inspector面板中下拉到粒子系统的最底下，找到<strong>Renderer</strong>渲染器组件</p><p>​    </p></li><li><p>将其<strong>Render Mode</strong>渲染模式改为<strong>Mesh</strong>(网格)</p><p>​    </p></li><li><p>将之前导入的<strong>子弹网格体</strong>拖入到Mesh中</p><p>​    </p></li><li><p>在<strong>Player Projectile</strong>文件夹下创建一个<strong>Materials</strong>材质，为其命名为<strong>Player_Projectile_Normal</strong></p><ul><li><p>将其<strong>Shader</strong>改为<strong>Universal Render Pioeline/Particles/Unlit</strong>。Type类型改为<strong>Transparent</strong>(透明的)，Mode改为<strong>Additive</strong>(叠加)</p></li><li><p>再将之前导入的<strong>ProjectileMesh_Texture</strong>贴图，拖入到<strong>Bash Map</strong>中</p></li><li><p>勾选<strong>Emission</strong>，点击<strong>HDR</strong>，将颜色改为天蓝色。并将下方的<strong>Intensity</strong>发光强度改为<strong>4</strong></p></li></ul></li></ol><ol><li><p>选中场景中的<strong>Particle</strong>对象，找到其<strong>Renderer</strong>组件，再将上一步创建好的材质，拖入到Renderer组件的<strong>Material</strong>参数中</p><p>​    </p></li><li><p>拉到粒子系统的最上方，找到<strong>Particle</strong></p><ul><li><p>将<strong>Duration</strong>(持续时间)改为0.5，并勾选Prewarm</p></li><li><p>将<strong>Start Lifetime</strong> 起始声明周期改为0.5</p></li><li><p>将<strong>Start Speed</strong> 起始速度改为0，这里需要在脚本中控制</p></li><li><p>最后将<strong>Start Size</strong>设置为0.5。将粒子起始的大变为原来的一般</p></li></ul></li></ol><ol><li><p>选中粒子系统中的<strong>Emission</strong>组件，将<strong>Rate over Time</strong>改为2。即这个粒子系统的生命周期最多产生两个例子</p><p>​    </p></li><li><p>取消勾选Shape组件</p><p>​    </p></li><li><p>勾选粒子系统中的<strong>Color over Lifetime</strong>组件，它可以改变粒子在生命周期的颜色</p><ul><li>点击Color，将<strong>Location</strong>设置为百分之50，并将<strong>Alpha</strong>值改为0，这样能产生<strong>粒子闪烁</strong></li></ul></li></ol><ol><li><p>勾选粒子系统中的<strong>Rotation by Speed</strong>，它可以设置粒子在生命周期<strong>旋转时的速度</strong></p><ul><li>勾选<strong>Spearate Axes</strong>，就可以设置每个轴的旋转速度</li><li>将X轴设置为1000，其他轴为0。这样粒子就会绕着X轴进行快速旋转</li></ul><blockquote><p>注意：</p><p>1、如果<strong>Emission</strong>组件中的Rate over Time是1的话，粒子会出现时有时无的情况</p><p>2、Rotation by Speed组件中，xyz中的参数是<strong>旋转速度</strong>，而不是角度</p></blockquote></li></ol><h3 id="创建子弹尾迹粒子"><a href="#创建子弹尾迹粒子" class="headerlink" title="创建子弹尾迹粒子"></a>创建子弹尾迹粒子</h3><ol><li>在<strong>Player Projectile</strong>对象下，创建一个Effects/Trail</li><li>将<strong>Time</strong>参数改为0.1，不然尾迹会拖的很长</li><li>选中颜色参数，将初始颜色的透明度设置为200，结束颜色的透明度设置为0。这样尾迹会有一个<strong>慢慢消失</strong>的效果</li><li>找到尾迹宽度曲线，右键点击<strong>Add Key</strong>，然后将Key拉倒右下角。这样尾迹会从头到尾<strong>慢慢缩</strong></li><li>将<strong>Width</strong>(尾迹宽度)最大值设置为0.1。否则尾迹会很大</li><li>复制之前创建的子弹材质，删除它<strong>Base Map</strong>中的纹理贴图(尾迹中不需要)</li><li>将删除纹理贴图的<strong>新材质</strong>拖动到<strong>Trail Renderer</strong>组件中的<strong>Materials</strong>参数中</li></ol><h3 id="脚本实现子弹移动"><a href="#脚本实现子弹移动" class="headerlink" title="脚本实现子弹移动"></a>脚本实现子弹移动</h3><blockquote><p>思路：玩家和敌人都有子弹，所以可以写一个子弹基类。再让玩家和敌人继承基类</p><p>基类中会包含一些共同数据，比如子弹移动方向和移动速度</p></blockquote><ol><li><p>创建一个Projectile脚本基类，用于存储子弹移动方向、速度属性以及子弹移动的方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Projectile</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="built_in">float</span> moveSpeed = <span class="number">10</span>;   <span class="comment">//子弹移动速度</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">protected</span> Vector2 moveDirection;  <span class="comment">//子弹移动方向</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.transform.Translate(moveDirection * moveSpeed * Time.deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    </p></li></ol><ol><li><p>创建Player Projectile脚本，继承Projectile</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerProjectile</span> : <span class="title">Projectile</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>因为继承了父类，所以Play Projectile脚本不需要写任何内容，即可完成最基本的功能</p></blockquote><p>​    </p></li><li><p>将Player Projectile脚本挂在到场景中的Player Projectile对象上</p></li><li><p>将moveDirection参数设置为(1,0)，即子弹沿着x轴正方向移动</p><p>​    </p><h3 id="添加场景后处理体积"><a href="#添加场景后处理体积" class="headerlink" title="添加场景后处理体积"></a>添加场景后处理体积</h3></li><li><p>创建一个空对象，为其命名为<strong>Global Post Processing Volume</strong>(全局后处理体积)，并充值Tranforms</p></li><li>为空对象添加<strong>Volume</strong>组件，它是URP包自带的后处理配置脚本</li><li>设置主相机Camera组件配置<ol><li>勾选Post Processing 参数</li><li>Anti-alising参数设置为FXAA(移动平台)，若是PC平台则设置SMAA</li><li>在<strong>Background Type</strong>参数设置为<strong>Solid Color</strong>(单色)，不需要用天空盒</li><li>Volume Mask 设置为evering。处理全部层级</li></ol></li><li>选中之前的<strong>Global Post Processing Volume</strong>对象，点击New，系统就会帮我们创建一个后处理配置文件。我们将它移动到Settings里的URP文件中</li><li>回到Volume脚本中，点击<strong>Add Override</strong>添加后处理效果</li><li>添加Bloom辉光效果，可以让子弹周围包裹一层光晕<ol><li>将Intensity强度(光晕大)设置为1，Threshold 阈值设置为1</li><li>勾选High Quality Filering(高品质过滤)，以更低的性能，可以获取更柔和的光</li><li>skip Iterations 设置为5</li></ol></li><li>接下来添加Tone Mapping 色调映射效果<ol><li>Mode参数默认为Neutral，渲染效果比较模糊，但光线更为柔和</li><li>第二个参数是ACES，渲染效果会加深对比度和饱和度。这里我们选中ACES模式</li></ol></li></ol><blockquote><p>注意：</p><p>Vloume脚本中的默认Mode为Global，即应用到整个场景</p><p>若我们想要其局部生效，可以将Mode改为<strong>Local</strong>，并在Volume中点击<strong>Add Collider</strong>。添加一个碰撞体</p></blockquote><h3 id="创建子弹预设体"><a href="#创建子弹预设体" class="headerlink" title="创建子弹预设体"></a>创建子弹预设体</h3><ol><li>将场景中Player Projectile对象拖入到Prefabs即可创建预设体</li></ol><hr><h2 id="发射子弹"><a href="#发射子弹" class="headerlink" title="发射子弹"></a>发射子弹</h2><blockquote><p>思路：</p><p>按住空格时创建子弹到飞机位置</p><p>1、Input检测按键输入</p><p>2、Instantiate实例化子弹</p></blockquote><h3 id="发射子弹-1"><a href="#发射子弹-1" class="headerlink" title="发射子弹"></a>发射子弹</h3>   <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Fire</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Object bullet;</span><br><span class="line">    <span class="keyword">public</span> Transform firePos;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="built_in">float</span> fireTime = <span class="number">0.5f</span>;  <span class="comment">//子弹开火的间隔时间</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        fireTime += Time.deltaTime;   <span class="comment">//时间累加</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKey(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fireTime &gt; <span class="number">0.25f</span> ) <span class="comment">//每隔0.25s可以发射一次子弹</span></span><br><span class="line">            &#123;</span><br><span class="line">                Instantiate(bullet, firePos.position, Quaternion.identity);</span><br><span class="line">                fireTime = <span class="number">0</span>;</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="利用协程添加补充子弹时间"><a href="#利用协程添加补充子弹时间" class="headerlink" title="利用协程添加补充子弹时间"></a>利用协程添加补充子弹时间</h3>   <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Fire</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform firePos;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="built_in">float</span> fireTime = <span class="number">0.5f</span>;  <span class="comment">//子弹开火的间隔时间</span></span><br><span class="line">    </span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="built_in">int</span> bulletNums = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">bool</span> isStart = <span class="literal">false</span>;</span><br><span class="line">    WaitForSeconds waitForSeconds;<span class="comment">//直接将协程的值保存下来</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//在Start中初始化，这样就不会多次声明</span></span><br><span class="line">        waitForSeconds = <span class="keyword">new</span> WaitForSeconds(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        MyFire();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MyFire</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        fireTime += Time.deltaTime;   <span class="comment">//时间累加</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKey(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (fireTime &gt; <span class="number">0.25f</span> &amp;&amp; bulletNums &gt; <span class="number">0</span>) <span class="comment">//每隔0.25s可以发射一次子弹</span></span><br><span class="line">            &#123;</span><br><span class="line">                Instantiate(bullet, firePos.position, Quaternion.identity);</span><br><span class="line">                fireTime = <span class="number">0</span>;</span><br><span class="line">                bulletNums--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//子弹为0的时候，开启协程</span></span><br><span class="line">        <span class="keyword">if</span> (bulletNums == <span class="number">0</span> &amp;&amp; !isStart)</span><br><span class="line">        &#123;</span><br><span class="line">            StartCoroutine(BulletTime());</span><br><span class="line">            isStart = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两秒后补充子弹</span></span><br><span class="line">    <span class="function">IEnumerator <span class="title">BulletTime</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;       </span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> waitForSeconds;   <span class="comment">//挂起3秒再进入协程     </span></span><br><span class="line">        bulletNums = <span class="number">10</span>;</span><br><span class="line">        isStart = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>   在游戏的运行阶段，取出一块内存区域，用来存储游戏对象。</p><p>   当我们需要用到某个游戏对象时，不再new新的对象，而是从准备好的对象池中取出。</p><p>   而用完之后，不会将对象销毁，而是失活后重新存放到对象池中，方便下次使用</p><p>   ​    </p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>   使用对象池后，对象可以重复利用，这样就可以减少垃圾回收机制的触发。能够减少游戏的卡顿</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><blockquote><p>步骤：</p><p>1、生成一些备用对象。让它们处于禁用状态，已备随时启用，最后让这些对象入列</p><p>2、从队列中取出可用对象。如果队列中元素大于0，则出列。否则将再次创建一个对象</p><p>3、将取出的对象激活</p><p>4、将完成任务的对象返回对象池</p><p>注意：</p><p>使用Resources创建对象时，不要忘记将预设体放到Resources文件夹下</p></blockquote><h4 id="创建PoolManager脚本"><a href="#创建PoolManager脚本" class="headerlink" title="创建PoolManager脚本"></a>创建PoolManager脚本</h4><p>   用链表存储对象池中一种对象</p>   <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PoolManager</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> PoolManager instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PoolManager <span class="title">Instance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> PoolManager();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    List&lt;GameObject&gt; pools = <span class="keyword">new</span> List&lt;GameObject&gt;();    <span class="comment">//创建一个链表，用于存放对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从链表中取出对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GameObject <span class="title">GetObject</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        GameObject getObject = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(pools.Count &gt; <span class="number">0</span>) <span class="comment">//链表中元素大于0</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pools[<span class="number">0</span>].name == name)</span><br><span class="line">            &#123;</span><br><span class="line">                getObject = pools[<span class="number">0</span>];   <span class="comment">//将链表中第一个元素赋值给对象</span></span><br><span class="line">                getObject.SetActive(<span class="literal">true</span>);  <span class="comment">//激活对象</span></span><br><span class="line">                pools.RemoveAt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果对象池中没有对象，则先实例化一个对象</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            getObject = GameObject.Instantiate(Resources.Load&lt;GameObject&gt;(name));</span><br><span class="line">            getObject.name = name;  <span class="comment">//再将对象的名字改的和对象池名字相同</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getObject;<span class="comment">//将对象返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将对象存放到链表中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveObject</span>(<span class="params">GameObject obj</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//失活游戏对象</span></span><br><span class="line">        obj.SetActive(<span class="literal">false</span>);</span><br><span class="line">        obj.transform.parent = GameObject.Find(<span class="string">&quot;Pool&quot;</span>).transform;   <span class="comment">//将生成的对象放到一个父物体下</span></span><br><span class="line">        pools.Add(obj); <span class="comment">//将对象存入链表中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意：将生成的对象放到父物体下，需要现在场景中创建一个预设体</p></blockquote><p>   用字典存储对象池中多种对象</p>   <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PoolManager</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> PoolManager instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PoolManager <span class="title">Instance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> PoolManager();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、用字典创建一个对象池容器</span></span><br><span class="line">    Dictionary&lt;<span class="built_in">string</span>, List&lt;GameObject&gt;&gt; dicPools = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, List&lt;GameObject&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、通过key调用方法获取对象池中的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  GameObject <span class="title">GetObject</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        GameObject obj = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(dicPools.ContainsKey(name) &amp;&amp; dicPools[name].Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            obj = dicPools[name][<span class="number">0</span>];    <span class="comment">//通过key值获取第一个对象</span></span><br><span class="line">            dicPools[name].RemoveAt(<span class="number">0</span>); <span class="comment">//拿取对象后，链表元素移除</span></span><br><span class="line">            obj.SetActive(<span class="literal">true</span>);    <span class="comment">//拿出对象后激活对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(obj == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果池子中没有对象，那就创建动态创建一个对象</span></span><br><span class="line">            obj = GameObject.Instantiate(Resources.Load&lt;GameObject&gt;(name));</span><br><span class="line">            obj.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、调用方法将用完的对象池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveObject</span>(<span class="params">GameObject obj</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        obj.SetActive(<span class="literal">false</span>);<span class="comment">//对象失活</span></span><br><span class="line">        <span class="keyword">if</span> (dicPools.ContainsKey(obj.name)) <span class="comment">//如果key存在，就存到对应的链表中</span></span><br><span class="line">        &#123;</span><br><span class="line">            dicPools[obj.name].Add(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//第一次生成时，对象池中没有这种key的列表</span></span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;GameObject&gt; list = <span class="keyword">new</span> List&lt;GameObject&gt;();<span class="comment">//先创建一个链表</span></span><br><span class="line">            list.Add(obj);<span class="comment">//将对象添加到链表中</span></span><br><span class="line">            dicPools.Add(obj.name, list);   <span class="comment">//将key和链表添加到字典中</span></span><br><span class="line">        &#125;</span><br><span class="line">        obj.transform.parent = GameObject.Find(<span class="string">&quot;Pool&quot;</span>).transform;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="在Fire脚本中调用PoolMananger的GetOobject-方法"><a href="#在Fire脚本中调用PoolMananger的GetOobject-方法" class="headerlink" title="在Fire脚本中调用PoolMananger的GetOobject()方法"></a>在Fire脚本中调用PoolMananger的GetOobject()方法</h4><p>   创建对象并存储到池子中</p>   <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Fire</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform firePos;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="built_in">float</span> fireTime = <span class="number">0.5f</span>;  <span class="comment">//子弹开火的间隔时间</span></span><br><span class="line">    </span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="built_in">int</span> bulletNums = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">bool</span> isStart = <span class="literal">false</span>;</span><br><span class="line">    WaitForSeconds waitForSeconds;<span class="comment">//直接将协程的值保存下来</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//在Start中初始化，这样就不会多次声明</span></span><br><span class="line">        waitForSeconds = <span class="keyword">new</span> WaitForSeconds(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        MyFire();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MyFire</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        fireTime += Time.deltaTime;   <span class="comment">//时间累加</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKey(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (fireTime &gt; <span class="number">0.25f</span> &amp;&amp; bulletNums &gt; <span class="number">0</span>) <span class="comment">//每隔0.25s可以发射一次子弹</span></span><br><span class="line">            &#123;</span><br><span class="line">                GameObject bullet = PoolManager.Instance().GetObject(<span class="string">&quot;Player Projectile&quot;</span>); <span class="comment">//从对象池中创建子弹</span></span><br><span class="line">                bullet.transform.position = firePos.position;<span class="comment">//为子弹赋值位置</span></span><br><span class="line">                fireTime = <span class="number">0</span>;</span><br><span class="line">                bulletNums--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//子弹为0的时候，开启协程</span></span><br><span class="line">        <span class="keyword">if</span> (bulletNums == <span class="number">0</span> &amp;&amp; !isStart)</span><br><span class="line">        &#123;</span><br><span class="line">            StartCoroutine(BulletTime());</span><br><span class="line">            isStart = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两秒后补充子弹</span></span><br><span class="line">    <span class="function">IEnumerator <span class="title">BulletTime</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;       </span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> waitForSeconds;   <span class="comment">//挂起3秒再进入协程     </span></span><br><span class="line">        bulletNums = <span class="number">10</span>;</span><br><span class="line">        isStart = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意：从对象池中创建对象时，传入的是预制体的名字</p></blockquote><h4 id="创建一个SaveBullet脚本"><a href="#创建一个SaveBullet脚本" class="headerlink" title="创建一个SaveBullet脚本"></a>创建一个<strong>SaveBullet</strong>脚本</h4><p>   挂在到子弹的预制体上，用于回收子弹</p>   <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SaveBullet</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.transform.position.x &gt; <span class="number">9</span> || <span class="keyword">this</span>.transform.position.x &lt; <span class="number">-9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            PoolManager.Instance().SaveObject(<span class="keyword">this</span>.gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="解决尾迹的拖尾效果"><a href="#解决尾迹的拖尾效果" class="headerlink" title="解决尾迹的拖尾效果"></a>解决尾迹的拖尾效果</h3><p>   打开之前的<strong>PlayerProjectile</strong>脚本，在里面编写脚本解决</p>   <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerProjectile</span> : <span class="title">Projectile</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//声明尾迹渲染器</span></span><br><span class="line">    TrailRenderer trailRenderer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//轨迹组件是在子对象上的，所以用GetComponentInChildren</span></span><br><span class="line">        trailRenderer = GetComponentInChildren&lt;TrailRenderer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子弹对象被禁用时，去掉子弹尾迹</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        trailRenderer.Clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><hr><h2 id="创建敌人"><a href="#创建敌人" class="headerlink" title="创建敌人"></a>创建敌人</h2><h3 id="导入资源素材-2"><a href="#导入资源素材-2" class="headerlink" title="导入资源素材"></a>导入资源素材</h3><ol><li>将敌人资源导入，在Prefab文件夹中找到三个敌人预制体</li><li>将它们命名更改为Enemy01,Enemy02,Enemy03</li><li>将预制体拖入到场景中即可创建敌人</li></ol><h3 id="限制敌人移动范围"><a href="#限制敌人移动范围" class="headerlink" title="限制敌人移动范围"></a>限制敌人移动范围</h3><ol><li><p>打开之前的<strong>View</strong>脚本，在里面限制敌人的移动范围</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">View</span> : <span class="title">SingletonBase</span>&lt;<span class="title">View</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> minX = <span class="number">-8</span>, maxX = <span class="number">8</span>, minY = <span class="number">-4.72f</span>, maxY = <span class="number">4.72f</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//敌人随机生成函数，我们将其限制在屏幕坐标外生成</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vector3 <span class="title">RondomCreateEnemy</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Vector3 pos = Vector3.zero; <span class="comment">//敌人坐标初始化</span></span><br><span class="line"></span><br><span class="line">        pos.x = maxX + <span class="number">2</span>;   <span class="comment">//需要计算敌人模型的范围</span></span><br><span class="line">        pos.y = Random.Range(minY, maxY);   <span class="comment">//敌人Y轴的随机生成范围</span></span><br><span class="line">        pos.z = <span class="number">-5</span>; <span class="comment">//敌人和人物Z轴坐标保持一直</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//敌人可随机移动范围的函数，我们让其限制在屏幕的左半边移动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vector3 <span class="title">RandomMoveEnemy</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Vector3 pos = Vector3.zero;</span><br><span class="line">        pos.x = Random.Range(<span class="number">0</span>, maxX);</span><br><span class="line">        pos.y = Random.Range(minY, maxY);</span><br><span class="line">        pos.z = <span class="number">-5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="敌人随机移动"><a href="#敌人随机移动" class="headerlink" title="敌人随机移动"></a>敌人随机移动</h3><ol><li><p>创建一个<strong>EnemyController</strong>敌人控制器脚本</p><blockquote><p>在脚本中调用单例View类，获取敌人位置和移动范围的方法</p><p>思路：通过<strong>协程</strong>，让敌人处于激活状态时才会移动</p><p>利用Vector3.Distance()计算敌人当前位置和目标位置的距离，通过Mathf.Epsilon来判断二者是否接近最值</p><p>如果还没到达目标位置，则用Vector3.MoveTowards()函数，让敌人不断接近目标值</p><p>当敌人到达目标值后，就随机更新一个新的目标值，让敌人移动</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="built_in">float</span> moveSpeed = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//敌人每次激活时都会启用协程</span></span><br><span class="line">        StartCoroutine(RandomMove());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">RandomMove</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//开始时，敌人的位置将在屏幕外</span></span><br><span class="line">        <span class="keyword">this</span>.transform.position = View.instance.RondomCreateEnemy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录敌人想要移动的目标位置</span></span><br><span class="line">        Vector3 targetPos = View.instance.RandomMoveEnemy();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (gameObject.activeSelf)   <span class="comment">//敌人激活时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当敌人当前位置与目标位置的距离 大于极值时，说明敌人还没到达位置</span></span><br><span class="line">            <span class="keyword">if</span>(Vector3.Distance(transform.position, targetPos) &gt; Mathf.Epsilon)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//利用MoveToward函数,让当前位置到达目标位置，第三个参数是每帧移动量的最大值</span></span><br><span class="line">               <span class="keyword">this</span>.transform.position = Vector3.MoveTowards(transform.position, targetPos, moveSpeed * Time.deltaTime);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//获取敌人Y轴坐标变化的单位四元数。让其在Y轴变化时，会沿着X轴偏移25°</span></span><br><span class="line">                transform.rotation = Quaternion.AngleAxis((targetPos - transform.position).normalized.y * <span class="number">25</span>, Vector3.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//敌人到达目标位置后，更新目标位置</span></span><br><span class="line">                targetPos = View.instance.RandomMoveEnemy();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="敌人随机开火"><a href="#敌人随机开火" class="headerlink" title="敌人随机开火"></a>敌人随机开火</h3><ol><li><p>在<strong>EnemyController</strong>脚本增加敌人开火的协程</p><blockquote><p>思路：</p><p>1、我们要设置敌人开火的时间间隔，为了让其是随机设计的，可以设置两个值，让其随机数在协程中挂起</p><p>2、当协程挂起结束后，调用对象池生成敌人子弹</p><p>3、这里我们需要创建敌人子弹预制体对象，还要声明一个变量存储敌人开火的位置</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="meta-string">&quot;----Move----&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="built_in">float</span> moveSpeed = <span class="number">2</span>;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="built_in">float</span> minFireTime, maxFireTime;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="meta-string">&quot;----Fire----&quot;</span>)</span>]</span><br><span class="line">     </span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    Transform firePos;  <span class="comment">//敌人开火位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//敌人每次激活时都会启用协程</span></span><br><span class="line">        StartCoroutine(RandomMove());   <span class="comment">//敌人随机移动协程</span></span><br><span class="line">        StartCoroutine(RandomFireEnemy());  <span class="comment">//敌人随机开火协程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//防止意外，当敌人失活时，将协程全部关闭</span></span><br><span class="line">        StopAllCoroutines();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">RandomMove</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//开始时，敌人的位置将在屏幕外</span></span><br><span class="line">        <span class="keyword">this</span>.transform.position = View.instance.RondomCreateEnemy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录敌人想要移动的目标位置</span></span><br><span class="line">        Vector3 targetPos = View.instance.RandomMoveEnemy();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (gameObject.activeSelf)   <span class="comment">//敌人激活时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当敌人当前位置与目标位置的距离 大于极值时，说明敌人还没到达位置</span></span><br><span class="line">            <span class="keyword">if</span>(Vector3.Distance(transform.position, targetPos) &gt; Mathf.Epsilon)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//利用MoveToward函数,让当前位置到达目标位置，第三个参数是每帧移动量的最大值</span></span><br><span class="line">               <span class="keyword">this</span>.transform.position = Vector3.MoveTowards(transform.position, targetPos, moveSpeed * Time.deltaTime);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//获取敌人Y轴坐标变化的单位四元数。让其在Y轴变化时，会沿着X轴偏移25°</span></span><br><span class="line">                transform.rotation = Quaternion.AngleAxis((targetPos - transform.position).normalized.y * <span class="number">25</span>, Vector3.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//敌人到达目标位置后，更新目标位置</span></span><br><span class="line">                targetPos = View.instance.RandomMoveEnemy();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">RandomFireEnemy</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        GameObject bullet;   <span class="comment">//创建对象用于存储敌人子弹预制体</span></span><br><span class="line">        <span class="keyword">while</span> (gameObject.activeSelf)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//让协程挂起一个随机时间，这样敌人就会随机间隔的发射子弹</span></span><br><span class="line">            <span class="comment">//这里要注意，虽然尽量不要在循环中new对象，但如果将对象创建在外部，就没有随机间隔发射子弹效果</span></span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">Random.Range(minFireTime,maxFireTime</span>))</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当敌人随机发射间隔挂起结束后，敌人将发射子弹</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.transform.position.x &lt; <span class="number">8</span>)   <span class="comment">//避免敌人还没出来就发射子弹</span></span><br><span class="line">            &#123;</span><br><span class="line">                bullet = PoolManager.Instance().GetObject(<span class="string">&quot;EnemyBulletBase&quot;</span>);</span><br><span class="line">                bullet.transform.position = firePos.position;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="创建敌人子弹"><a href="#创建敌人子弹" class="headerlink" title="创建敌人子弹"></a>创建敌人子弹</h3><ol><li>在面板上创建一个空物体，为其命名为<strong>EnemyBulletBase</strong>。然后将设置位置(0,0,-5)</li><li>再从它的下方创建一个Cube，并将其大设置为子弹大，并移除Cube上的碰撞体</li><li>为<strong>EnemyBulletBase</strong>添加<strong>SaveBullet</strong>脚本。用于对象池回收子弹</li><li><p>为<strong>EnemyBulletBase</strong>新建<strong>EnemyBullet</strong>脚本，并让其继承Projectile(炮弹)基类</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyBullet</span> : <span class="title">Projectile</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//如果敌人子弹移动方向不是向左的话，更改其移动方向</span></span><br><span class="line">        <span class="keyword">if</span>(moveDirection != Vector2.left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Quaternion.FromToRotation方法更改当前方向</span></span><br><span class="line">            <span class="comment">//参数1是目标方向，参数2是当前方向</span></span><br><span class="line">            <span class="keyword">this</span>.transform.rotation = Quaternion.FromToRotation(Vector2.left, moveDirection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>敌人子弹飞行方向是左边，所以我们将其moveDirection参数的x值改为-1。并降低子弹移动速度</p></li><li>在Materials文件夹下为子弹创建材质，命名为EnemyBullet_M<ol><li>将子弹材质的<strong>Base Map</strong>(基础色)改为紫色</li><li>勾选<strong>Emission</strong>(发光)，并让Emission Map(发光色)和Base Map保持一致</li><li>点击<strong>HDR</strong>，设置下方的<strong>Intensity</strong>(发光强度)为4</li><li>最后将材质拖动到Cube上即可</li></ol></li><li>将<strong>EnemyBulletBase</strong>对象拖入到Resources文件夹下，制作成预设体</li><li>在敌人预制体下创建空物体，为其命名为<strong>EnemyFirePos</strong>，即敌人开火位置</li><li>将创建的<strong>EnemyFirePos</strong>对象拖动到<strong>Enemy Controller</strong>脚本下的<strong>Fire Pos</strong>参数中</li><li><p>将所有脚本中的面板参数设置到合适的值，运行游戏即可</p><blockquote><p>注意！！！</p><p>若出现奇奇怪怪的BUG，多去看看面板中参数有没有进行赋值，或者对象拖拽时有没有错误</p></blockquote></li></ol><hr><h2 id="生命值系统"><a href="#生命值系统" class="headerlink" title="生命值系统"></a>生命值系统</h2><blockquote><p>思路：</p><p>方法1：</p><p>将该系统以组件的形式，挂载到游戏对象上。</p><p>它拥有最大生命值，当前生命值等参数，以及受伤、死亡等方法</p><p>方法2：</p><p>通过类继承来实现角色和敌人的生命值系统</p><p>我们可以提取角色和敌人公共的属性和方法，将它们写成一个基类。</p><p>而角色或敌人它们的特殊方法，就在各自的类中实现</p><p>好处：用继承的方式实现，不需要给每个游戏对象额外挂载一个生命值系统的脚本</p></blockquote><h3 id="创建生命系统基类"><a href="#创建生命系统基类" class="headerlink" title="创建生命系统基类"></a>创建生命系统基类</h3><ol><li><p>创建一个LifeSystem脚本</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LifeSystem</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">float</span> hp; <span class="comment">//当前血量</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">float</span> hpMax;  <span class="comment">//最大血量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//激活时就让当前血量等于最大血量,设置虚函数是为了方便子类重写</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnEnable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        hp = hpMax;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//受伤函数，可以传入一个浮点数用于表示伤害值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">TakeDamage</span>(<span class="params"><span class="built_in">float</span> damage</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        hp -= damage;   <span class="comment">//每次受伤时就减血</span></span><br><span class="line">        <span class="keyword">if</span>(hp &lt;= <span class="number">0</span>) <span class="comment">//如果血量为0，就调用死亡函数</span></span><br><span class="line">        &#123;</span><br><span class="line">            Die();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//死亡函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Die</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        hp = <span class="number">0</span>; <span class="comment">//这里将hp = 0是为了死亡时将血条清空</span></span><br><span class="line">        <span class="comment">//如果死亡，就播放死亡特效。死亡特效也是交由对象池管理</span></span><br><span class="line">        PoolManager.Instance().GetObject(<span class="string">&quot;deathVFX&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//死亡后对象禁用，而不是销毁</span></span><br><span class="line">        gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加血函数，我们需要传入参数，表示回复量的大</span></span><br><span class="line">    <span class="comment">//当玩家捡到道具时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AddHp</span>(<span class="params"><span class="built_in">float</span> addHp</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hp != hpMax) <span class="comment">//血量不满时，才会加血</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//  hp += addHp;    这里可以用Clamp函数，简单的防止加血溢出的情况</span></span><br><span class="line">             hp = Mathf.Clamp(hp + addHp, <span class="number">0</span>, hpMax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用协程来实现缓慢回血效果，我们可以传入挂起时间，表示多久回一次血</span></span><br><span class="line">    <span class="comment">//还可以传入一个浮点数，表示回血百分比</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> IEnumerator <span class="title">RestoreHp</span>(<span class="params">WaitForSeconds waitTime, <span class="built_in">float</span> percent</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">while</span>(hp &lt; hpMax)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> waitTime;</span><br><span class="line">            AddHp(hpMax * percent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用协程来实现中毒效果，我们可以传入挂起时间，表示多久回一次血</span></span><br><span class="line">    <span class="comment">//还可以传入一个浮点数，表示回血百分比</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> IEnumerator <span class="title">DamageTimeHp</span>(<span class="params">WaitForSeconds waitTime, <span class="built_in">float</span> percent</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">while</span> (hp &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> waitTime;</span><br><span class="line">            TakeDamage(hpMax * percent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="角色继承生命值系统"><a href="#角色继承生命值系统" class="headerlink" title="角色继承生命值系统"></a>角色继承生命值系统</h3><ol><li>新建一个的<strong>Player</strong>玩家类脚本，让它继承LifeSystem类</li><li>角色类重写基类中的方法</li><li>不要忘记将新建好的脚本挂载到对象上！！！</li><li>不要忘记设置脚本面板上的参数！！</li><li><p>点击面板上的<strong>Overrides</strong>，可以更新预设体设置</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">LifeSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> isRestoreHp = <span class="literal">true</span>;   <span class="comment">//是否开启回血</span></span><br><span class="line">    [<span class="meta">SerializeField,Range(0f,1f)</span>]<span class="comment">//Range特性，增加一个滑动条，限制最大值和最值  </span></span><br><span class="line">    <span class="built_in">float</span> hpRestorePercent; <span class="comment">//回血百分比</span></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="built_in">float</span> hpRestoreTime;    <span class="comment">//回血时间间隔</span></span><br><span class="line"></span><br><span class="line">    Coroutine hpRestoreCoroutine;   <span class="comment">//声明一个协程变量，用于存储RestoreHp协程</span></span><br><span class="line"></span><br><span class="line">    WaitForSeconds waitHpRestoreTime;   <span class="comment">//声明回血时间对象</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//初始化回血时间对象，传入回血时间间隔</span></span><br><span class="line">        waitHpRestoreTime = <span class="keyword">new</span> WaitForSeconds(hpRestoreTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写生命值系统中的受伤方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">TakeDamage</span>(<span class="params"><span class="built_in">float</span> damage</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">base</span>.TakeDamage(damage);</span><br><span class="line">        <span class="keyword">if</span> (gameObject.activeSelf &amp;&amp; isRestoreHp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hpRestoreCoroutine != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//停止协程，这是为了保证生命恢复协程同一时间只开启一个</span></span><br><span class="line">                <span class="comment">//防止玩家回血时，又受伤，然后重复开启协程</span></span><br><span class="line">                StopCoroutine(hpRestoreCoroutine);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将协程存储到协程变量中</span></span><br><span class="line">            hpRestoreCoroutine = StartCoroutine(RestoreHp(waitHpRestoreTime, hpRestorePercent));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="敌人继承生命值系统"><a href="#敌人继承生命值系统" class="headerlink" title="敌人继承生命值系统"></a>敌人继承生命值系统</h3><ol><li>新建一个<strong>Enemy</strong>类，继承<strong>LifeSystem</strong>类</li></ol><h3 id="创建更多敌人以及更多子弹"><a href="#创建更多敌人以及更多子弹" class="headerlink" title="创建更多敌人以及更多子弹"></a>创建更多敌人以及更多子弹</h3><ol><li>将敌人预制体拖拽到场景中</li><li>在敌人下方创建一个空预制体，命名为<strong>EnemyFirePos</strong>，即开火位置</li><li>然后为敌人添加<strong>Enemy</strong>脚本和<strong>Enemy Controller</strong>脚本</li><li><p>设置脚本面板参数</p><h4 id="更多子弹"><a href="#更多子弹" class="headerlink" title="更多子弹"></a>更多子弹</h4></li><li><p>打开Enemy Controller脚本，添加一个GameObject数组，以便添加更多子弹</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    GameObject[] bulletType;<span class="comment">//用于存放多种子弹，以便拿去子弹的名字</span></span><br><span class="line">    [<span class="meta">Header(<span class="meta-string">&quot;----Move----&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="built_in">float</span> moveSpeed = <span class="number">2</span>;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="built_in">float</span> minFireTime, maxFireTime;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="meta-string">&quot;----Fire----&quot;</span>)</span>]</span><br><span class="line">     </span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    Transform firePos;  <span class="comment">//敌人开火位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//敌人每次激活时都会启用协程</span></span><br><span class="line">        StartCoroutine(RandomMove());   <span class="comment">//敌人随机移动协程</span></span><br><span class="line">        StartCoroutine(RandomFireEnemy());  <span class="comment">//敌人随机开火协程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//防止意外，当敌人失活时，将协程全部关闭</span></span><br><span class="line">        StopAllCoroutines();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">RandomMove</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//开始时，敌人的位置将在屏幕外</span></span><br><span class="line">        <span class="keyword">this</span>.transform.position = View.instance.RondomCreateEnemy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录敌人想要移动的目标位置</span></span><br><span class="line">        Vector3 targetPos = View.instance.RandomMoveEnemy();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (gameObject.activeSelf)   <span class="comment">//敌人激活时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当敌人当前位置与目标位置的距离 大于极值时，说明敌人还没到达位置</span></span><br><span class="line">            <span class="keyword">if</span>(Vector3.Distance(transform.position, targetPos) &gt; Mathf.Epsilon)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//利用MoveToward函数,让当前位置到达目标位置，第三个参数是每帧移动量的最大值</span></span><br><span class="line">               <span class="keyword">this</span>.transform.position = Vector3.MoveTowards(transform.position, targetPos, moveSpeed * Time.deltaTime);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//获取敌人Y轴坐标变化的单位四元数。让其在Y轴变化时，会沿着X轴偏移25°</span></span><br><span class="line">                transform.rotation = Quaternion.AngleAxis((targetPos - transform.position).normalized.y * <span class="number">25</span>, Vector3.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//敌人到达目标位置后，更新目标位置</span></span><br><span class="line">                targetPos = View.instance.RandomMoveEnemy();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">RandomFireEnemy</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        GameObject bullet;   <span class="comment">//创建对象用于存储敌人子弹预制体</span></span><br><span class="line">        <span class="keyword">while</span> (gameObject.activeSelf)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//让协程挂起一个随机时间，这样敌人就会随机间隔的发射子弹</span></span><br><span class="line">            <span class="comment">//这里要注意，虽然尽量不要在循环中new对象，但如果将对象创建在外部，就没有随机间隔发射子弹效果</span></span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">Random.Range(minFireTime,maxFireTime</span>))</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当敌人随机发射间隔挂起结束后，敌人将发射子弹</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.transform.position.x &lt; <span class="number">8</span>)   <span class="comment">//避免敌人还没出来就发射子弹</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> i =<span class="number">0</span>; i &lt; bulletType.Length; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    bullet = PoolManager.Instance().GetObject(bulletType[i].name);</span><br><span class="line">                    bullet.transform.position = firePos.position;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>在面板上设置<strong>Bullet Type</strong>数组数量，然后将想要添加的子弹制作成预设体，并添加到数组中</p></li><li><p>设置敌人脚本上的面板参数！</p></li><li><p>在<strong>Enemy Bullet</strong>的脚本上，设置子弹方向</p><h4 id="跟踪子弹"><a href="#跟踪子弹" class="headerlink" title="跟踪子弹"></a>跟踪子弹</h4><blockquote><ol><li>创建一个Sphere圆形物体，命名为<strong>EnemyBullet_Follow</strong>，将Scale设置为(0.2,0.2,0.2)，并取消碰撞体</li><li>为圆形子弹添加之前的材质</li><li>为子弹新建一个<strong>FollowPlayer</strong>脚本，和新增一个<strong>Save Bullet</strong>脚本</li><li>将子弹添加到Resources文件夹，制成预制体，然后将子弹添加到敌人的</li></ol></blockquote></li></ol><hr><h2 id="物理碰撞"><a href="#物理碰撞" class="headerlink" title="物理碰撞"></a>物理碰撞</h2><h3 id="通过层级设置碰撞"><a href="#通过层级设置碰撞" class="headerlink" title="通过层级设置碰撞"></a>通过层级设置碰撞</h3><ol><li>打开<strong>Edit</strong>/<strong>Project Setting</strong>/<strong>Physics 2D</strong>，再拉到最底下，找到<strong>Layer Collision Matrix</strong><ol><li>当表中<strong>横向和纵向</strong>两个<strong>层级相交</strong>时，才可以进行碰撞</li><li>这里我们取消玩家与玩家子弹的勾选，以及敌人和敌人子弹的勾选。它们就不能互相攻击了</li></ol></li></ol><h3 id="为子弹添加碰撞方法"><a href="#为子弹添加碰撞方法" class="headerlink" title="为子弹添加碰撞方法"></a>为子弹添加碰撞方法</h3><ol><li><p>打开之前的<strong>Projectlie</strong>脚本</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Projectile</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">protected</span> GameObject bulletHitVFX; <span class="comment">//子弹击中特效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> GameObject hitVFX;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">protected</span> <span class="built_in">float</span> damage;   <span class="comment">//子弹伤害</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">protected</span> <span class="built_in">float</span> moveSpeed = <span class="number">10</span>;   <span class="comment">//子弹移动速度</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">protected</span> Vector2 moveDirection;  <span class="comment">//子弹移动方向</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">       EnemyMove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span>  <span class="title">EnemyMove</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.transform.Translate(moveDirection * moveSpeed * Time.deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionEnter2D</span>(<span class="params">Collision2D collision</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//判断是否碰撞到了挂载生命系统的对象。</span></span><br><span class="line">        <span class="comment">//TryGetComponent&lt;&gt;()，该函数返回的是一个bool值，若成功则返回T,否则返回F</span></span><br><span class="line">        <span class="keyword">if</span> (collision.gameObject.TryGetComponent&lt;LifeSystem&gt;(<span class="keyword">out</span> LifeSystem ls))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//子弹碰撞到挂载生命系统的对象，则调用受伤函数</span></span><br><span class="line">            ls.TakeDamage(damage);</span><br><span class="line">            <span class="comment">//创建命中特效，传入特效名，交给对象池管理</span></span><br><span class="line">            hitVFX = PoolManager.Instance().GetObject(bulletHitVFX.name);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过collosion.GetContact()函数获取两个对象碰撞的接触点</span></span><br><span class="line">            <span class="keyword">var</span> contactPoint = collision.GetContact(<span class="number">0</span>); <span class="comment">//0表示取第一个接触点</span></span><br><span class="line">          </span><br><span class="line">            hitVFX.transform.position = contactPoint.point; <span class="comment">//创建特效的位置</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//子弹造成伤害后，将子弹禁用，存入对象池中</span></span><br><span class="line">            PoolManager.Instance().SaveObject(<span class="keyword">this</span>.gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="添加刚体和碰撞器"><a href="#添加刚体和碰撞器" class="headerlink" title="添加刚体和碰撞器"></a>添加刚体和碰撞器</h3><ol><li><p>为敌人和角色添加刚体和碰撞器</p><blockquote><p>注意：</p><p>添加刚体时，需要将其重力设置为0，并且要将敌人的X,Y,Z轴都约束住</p><p>人物的Z轴约束</p><p>为角色和敌人添加胶囊碰撞体时，需要将Direction(方向)改为Horizontal，否则不能水平编辑</p></blockquote></li></ol><h3 id="检测碰撞"><a href="#检测碰撞" class="headerlink" title="检测碰撞"></a>检测碰撞</h3><ol><li><p>打开<strong>EnemyBullet</strong>脚本，为其添加碰撞检测方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyBullet</span> : <span class="title">Projectile</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//如果敌人子弹移动方向不是向左的话，更改其移动方向</span></span><br><span class="line">        <span class="keyword">if</span>(moveDirection != Vector2.left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Quaternion.FromToRotation方法更改当前方向</span></span><br><span class="line">            <span class="comment">//参数1是目标方向，参数2是当前方向</span></span><br><span class="line">            <span class="keyword">this</span>.transform.rotation = Quaternion.FromToRotation(Vector2.left, moveDirection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionEnter2D</span>(<span class="params">Collision2D collision</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//判断是否碰撞到了挂载生命系统的对象。</span></span><br><span class="line">        <span class="comment">//TryGetComponent&lt;&gt;()，该函数返回的是一个bool值，若成功则返回T,否则返回F</span></span><br><span class="line">        <span class="keyword">if</span> (collision.gameObject.TryGetComponent&lt;Player&gt;(<span class="keyword">out</span> Player player))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//子弹碰撞到挂载生命系统的对象，则调用受伤函数</span></span><br><span class="line">            player.TakeDamage(damage);</span><br><span class="line">            <span class="comment">//创建命中特效，传入特效名，交给对象池管理</span></span><br><span class="line">            hitVFX = PoolManager.Instance().GetObject(bulletHitVFX.name);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过collosion.GetContact()函数获取两个对象碰撞的接触点</span></span><br><span class="line">            <span class="keyword">var</span> contactPoint = collision.GetContact(<span class="number">0</span>); <span class="comment">//0表示取第一个接触点</span></span><br><span class="line">            hitVFX.transform.position = contactPoint.point;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//子弹造成伤害后，将子弹禁用，存入对象池中</span></span><br><span class="line">            PoolManager.Instance().SaveObject(<span class="keyword">this</span>.gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>打开<strong>PlayerProjectile</strong>脚本，添加碰撞检测</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerProjectile</span> : <span class="title">Projectile</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//声明尾迹渲染器</span></span><br><span class="line">    TrailRenderer trailRenderer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//轨迹组件是在子对象上的，所以用GetComponentInChildren</span></span><br><span class="line">        trailRenderer = GetComponentInChildren&lt;TrailRenderer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子弹对象被禁用时，去掉子弹尾迹</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        trailRenderer.Clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionEnter2D</span>(<span class="params">Collision2D collision</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//判断是否碰撞到了挂载生命系统的对象。</span></span><br><span class="line">        <span class="comment">//TryGetComponent&lt;&gt;()，该函数返回的是一个bool值，若成功则返回T,否则返回F</span></span><br><span class="line">        <span class="keyword">if</span> (collision.gameObject.TryGetComponent&lt;Enemy&gt;(<span class="keyword">out</span> Enemy enemy))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//子弹碰撞到挂载生命系统的对象，则调用受伤函数</span></span><br><span class="line">            enemy.TakeDamage(damage);</span><br><span class="line">            <span class="comment">//创建命中特效，传入特效名，交给对象池管理</span></span><br><span class="line">            hitVFX = PoolManager.Instance().GetObject(bulletHitVFX.name);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过collosion.GetContact()函数获取两个对象碰撞的接触点</span></span><br><span class="line">            <span class="keyword">var</span> contactPoint = collision.GetContact(<span class="number">0</span>); <span class="comment">//0表示取第一个接触点</span></span><br><span class="line">            hitVFX.transform.position = contactPoint.point;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//子弹造成伤害后，将子弹禁用，存入对象池中</span></span><br><span class="line">            PoolManager.Instance().SaveObject(<span class="keyword">this</span>.gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="碰撞粒子特效"><a href="#碰撞粒子特效" class="headerlink" title="碰撞粒子特效"></a>碰撞粒子特效</h3><ol><li>导入碰撞粒子特效</li><li>检查所需脚本有没有挂载到对象上</li><li>检测脚本面版参数有没有设置</li><li>将对应的例子特效拖拽到面版中，用对象池管理</li></ol><hr><h2 id="制作血条"><a href="#制作血条" class="headerlink" title="制作血条"></a>制作血条</h2><p>   将素材导入到场景中</p><h3 id="创造头顶血条"><a href="#创造头顶血条" class="headerlink" title="创造头顶血条"></a>创造头顶血条</h3><ol><li>创建一个UI/Canvas，将其命名为<strong>UI_HP</strong></li><li>设置Canvas的Render Mode(渲染模式)为<strong>World Space</strong>，这是为了让血条一直跟随人物移动</li><li>将主摄像机关联到<strong>Event Camera</strong></li><li>在Canvas下创建一个Image子对象，为其命名为<strong>Background_Hp</strong></li><li>取消<strong>UI_HP</strong>对象下的<strong>Graphic Raycaster</strong>组件 和 <strong>Background_Hp</strong>对象下<strong>Raycast Target</strong>勾选。它们都是用于检测鼠标，这里不需要，取消后可以节约性能</li><li>将对应的血条背景图素材关联到<strong>Background_Hp</strong>，再点击<strong>锚点预设</strong>按键，按住<strong>shitf + ait</strong>，点击右下角，可以将素材覆盖到整个画布的范围。之后子对象都会随着父对象的宽高而变化</li><li>重载<strong>Background_Hp</strong>的Rect Transform，将其的宽高设置为(1,0.8)，再拖动到人物头顶的位置</li><li>Ctrl+D <strong>Background_Hp</strong>对象，重命名为<strong>Middle_Hp</strong></li><li>将文件夹中的Filler图片素材关联到<strong>Middle_Hp</strong>对象中<ol><li>再将其<strong>Image Type</strong>设置为<strong>Filled</strong>(填充类型)</li><li><strong>Fill Method</strong>(填充方法)设置为Horizontal 水平方向填充</li><li>给Front_Hp更改为暗红色</li></ol></li><li><p>Ctrl + D <strong>Middle_Hp</strong>对象，重命名为Front_Hp。并将颜色改为鲜红色</p><blockquote><p>这里需要三层图是因为要实现血条缓冲的效果，所以还需要一个中间的图</p><p>这里要注意图层的顺序，图片对象越在下方，显示在越前面</p></blockquote></li></ol><h3 id="为血条添加材质"><a href="#为血条添加材质" class="headerlink" title="为血条添加材质"></a>为血条添加材质</h3><ol><li>在Shaders文件夹下找到Shader_UI，右键它新建一个材质</li><li>然后在Materials文件夹下新建一个UI文件夹，将上方创建的材质拖入其中，并重命名为<strong>M_Middle_Fill</strong>。最后将其发光强度设置为3</li><li>Ctrl + D该材质，命名为<strong>M_Front_Fill</strong>，发光强度设置为4</li><li>最后将<strong>M_Middle_Fill拖拽给Middle_Hp</strong>，<strong>M_Front_Fill拖拽给Front_Hp</strong>。即可实现发光效果</li></ol><h3 id="为血条关联脚本"><a href="#为血条关联脚本" class="headerlink" title="为血条关联脚本"></a>为血条关联脚本</h3><blockquote><p>在Scripts文件夹中创建一个UI文件夹，用于存放UI脚本</p><p>为血条创建一个StatsBar(状态条),这里的状态条不仅用于血量，还可以用于能量</p></blockquote><ol><li><p>新建一个<strong>StatsBar</strong>脚本</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StatsBar</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>]    Image fillMid, fillFront;   <span class="comment">//声明两个图片类变量</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>]    <span class="built_in">float</span> fillSpeed = <span class="number">0.1f</span>;    <span class="comment">//图片填充速度</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> currentFillAmount;    <span class="comment">//图片当前的填充值</span></span><br><span class="line">    <span class="built_in">float</span> targetFillAmount;     <span class="comment">//图片目标填充值</span></span><br><span class="line"></span><br><span class="line">    Coroutine bufferFill;   <span class="comment">//协程变量</span></span><br><span class="line"></span><br><span class="line">    Canvas canvas;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        canvas = GetComponent&lt;Canvas&gt;();</span><br><span class="line">        canvas.worldCamera = Camera.main;   <span class="comment">//游戏一开始时，就将worldCamera设置为主摄像机</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//角色失活时关闭所有协程</span></span><br><span class="line">        StopAllCoroutines();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于初始化状态条的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"><span class="built_in">float</span> currentValue, <span class="built_in">float</span> maxValue</span>)    <span class="comment">//传入当前值 和 最大值  </span></span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//当前状态值除以最大状态值，获得一个百分比，然后将其赋值给图片当前填充值</span></span><br><span class="line">        currentFillAmount = currentValue / maxValue;</span><br><span class="line">        targetFillAmount = currentFillAmount;       <span class="comment">//初始化时目标值等于当前值</span></span><br><span class="line">        fillFront.fillAmount = currentFillAmount;   <span class="comment">//图片的填充也是最大</span></span><br><span class="line">        fillMid.fillAmount = currentFillAmount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态更新函数，当状态条发生变化时，调用这个函数来更新状态条</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UpdateStats</span>(<span class="params"><span class="built_in">float</span> currentValue, <span class="built_in">float</span> maxValue</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//当前状态值除以最大状态值，获得一个百分比，然后将其赋值给图片目标填充值</span></span><br><span class="line">        targetFillAmount = currentValue / maxValue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//要考虑到函数频繁调用时，协程重复开启的问题，所以在协程开启前，先关闭</span></span><br><span class="line">        <span class="keyword">if</span>(bufferFill != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            StopCoroutine(bufferFill);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当状态值减少时</span></span><br><span class="line">        <span class="keyword">if</span>(currentFillAmount &gt; targetFillAmount)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//前面图片的填充值 = 目标填充值</span></span><br><span class="line">            fillFront.fillAmount = targetFillAmount;</span><br><span class="line">            <span class="comment">//然后慢慢减少中间图片</span></span><br><span class="line">           bufferFill =  StartCoroutine(BufferFill(fillMid));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//当状态值增加时</span></span><br><span class="line">        <span class="keyword">if</span>(currentFillAmount &lt; targetFillAmount)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//中间图片的填充值 = 目标填充值</span></span><br><span class="line">            fillMid.fillAmount = targetFillAmount;</span><br><span class="line">            <span class="comment">//前面图片的填充值慢慢增加</span></span><br><span class="line">            bufferFill = StartCoroutine(BufferFill(fillFront));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">BufferFill</span>(<span class="params">Image image</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(t &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t += Time.deltaTime * fillSpeed;</span><br><span class="line">            <span class="comment">//这里线性插值的t会被频繁使用，所以将其声明为本地变量，减少CG</span></span><br><span class="line">            currentFillAmount = Mathf.Lerp(currentFillAmount, targetFillAmount, t);</span><br><span class="line">            image.fillAmount = currentFillAmount;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>打开之前的LifeSystem脚本进行更新</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LifeSystem</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">protected</span> GameObject deathVFX;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>] StatsBar hpBar;    <span class="comment">//声明一个血条</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">bool</span> showHpBar = <span class="literal">true</span>; <span class="comment">//是否显示血条</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">float</span> hp; <span class="comment">//当前血量</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">float</span> hpMax;  <span class="comment">//最大血量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//激活时就让当前血量等于最大血量,设置虚函数是为了方便子类重写</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnEnable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        hp = hpMax;</span><br><span class="line">        <span class="keyword">if</span> (showHpBar)  <span class="comment">//如果显示血条</span></span><br><span class="line">        &#123;</span><br><span class="line">            ShowHpBar();<span class="comment">//调用显血函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            HideHpBar();<span class="comment">//关闭时则调用隐藏函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowHpBar</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        hpBar.gameObject.SetActive(<span class="literal">true</span>);   <span class="comment">//激活血条</span></span><br><span class="line">        hpBar.Init(hp,hpMax);   <span class="comment">//血条初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HideHpBar</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        hpBar.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//受伤函数，可以传入一个浮点数用于表示伤害值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">TakeDamage</span>(<span class="params"><span class="built_in">float</span> damage</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        hp -= damage;   <span class="comment">//每次受伤时就减血</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (showHpBar &amp;&amp; gameObject.activeSelf)  <span class="comment">//如果血条显示且角色处于激活状态</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//受伤时就调用血条的更新状态条函数，传入当前血量和最大血量</span></span><br><span class="line">            hpBar.UpdateStats(hp,hpMax);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(hp &lt;= <span class="number">0</span>) <span class="comment">//如果血量为0，就调用死亡函数</span></span><br><span class="line">        &#123;</span><br><span class="line">            Die();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//死亡函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Die</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        hp = <span class="number">0</span>; <span class="comment">//这里将hp = 0是为了死亡时将血条清空</span></span><br><span class="line">        <span class="comment">//如果死亡，就播放死亡特效。死亡特效也是交由对象池管理</span></span><br><span class="line">        GameObject obj = PoolManager.Instance().GetObject(deathVFX.name);</span><br><span class="line">        obj.transform.position = <span class="keyword">this</span>.transform.position;</span><br><span class="line">        <span class="comment">//死亡后对象禁用，而不是销毁</span></span><br><span class="line">        gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加血函数，我们需要传入参数，表示回复量的大</span></span><br><span class="line">    <span class="comment">//当玩家捡到道具时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AddHp</span>(<span class="params"><span class="built_in">float</span> addHp</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hp != hpMax) <span class="comment">//血量不满时，才会加血</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//  hp += addHp;    这里可以用Clamp函数，简单的防止加血溢出的情况</span></span><br><span class="line">             hp = Mathf.Clamp(hp + addHp, <span class="number">0</span>, hpMax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (showHpBar)  <span class="comment">//如果血条显示</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//加血时就调用血条的更新状态条函数，传入当前血量和最大血量</span></span><br><span class="line">            hpBar.UpdateStats(hp, hpMax);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用协程来实现缓慢回血效果，我们可以传入挂起时间，表示多久回一次血</span></span><br><span class="line">    <span class="comment">//还可以传入一个浮点数，表示回血百分比</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> IEnumerator <span class="title">RestoreHp</span>(<span class="params">WaitForSeconds waitTime, <span class="built_in">float</span> percent</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">while</span>(hp &lt; hpMax)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> waitTime;</span><br><span class="line">            AddHp(hpMax * percent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用协程来实现中毒效果，我们可以传入挂起时间，表示多久回一次血</span></span><br><span class="line">    <span class="comment">//还可以传入一个浮点数，表示回血百分比</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> IEnumerator <span class="title">DamageTimeHp</span>(<span class="params">WaitForSeconds waitTime, <span class="built_in">float</span> percent</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">while</span> (hp &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> waitTime;</span><br><span class="line">            TakeDamage(hpMax * percent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li>将相应的面板对象拖动到血条脚本的对应字段中</li><li>在Prefab文件夹中创建一个UI文件夹，将UI_HP对象做出预制体</li><li>Ctrl + D一个新的预制体，为其命名为UI_HP_Enemy,并将其颜色改为紫色</li><li>将玩家血条 和 敌人血条分别拖动到玩家和敌人对象下。这里可以为不同的敌人设置不同长度的血量</li><li><strong>将玩家和敌人血条关联到 各自的脚本对象的字段上</strong></li></ol><h3 id="HUD血条"><a href="#HUD血条" class="headerlink" title="HUD血条"></a>HUD血条</h3><ol><li>取消场景中<strong>UI_HP_Player</strong>对象的预制体。    通过右键/Prefab/Unpack Competely</li><li>将UI_HP_Player对象的渲染模式换成Camera摄像机模式</li><li>更改UI_HP_Player的名字为UI_HP_HUD</li><li>为其关联主摄像机</li><li>把Plane Distance平面距离参数设置为5</li><li>将UI Scale Mode 改为缩放模式，分辨率为1920*1080</li><li>选中UI_HP_Player对象下的<strong>Background_Hp</strong>，点击其锚点预设按钮，将其改为居中。并设置宽高为512*256</li><li>将<strong>Middle_Hp</strong> 和 <strong>Front_Hp</strong>，拖动到<strong>Background_Hp</strong>对象下，设置其子对象。然后点击它们的锚点预设按钮，按住<strong>Alt</strong>键，让这两个图片的锚点全拉伸。这样血条就会变</li><li>找到HUD文件夹下的三张遮罩图片，将<strong>Backrground</strong>图片拖拽给<strong>Background_Hp</strong>，将<strong>Filler</strong>拖拽给<strong>Middle_Hp</strong> 和 <strong>Front_Hp</strong></li><li>再Ctrl + D <strong>Middle_Hp</strong>对象，复制一张填充图片，重命名为Mask<ol><li>修改其Fill Amount(填充值)为1</li><li>Type类型修改为Simpe</li><li>图片源修改为Mask图片</li><li>给其添加一个Mask遮罩组件</li><li>最后将<strong>Middle_Hp</strong> 和 <strong>Front_Hp</strong>拖动到<strong>Mask</strong>下设置为它的子对象即可</li></ol></li><li>在<strong>Background_HP</strong>对象下方创建两个<strong>Text</strong>子对象，取消勾选它们的<strong>Raycast Target</strong>，它们不需要射线检测，可以节约性能</li><li>更改文本框中的字体，再将M_Middle_Fill材质拖动给它们</li><li>第一个文本框内的内容是HP，第二个文本框显示血量百分比，我们输入100%。并修改它们的文字的颜色以及大</li><li>最后选中Background_HP对象，点击它的锚点预制件，同时按住<strong>Shift + alt</strong> 然后点击左上角，这样就能将对象的锚点和位置都移动到左上角。并且视口分辨率不会影响到它</li></ol><h3 id="为HUD血条添加脚本"><a href="#为HUD血条添加脚本" class="headerlink" title="为HUD血条添加脚本"></a>为HUD血条添加脚本</h3><blockquote><p>由于我们之前的HUD血条是在普通血条的预制体上是实现，所以不要忘记移除它身上的StatsBar脚本。我们需要重新为它编写脚本</p></blockquote><ol><li><p>新建一个<strong>StatsBar_HUD</strong>脚本，挂载到UI_HP_HUD对象上。它将继承StatsBar</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StatsBar_HUD</span> : <span class="title">StatsBar</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] Text percentText;  <span class="comment">//声明百分比文本</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置百分比文本函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetPercentText</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//targetFillAmount的值介于0~1之间</span></span><br><span class="line">        <span class="comment">//我们不想让其显示数，所以通过Mathf.RoundToInt()方法，可以将浮点数转换成最接近的整数</span></span><br><span class="line">        percentText.text = Mathf.RoundToInt(targetFillAmount * <span class="number">100f</span>) + <span class="string">&quot;%&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写初始化函数，在调用基类函数之后，调用设置百分比函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"><span class="built_in">float</span> currentValue, <span class="built_in">float</span> maxValue</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">base</span>.Init(currentValue, maxValue);</span><br><span class="line">        SetPercentText();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写缓慢减血的协程，先设置百分比后再调用协程</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> IEnumerator <span class="title">BufferFill</span>(<span class="params">Image image</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        SetPercentText();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">base</span>.BufferFill(image);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>更改<strong>StatsBar脚本</strong>中的内容，将一些属性和方法设置为保护类型，以及设置为虚函数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StatsBar</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>]    Image fillMid, fillFront;   <span class="comment">//声明两个图片类变量</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>]    <span class="built_in">float</span> fillSpeed = <span class="number">0.1f</span>;    <span class="comment">//图片填充速度</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> currentFillAmount;    <span class="comment">//图片当前的填充值</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">float</span> targetFillAmount;     <span class="comment">//图片目标填充值</span></span><br><span class="line"></span><br><span class="line">    Coroutine bufferFill;   <span class="comment">//协程变量</span></span><br><span class="line"></span><br><span class="line">    Canvas canvas;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        canvas = GetComponent&lt;Canvas&gt;();</span><br><span class="line">        canvas.worldCamera = Camera.main;   <span class="comment">//游戏一开始时，就将worldCamera设置为主摄像机</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于初始化状态条的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"><span class="built_in">float</span> currentValue, <span class="built_in">float</span> maxValue</span>)    <span class="comment">//传入当前值 和 最大值  </span></span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//当前状态值除以最大状态值，获得一个百分比，然后将其赋值给图片当前填充值</span></span><br><span class="line">        currentFillAmount = currentValue / maxValue;</span><br><span class="line">        targetFillAmount = currentFillAmount;       <span class="comment">//初始化时目标值等于当前值</span></span><br><span class="line">        fillFront.fillAmount = currentFillAmount;   <span class="comment">//图片的填充也是最大</span></span><br><span class="line">        fillMid.fillAmount = currentFillAmount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态更新函数，当状态条发生变化时，调用这个函数来更新状态条</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UpdateStats</span>(<span class="params"><span class="built_in">float</span> currentValue, <span class="built_in">float</span> maxValue</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//当前状态值除以最大状态值，获得一个百分比，然后将其赋值给图片目标填充值</span></span><br><span class="line">        targetFillAmount = currentValue / maxValue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//要考虑到函数频繁调用时，协程重复开启的问题，所以在协程开启前，先关闭</span></span><br><span class="line">        <span class="keyword">if</span>(bufferFill != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            StopCoroutine(bufferFill);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当状态值减少时</span></span><br><span class="line">        <span class="keyword">if</span>(currentFillAmount &gt; targetFillAmount)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//前面图片的填充值 = 目标填充值</span></span><br><span class="line">            fillFront.fillAmount = targetFillAmount;</span><br><span class="line">            <span class="comment">//然后慢慢减少中间图片</span></span><br><span class="line">           bufferFill =  StartCoroutine(BufferFill(fillMid));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当状态值增加时</span></span><br><span class="line">        <span class="keyword">if</span>(currentFillAmount &lt; targetFillAmount)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//中间图片的填充值 = 目标填充值</span></span><br><span class="line">            fillMid.fillAmount = targetFillAmount;</span><br><span class="line">            <span class="comment">//前面图片的填充值慢慢增加</span></span><br><span class="line">            bufferFill = StartCoroutine(BufferFill(fillFront));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> IEnumerator <span class="title">BufferFill</span>(<span class="params">Image image</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(t &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t += Time.deltaTime * fillSpeed;</span><br><span class="line">            <span class="comment">//这里线性插值的t会被频繁使用，所以将其声明为本地变量，减少CG</span></span><br><span class="line">            currentFillAmount = Mathf.Lerp(currentFillAmount, targetFillAmount, t);</span><br><span class="line">            image.fillAmount = currentFillAmount;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>打开之前的<strong>Player</strong>脚本，将HUD血条和人物的普通血条关联起来</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">LifeSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] StatsBar_HUD statsBar_HUD;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">bool</span> isRestoreHp = <span class="literal">true</span>;   <span class="comment">//是否开启回血</span></span><br><span class="line">    [<span class="meta">SerializeField,Range(0f,1f)</span>]  <span class="comment">//Range特性，可以增加一个滑动条，并限制最大值和最值  </span></span><br><span class="line">    <span class="built_in">float</span> hpRestorePercent; <span class="comment">//回血百分比</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> hpRestoreTime;    <span class="comment">//回血时间间隔</span></span><br><span class="line"></span><br><span class="line">    Coroutine hpRestoreCoroutine;   <span class="comment">//声明一个协程变量，用于存储RestoreHp协程</span></span><br><span class="line"></span><br><span class="line">    WaitForSeconds waitHpRestoreTime;   <span class="comment">//声明回血时间对象</span></span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//初始化回血时间对象，传入回血时间间隔</span></span><br><span class="line">        waitHpRestoreTime = <span class="keyword">new</span> WaitForSeconds(hpRestoreTime);</span><br><span class="line">        statsBar_HUD.Init(hp, hpMax);   <span class="comment">//在Start函数中初始化HUD血条</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写生命值系统中的受伤方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">TakeDamage</span>(<span class="params"><span class="built_in">float</span> damage</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">base</span>.TakeDamage(damage);</span><br><span class="line">        statsBar_HUD.UpdateStats(hp, hpMax);<span class="comment">//受伤函数调用后，调用更新HUD血条的函数</span></span><br><span class="line">        <span class="keyword">if</span> (gameObject.activeSelf &amp;&amp; isRestoreHp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hpRestoreCoroutine != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//停止协程，这是为了保证生命恢复协程同一时间只开启一个</span></span><br><span class="line">                <span class="comment">//防止玩家回血时，又受伤，然后重复开启协程</span></span><br><span class="line">                StopCoroutine(hpRestoreCoroutine);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将协程存储到协程变量中</span></span><br><span class="line">            hpRestoreCoroutine = StartCoroutine(RestoreHp(waitHpRestoreTime, hpRestorePercent));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写生命值系统中的回血方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">AddHp</span>(<span class="params"><span class="built_in">float</span> addHp</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">base</span>.AddHp(addHp);</span><br><span class="line">        statsBar_HUD.UpdateStats(hp, hpMax);<span class="comment">//加血函数调用后，调用更新HUD血条的函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写生命值系统中的死亡方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Die</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//在死亡函数调用前，调用更新血条函数，将血条设置为0</span></span><br><span class="line">        statsBar_HUD.UpdateStats(<span class="number">0</span>, hpMax);</span><br><span class="line">        <span class="keyword">base</span>.Die();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li>将<strong>Middle_Hp</strong> 拖拽到StatsBar_HUD脚本的<strong>Fill Mid</strong>参数中，将<strong>Front_Hp</strong>拖动到<strong>Fill Front</strong>参数中，将<strong>Percent_Text</strong>对象 拖拽到 Percent_Text参数中</li><li><p>将<strong>HUD</strong>血条拖拽到Player对象的Player脚本的参数中</p><blockquote><p>如果运行时出现报错，多检查是否有脚本的参数未拖拽或未赋值</p></blockquote></li></ol><hr><h2 id="能量系统"><a href="#能量系统" class="headerlink" title="能量系统"></a>能量系统</h2><h3 id="制作能量条"><a href="#制作能量条" class="headerlink" title="制作能量条"></a>制作能量条</h3><ol><li>选中UI_HP_HUD,然后Ctrl + D，复制一份能量条，为其命名为UI_Energy_HUD</li><li>更改Text文本中的名称，以及内容，还有颜色</li><li>在Mask文件夹下更改能量条的前景色与中景色</li><li>移除UI_Energy_HUD对象上的StatsBar_HUD脚本，为其新建一个<strong>EnergyBar</strong>脚本，继承于<strong>EnergyBar_HUD</strong></li><li><p>为<strong>EnergyBar</strong>脚本的参数进行对象关联</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnergyBar</span> : <span class="title">StatsBar_HUD</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//里面暂时不需要写任何的内容，只需要继承StatsBar_HUD即可，然后在外部对参数进行关联</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="为能量条添加脚本"><a href="#为能量条添加脚本" class="headerlink" title="为能量条添加脚本"></a>为能量条添加脚本</h3><ol><li><p>新建一个<strong>PlayerEnergy</strong>脚本，不要忘记将脚本挂载到Player对象上</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们只有一个玩家和一个能量系统，为了让其他类更方便调用能量系统，可以将其设置为单例模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerEnergy</span> :  <span class="title">SingletonBase</span>&lt;<span class="title">PlayerEnergy</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">   [<span class="meta">SerializeField</span>] EnergyBar energyBar;</span><br><span class="line">    <span class="comment">//最大能量值我们不会去改动，所以设置为常量</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> MAX_ENERGY = <span class="number">100</span>;   <span class="comment">//最大能量条为100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> PERCENT = <span class="number">1</span>;   <span class="comment">//每次增加1点能量</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> energy; <span class="comment">//当前能量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//初始化能量条</span></span><br><span class="line">        energyBar.Init(energy,MAX_ENERGY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加能量的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddEnergy</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (energy == MAX_ENERGY) <span class="keyword">return</span>;<span class="comment">//如果能量条满了，则直接返回</span></span><br><span class="line">        <span class="comment">//energy += value;//能量条没满时，增加能量</span></span><br><span class="line">        energy = Mathf.Clamp(energy + <span class="keyword">value</span>, <span class="number">0</span>, MAX_ENERGY);</span><br><span class="line">        energyBar.UpdateStats(energy, MAX_ENERGY);   <span class="comment">//更新能量条</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用能量函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UseEnergy</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        energy -= <span class="keyword">value</span>;    <span class="comment">//能量值消耗</span></span><br><span class="line">        energyBar.UpdateStats(energy, MAX_ENERGY);  <span class="comment">//更新能量条</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前能量值是否足够函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsEnough</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> energy &gt;= <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>先打开<strong>Projectile</strong>子弹类脚本</p><blockquote><p>这里主要的逻辑是，要重写OnCollisionEnter()方法，方便玩家子弹类重写里面的方法</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnCollisionEnter2D</span>(<span class="params">Collision2D collision</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判断是否碰撞到了挂载生命系统的对象。</span></span><br><span class="line">    <span class="comment">//TryGetComponent&lt;&gt;()，该函数返回的是一个bool值，若成功则返回T,否则返回F</span></span><br><span class="line">    <span class="keyword">if</span> (collision.gameObject.TryGetComponent&lt;LifeSystem&gt;(<span class="keyword">out</span> LifeSystem ls))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子弹碰撞到挂载生命系统的对象，则调用受伤函数</span></span><br><span class="line">        ls.TakeDamage(damage);</span><br><span class="line">        <span class="comment">//创建命中特效，传入特效名，交给对象池管理</span></span><br><span class="line">        hitVFX = PoolManager.Instance().GetObject(bulletHitVFX.name);</span><br><span class="line">   </span><br><span class="line">        <span class="comment">//通过collosion.GetContact()函数获取两个对象碰撞的接触点</span></span><br><span class="line">        <span class="keyword">var</span> contactPoint = collision.GetContact(<span class="number">0</span>); <span class="comment">//0表示取第一个接触点</span></span><br><span class="line">      </span><br><span class="line">        hitVFX.transform.position = contactPoint.point; <span class="comment">//创建特效的位置</span></span><br><span class="line">   </span><br><span class="line">        <span class="comment">//子弹造成伤害后，将子弹禁用，存入对象池中</span></span><br><span class="line">        PoolManager.Instance().SaveObject(<span class="keyword">this</span>.gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>再打开<strong>PlayerProjectile</strong>玩家子弹类脚本</p><blockquote><p>这里的逻辑是，当玩家的子弹命中敌人后，增加能量</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerProjectile</span> : <span class="title">Projectile</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//声明尾迹渲染器</span></span><br><span class="line">    TrailRenderer trailRenderer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//轨迹组件是在子对象上的，所以用GetComponentInChildren</span></span><br><span class="line">        trailRenderer = GetComponentInChildren&lt;TrailRenderer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子弹对象被禁用时，去掉子弹尾迹</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        trailRenderer.Clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写触发函数</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCollisionEnter2D</span>(<span class="params">Collision2D collision</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//实现父类的方法后</span></span><br><span class="line">        <span class="keyword">base</span>.OnCollisionEnter2D(collision);</span><br><span class="line">        <span class="comment">//新增命中敌人增加1点能量的方法</span></span><br><span class="line">        <span class="keyword">if</span> (GameObject.Find(<span class="string">&quot;Player&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            PlayerEnergy.instance.AddEnergy(PlayerEnergy.PERCENT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>打开之前的<strong>Enmey</strong>脚本，重写它的死亡方法</p><blockquote><p>这里的主要目的是，当敌人死亡时，玩家调用增加能量的方法，增加能量</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy</span> : <span class="title">LifeSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> deathEnergyBonus = <span class="number">3</span>;   <span class="comment">//敌人死亡时玩家的能量奖励</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写敌人死亡函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Die</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//当敌人死亡之前，将会给玩家增加能量</span></span><br><span class="line">        PlayerEnergy.instance.AddEnergy(deathEnergyBonus);</span><br><span class="line">        <span class="keyword">base</span>.Die();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>不要忘记将<strong>UI_Energy_HUD</strong>对象关联到<strong>PlayerEnergy</strong>脚本中</p></li></ol><hr><h2 id="闪避功能"><a href="#闪避功能" class="headerlink" title="闪避功能"></a>闪避功能</h2><ol><li><p>打开之气的<strong>PlayerController</strong>脚本</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="built_in">float</span> moveSpeed;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="built_in">float</span> rotationSpeed;</span><br><span class="line">    <span class="built_in">float</span> hor, ver;</span><br><span class="line">    <span class="comment">//  float minX, maxX, minY, maxY;</span></span><br><span class="line">    [<span class="meta">Header(<span class="meta-string">&quot;----闪避-----&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> dodgeEnergy = <span class="number">25</span>;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> maxRoll = <span class="number">360</span>;       <span class="comment">//玩家闪避时最多旋转两圈</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> rollSpeed = <span class="number">360</span>;     <span class="comment">//每秒的翻滚速度</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> nowRoll;  <span class="comment">//当前的旋转角度</span></span><br><span class="line">    <span class="built_in">bool</span> isDogeing = <span class="literal">false</span>; <span class="comment">//正在闪避</span></span><br><span class="line"></span><br><span class="line">    Collider2D cd2d;  <span class="comment">//获取玩家碰撞体</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        cd2d = GetComponent&lt;Collider2D&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Move();</span><br><span class="line">        Rotation();</span><br><span class="line">        Dodge();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Move</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        hor = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        ver = Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.transform.Translate(Vector3.right * moveSpeed * Time.deltaTime * hor);</span><br><span class="line">        <span class="keyword">this</span>.transform.Translate(Vector3.up * moveSpeed * Time.deltaTime * ver,Space.World);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将人物的位置限制在相机视口范围内</span></span><br><span class="line">        <span class="comment">//this.transform.position = new Vector3(Mathf.Clamp(transform.position.x, minX, maxX), </span></span><br><span class="line">        <span class="comment">//    Mathf.Clamp(transform.position.y, minY, maxY),this.transform.position.z);</span></span><br><span class="line">        print(EnemyManager.instance+<span class="string">&quot;2222222222&quot;</span>);</span><br><span class="line">        print(View.instance);</span><br><span class="line">        <span class="keyword">this</span>.transform.position = <span class="keyword">new</span> Vector3(Mathf.Clamp(transform.position.x, View.instance.minX, View.instance.maxX),</span><br><span class="line">    Mathf.Clamp(transform.position.y, View.instance.minY, View.instance.maxY), <span class="keyword">this</span>.transform.position.z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Rotation</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetKey(KeyCode.W))</span><br><span class="line">        &#123;</span><br><span class="line">            Quaternion q = Quaternion.AngleAxis(<span class="number">45</span>,Vector3.right);</span><br><span class="line">            <span class="keyword">this</span>.transform.rotation = Quaternion.Slerp(<span class="keyword">this</span>.transform.rotation, q, Time.deltaTime * rotationSpeed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Input.GetKey(KeyCode.S))</span><br><span class="line">        &#123;</span><br><span class="line">            Quaternion q = Quaternion.AngleAxis(<span class="number">-45</span>, Vector3.right);</span><br><span class="line">            <span class="keyword">this</span>.transform.rotation = Quaternion.Slerp(<span class="keyword">this</span>.transform.rotation, q, Time.deltaTime * rotationSpeed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Quaternion q = Quaternion.AngleAxis(<span class="number">0</span>, Vector3.right);</span><br><span class="line">            <span class="keyword">this</span>.transform.rotation = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Dodge</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//如果按下回车键,则触发闪避</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.E))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//正在闪避或者能量不足时，不能进行闪避</span></span><br><span class="line">            <span class="keyword">if</span> (isDogeing || !FindObjectOfType&lt;PlayerEnergy&gt;().IsEnough(dodgeEnergy))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            StartCoroutine(PlayerDodge());  <span class="comment">//开启闪避协程</span></span><br><span class="line">            <span class="comment">//改变人物缩放值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//玩家闪避协程</span></span><br><span class="line">    <span class="function">IEnumerator <span class="title">PlayerDodge</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        isDogeing = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//触发闪避时需要消耗能量</span></span><br><span class="line">        PlayerEnergy.instance.UseEnergy(dodgeEnergy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//触发闪避时玩家无敌</span></span><br><span class="line">        <span class="comment">//这里有好几种方法，可以改变玩家图层，让子弹检测不到</span></span><br><span class="line">        <span class="comment">//还可以将玩家的IsTirgger开始，让玩家变成触发器，这样就不能与子弹碰撞</span></span><br><span class="line">        cd2d.isTrigger = <span class="literal">true</span>;    <span class="comment">//闪避开始时为true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//触发闪避时视觉上人物X轴会进行翻转</span></span><br><span class="line">        <span class="keyword">while</span> (nowRoll &lt; maxRoll)    <span class="comment">//当前旋转于最大旋转</span></span><br><span class="line">        &#123;</span><br><span class="line">            nowRoll += rollSpeed * Time.deltaTime;</span><br><span class="line">            transform.rotation = Quaternion.AngleAxis(nowRoll, Vector3.right);  <span class="comment">//利用四元数沿着X轴旋转</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nowRoll = <span class="number">0</span>;    <span class="comment">//重置当前旋转，否则改值会一直大于maxRoll，这样的话人物只能旋转一次</span></span><br><span class="line">        cd2d.isTrigger = <span class="literal">false</span>;   <span class="comment">//闪避结束后为false</span></span><br><span class="line">        isDogeing = <span class="literal">false</span>;  <span class="comment">//闪避结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="敌人管理器"><a href="#敌人管理器" class="headerlink" title="敌人管理器"></a>敌人管理器</h2><p>   敌人管理器只会有一个，我们用它继承单例模式基类。用于控制敌人的生成、刷新等功能</p><h3 id="随机生成敌人"><a href="#随机生成敌人" class="headerlink" title="随机生成敌人"></a>随机生成敌人</h3><blockquote><p>思路：</p><p>首先我们需要一个存储所有敌人预制体数量的<strong>数组</strong></p><p>每次生成敌人时，我们都从这个数组中<strong>随机取出</strong>一个敌人预制体</p><p>然后让<strong>对象池</strong>系统帮我们<strong>生成这个敌人</strong></p><p>敌人是一波一波生成的，我们还需要用一个<strong>整形变量</strong>来<strong>存储</strong>当前<strong>敌人的波数</strong></p><p>最后使用<strong>协程</strong>来依次生成当前波数中的所有敌人</p><p>这里我们需要用一个<strong>整形变量</strong>来控制每一波<strong>敌人的数量</strong>，还需要一个<strong>浮点型变量</strong>来控制<strong>敌人生成的时间间隔</strong></p></blockquote><ol><li><p>新建一个EnemyManager脚本，它继承单例模式基类</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承单例模式基类，真单例不能挂载到对象上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyManager</span> : <span class="title">SingletonBase</span>&lt;<span class="title">EnemyManager</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] GameObject[] enemyPrefabs;     <span class="comment">//敌人预制体数组，不要忘记外部进行关联</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> enemySpawnTime = <span class="number">1</span>;    <span class="comment">//敌人生成时间间隔</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> waveNumber = <span class="number">1</span>; <span class="comment">//敌人波数从1开始</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> enemyAmount;    <span class="comment">//敌人每波的数量</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> minEnmeyAmount = <span class="number">3</span>; <span class="comment">//最敌人数量</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> maxEnmeyAmount = <span class="number">9</span>;    <span class="comment">//最大敌人数量</span></span><br><span class="line"></span><br><span class="line">    WaitForSeconds wait;    <span class="comment">//等待敌人生成的间隔时间</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//如果不继承MonoBehaviour，则不能启用协程</span></span><br><span class="line">        StartCoroutine(RandomSpawn());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">RandomSpawn</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        wait = <span class="keyword">new</span> WaitForSeconds(enemySpawnTime);</span><br><span class="line">        <span class="comment">//限制敌人数量，并实现每3波最敌人数量就会+1</span></span><br><span class="line">        enemyAmount = Mathf.Clamp(enemyAmount, minEnmeyAmount + waveNumber / <span class="number">3</span>, maxEnmeyAmount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; enemyAmount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从敌人预制体数组中随机取一个敌人预制体对象</span></span><br><span class="line">            <span class="keyword">var</span> enemy = enemyPrefabs[Random.Range(<span class="number">0</span>, enemyPrefabs.Length)];</span><br><span class="line">            PoolManager.Instance().GetObject(enemy.name);   <span class="comment">//利用对象池创建敌人</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> wait;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        waveNumber++;   <span class="comment">//当前波数敌人生成完毕后，波数+1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="敌人刷新"><a href="#敌人刷新" class="headerlink" title="敌人刷新"></a>敌人刷新</h3><blockquote><p>思路：</p><p>当我们场景中的敌人全部死亡时，我们需要将敌人刷新，然后开启下一波</p><p>方法：</p><p>1、可以用GameObject.Find()，遍历场景中的所有敌人，好处是简单，坏处是遍历所需时间较大，比较消耗性能</p><p>2、可以创建一个Enmey List，敌人生成时加入列表，敌人死亡时移除列表。最后只需要判断列表是否为空即可。</p></blockquote><ol><li><p>打开之前的<strong>EnemyManager</strong>脚本。在其中创建一个敌人列表，当敌人创建时加入列表，再写一个移除列表的方法给外部调用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承单例模式基类，真单例不能挂载到对象上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyManager</span> : <span class="title">SingletonBase</span>&lt;<span class="title">EnemyManager</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] GameObject[] enemyPrefabs;     <span class="comment">//敌人预制体数组，不要忘记外部进行关联</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> enemySpawnTime = <span class="number">1</span>;    <span class="comment">//敌人生成时间间隔</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> waveNumber = <span class="number">1</span>; <span class="comment">//敌人波数从1开始</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> enemyAmount;    <span class="comment">//敌人每波的数量</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> minEnmeyAmount = <span class="number">3</span>; <span class="comment">//最敌人数量</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> maxEnmeyAmount = <span class="number">9</span>;    <span class="comment">//最大敌人数量</span></span><br><span class="line"></span><br><span class="line">    WaitForSeconds wait;    <span class="comment">//等待敌人生成的间隔时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************************************/</span></span><br><span class="line">    <span class="comment">//创建一个敌人列表</span></span><br><span class="line">    List&lt;GameObject&gt; enemyList;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/***************************************************************/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        enemyList = <span class="keyword">new</span> List&lt;GameObject&gt;();<span class="comment">//在Awake中初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//如果不继承MonoBehaviour，则不能启用协程</span></span><br><span class="line">        StartCoroutine(RandomSpawn());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">RandomSpawn</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        wait = <span class="keyword">new</span> WaitForSeconds(enemySpawnTime);</span><br><span class="line">        <span class="comment">//限制敌人数量，并实现每3波最敌人数量就会+1</span></span><br><span class="line">        enemyAmount = Mathf.Clamp(enemyAmount, minEnmeyAmount + waveNumber / <span class="number">3</span>, maxEnmeyAmount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; enemyAmount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从敌人预制体数组中随机取一个敌人预制体对象</span></span><br><span class="line">            <span class="keyword">var</span> enemy = enemyPrefabs[Random.Range(<span class="number">0</span>, enemyPrefabs.Length)];</span><br><span class="line">            PoolManager.Instance().GetObject(enemy.name);   <span class="comment">//利用对象池创建敌人</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************************************/</span></span><br><span class="line">        </span><br><span class="line">            enemyList.Add(enemy);   <span class="comment">//将敌人添加到链表中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************************************/</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> wait;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        waveNumber++;   <span class="comment">//当前波数敌人生成完毕后，波数+1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************************************/</span></span><br><span class="line">    <span class="comment">//从链表中移除敌人的方法，提供给外部调用。</span></span><br><span class="line">    <span class="comment">//参数是GameObject类型</span></span><br><span class="line">    <span class="comment">//public void RemoveEnemyList(GameObject enemy)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    enemyList.Remove(enemy);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//上述方法的lambda表达式形式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveEnemyList</span>(<span class="params">GameObject enemy</span>)</span> =&gt; enemyList.Remove(enemy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>打开之前的<strong>Enemy</strong>脚本。当敌人死亡时，调用移除链表的方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy</span> : <span class="title">LifeSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> deathEnergyBonus = <span class="number">3</span>;   <span class="comment">//敌人死亡时玩家的能量奖励</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写敌人死亡函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Die</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//当敌人死亡之前，将会给玩家增加能量</span></span><br><span class="line">        FindObjectOfType&lt;PlayerEnergy&gt;().AddEnergy(deathEnergyBonus);</span><br><span class="line">        <span class="keyword">base</span>.Die();</span><br><span class="line"><span class="comment">/***************************************************************/</span></span><br><span class="line">        <span class="comment">//通过EnmeyManger调用移除敌人链表的方法，参数传入当前脚本</span></span><br><span class="line">        EnemyManager.instance.RemoveEnemyList(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>打开之前的<strong>EnemyManager</strong>脚本，判断链表是否为空，如果为空，则生成新的敌人</p><blockquote><p>思路：</p><p>我们将Start函数改为协程，在Start协程中有一个死循环判断，每次在执行生成新敌人前，都要判断当前敌人是否为0</p><p>WaitUntil类</p><p>它会挂起等待，直到满足某个条件时才会执行后面的代码</p><p>该类初始化时需要传入一个bool类型的委托。它会一直挂起等待，直到完成对象中的委托返回为true时，才会执行后面内容</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyManager</span> : <span class="title">SingletonBase</span>&lt;<span class="title">EnemyManager</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] GameObject[] enemyPrefabs;     <span class="comment">//敌人预制体数组，不要忘记外部进行关联</span></span><br><span class="line">   </span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> enemySpawnTime = <span class="number">1</span>;    <span class="comment">//敌人生成时间</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> minEnmeyAmount = <span class="number">3</span>; <span class="comment">//最敌人数量</span></span><br><span class="line">   </span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> maxEnmeyAmount = <span class="number">9</span>;    <span class="comment">//最大敌人数量</span></span><br><span class="line">   </span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">bool</span> refreshEnemy = <span class="literal">true</span>; <span class="comment">//是否刷新敌人</span></span><br><span class="line">   </span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> enemyRefreshTime = <span class="number">2</span>;  <span class="comment">//敌人刷新时间</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> waveNumber = <span class="number">1</span>; <span class="comment">//敌人波数从1开始</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> enemyAmount;    <span class="comment">//敌人每波的数量</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    WaitForSeconds waitEnemySpawnTime;    <span class="comment">//等待敌人生成的时间</span></span><br><span class="line"></span><br><span class="line">    WaitForSeconds waitEnemyRefreshTime;    <span class="comment">//等待敌人刷新时间</span></span><br><span class="line"></span><br><span class="line">    WaitUntil waitUntilNoEnemy; <span class="comment">//声明一个挂起等待类变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个敌人列表变量</span></span><br><span class="line">    List&lt;GameObject&gt; enemyList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123; </span><br><span class="line">        <span class="keyword">base</span>.Awake();</span><br><span class="line">        <span class="comment">//在Awake中初始化</span></span><br><span class="line">        waitEnemySpawnTime = <span class="keyword">new</span> WaitForSeconds(enemySpawnTime);</span><br><span class="line">        waitEnemyRefreshTime = <span class="keyword">new</span> WaitForSeconds(enemyRefreshTime);</span><br><span class="line">        enemyList = <span class="keyword">new</span> List&lt;GameObject&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//WaitUntil的构造函数中需要传入一个bool类型的委托</span></span><br><span class="line">        waitUntilNoEnemy = <span class="keyword">new</span> WaitUntil(NoEnemy);  <span class="comment">//初始化一个WaitUntil对象</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">//waitUntilNoEnemy = new WaitUntil( () =&gt; enemyList.Count == 0); lambda表达式的匿名函数写法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">NoEnemy</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//判断链表中是否有敌人，有敌人则返回flase，没有则返回true</span></span><br><span class="line">        <span class="keyword">return</span> enemyList.Count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">Start</span>(<span class="params"></span>) <span class="comment">//将Start函数改为协程，让其在游戏开始阶段就调用协程中的所有内容</span></span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">while</span> (refreshEnemy)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当场景中有敌人时，该协程会挂起等待，不会执行后面随机生成敌人的代码</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> waitUntilNoEnemy;  <span class="comment">//直到敌人数量为0，才会执行后面的代码</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> waitEnemyRefreshTime;  <span class="comment">//每波刷新前都要等待</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果不继承MonoBehaviour，则不能启用协程</span></span><br><span class="line">            <span class="comment">//刚开始场景中没有敌人，所以启用随机生成敌人的协程</span></span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">StartCoroutine</span>(<span class="params">RandomSpawn(</span>))</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">RandomSpawn</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//限制敌人数量，并实现每3波最敌人数量就会+1</span></span><br><span class="line">        enemyAmount = Mathf.Clamp(enemyAmount, minEnmeyAmount + waveNumber / <span class="number">3</span>, maxEnmeyAmount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; enemyAmount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从敌人预制体数组中随机取一个敌人预制体对象</span></span><br><span class="line">            <span class="keyword">var</span> enemy= enemyPrefabs[Random.Range(<span class="number">0</span>, enemyPrefabs.Length)];</span><br><span class="line">            PoolManager.Instance().GetObject(enemy.name);   <span class="comment">//利用对象池创建敌人    </span></span><br><span class="line">            enemyList.Add(enemy);   <span class="comment">//将敌人添加到链表中          </span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        waveNumber++;   <span class="comment">//当前波数敌人生成完毕后，波数+1</span></span><br><span class="line">      <span class="comment">//  print(waveNumber);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清楚链表中的所有敌人对象，提供给外部调用。</span></span><br><span class="line">    <span class="comment">//public void ClearEnemyList()</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    enemyList.Clear();</span></span><br><span class="line">    <span class="comment">//    print(enemyList.Count + &quot;555555&quot;);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//上述方法的lambda表达式形式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ClearEnemyList</span>(<span class="params"></span>)</span> =&gt; enemyList.Clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>此处的EnemyManager脚本改动较大，将所有的初始化都加入到了Awake函数中</p><p>还更改了一些变量的名字让其更加规范法</p><p>所以这段代码要对比之前的代码来看</p></blockquote></li></ol><ol><li><p>打开<strong>Enmey</strong>脚本。敌人全部死亡时，清空链表</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy</span> : <span class="title">LifeSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> deathEnergyBonus = <span class="number">3</span>;   <span class="comment">//敌人死亡时玩家的能量奖励</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span> enemyDieNum; <span class="comment">//死亡的敌人数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        print(enemyDieNum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写敌人死亡函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Die</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">base</span>.Die();</span><br><span class="line">        <span class="comment">//当敌人死亡之前，将会给玩家增加能量</span></span><br><span class="line">        PlayerEnergy.instance.AddEnergy(deathEnergyBonus);</span><br><span class="line"></span><br><span class="line">        enemyDieNum++;  <span class="comment">//死亡的敌人数+1</span></span><br><span class="line">        <span class="keyword">if</span>(enemyDieNum == EnemyManager.instance.enemyAmount)    <span class="comment">//死亡的敌人数等于当前敌人数量</span></span><br><span class="line">        &#123;</span><br><span class="line">            EnemyManager.instance.ClearEnemyList();</span><br><span class="line">            enemyDieNum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>这里使用敌人死亡时从链表移除的方法，发现当前对象并不是链表中的对象，所以不能移除</p><p>故只好使用累计死亡的敌人个数，当它等于敌人数时，应该清空链表，开启下一波了</p></blockquote></li></ol><hr><h2 id="当前波数显示"><a href="#当前波数显示" class="headerlink" title="当前波数显示"></a>当前波数显示</h2><h3 id="制作波数UI"><a href="#制作波数UI" class="headerlink" title="制作波数UI"></a>制作波数UI</h3><ol><li>直接Ctrl + D  复制一个HUD能量条UI，将其命名为WaveUI</li><li>只保留Mask对象下的后景图，和一个Text对象，将它们拖动到WaveUI子对象下。其余都删掉</li><li>将图片对象重命名为<strong>Line Top</strong>，删除它关联的图片，并将<strong>锚点</strong>和<strong>位置</strong>都<strong>居中</strong>，再将它的Height设置为<strong>8</strong>，这样就能出现一条横线</li><li>Ctrl + D复制<strong>Line Top</strong>，设置PosY为140，将其命名为<strong>Line Button</strong>。这样就有两条横线</li><li>将刚才的Text对象，重命名为<strong>WaveText</strong>，也将其<strong>锚点</strong>和<strong>位置</strong>都<strong>居中</strong>，然后重载Rect Transfrom组件<ol><li>将<strong>WaveText</strong>对象的宽高设置为(512,256)，PosY设置为65，字体大设置为80</li><li>再将WaveText对象文本组件都<strong>居中对齐</strong>即可</li><li>更改文本框的内容为WAKE 01</li><li>取消它身上挂载的脚本，为其添加一个新的<strong>WaveUI</strong>脚本</li></ol></li></ol><h3 id="为波数UI添加脚本"><a href="#为波数UI添加脚本" class="headerlink" title="为波数UI添加脚本"></a>为波数UI添加脚本</h3><ol><li><p>打开WaveUI脚本</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WaveUI</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    Text waveText;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//将主摄像机赋值给世界摄像机</span></span><br><span class="line">        GetComponent&lt;Canvas&gt;().worldCamera = Camera.main;</span><br><span class="line">        waveText = GetComponentInChildren&lt;Text&gt;();</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (EnemyManager.instance.WaveNumber != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            waveText.text = <span class="string">&quot;- WAVE &quot;</span> + EnemyManager.instance.WaveNumber + <span class="string">&quot; -&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里不加条件判断会报错</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>打开之前的<strong>EnemyManager</strong>脚本</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyManager</span> : <span class="title">SingletonBase</span>&lt;<span class="title">EnemyManager</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line">    <span class="comment">//lambda表达式，返回给外部一个获取 当前波数的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> WaveNumber =&gt; waveNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回给外部一个获取 敌人刷新时间的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> EnemyRefreshTime =&gt; enemyRefreshTime;</span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] GameObject waveUI; <span class="comment">//声明waveUI对象,不要忘记外部关联waveUI对象</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>] GameObject[] enemyPrefabs;    <span class="comment">//敌人预制体数组，不要忘记外部进行关联</span></span><br><span class="line">   </span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> enemySpawnTime = <span class="number">1</span>;    <span class="comment">//敌人生成时间</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> minEnmeyAmount = <span class="number">3</span>; <span class="comment">//最敌人数量</span></span><br><span class="line">   </span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> maxEnmeyAmount = <span class="number">9</span>;    <span class="comment">//最大敌人数量</span></span><br><span class="line">   </span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">bool</span> refreshEnemy = <span class="literal">true</span>; <span class="comment">//是否刷新敌人</span></span><br><span class="line">   </span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> enemyRefreshTime = <span class="number">2</span>;  <span class="comment">//敌人刷新时间</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> waveNumber = <span class="number">1</span>; <span class="comment">//敌人波数从1开始</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> enemyAmount;    <span class="comment">//敌人每波的数量</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    WaitForSeconds waitEnemySpawnTime;    <span class="comment">//等待敌人生成的时间</span></span><br><span class="line"></span><br><span class="line">    WaitForSeconds waitEnemyRefreshTime;    <span class="comment">//等待敌人刷新时间</span></span><br><span class="line"></span><br><span class="line">    WaitUntil waitUntilNoEnemy; <span class="comment">//声明一个挂起等待类变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个敌人列表变量</span></span><br><span class="line">    List&lt;GameObject&gt; enemyList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123; </span><br><span class="line">        <span class="keyword">base</span>.Awake();</span><br><span class="line">        <span class="comment">//在Awake中初始化</span></span><br><span class="line">        waitEnemySpawnTime = <span class="keyword">new</span> WaitForSeconds(enemySpawnTime);</span><br><span class="line">        waitEnemyRefreshTime = <span class="keyword">new</span> WaitForSeconds(enemyRefreshTime);</span><br><span class="line">        enemyList = <span class="keyword">new</span> List&lt;GameObject&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//WaitUntil的构造函数中需要传入一个bool类型的委托</span></span><br><span class="line">        waitUntilNoEnemy = <span class="keyword">new</span> WaitUntil(NoEnemy);  <span class="comment">//初始化一个WaitUntil对象</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">//waitUntilNoEnemy = new WaitUntil( () =&gt; enemyList.Count == 0); lambda表达式的匿名函数写法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">NoEnemy</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//判断链表中是否有敌人，有敌人则返回flase，没有则返回true</span></span><br><span class="line">        <span class="keyword">return</span> enemyList.Count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">Start</span>(<span class="params"></span>) <span class="comment">//将Start函数改为协程，让其在游戏开始阶段就调用协程中的所有内容</span></span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">while</span> (refreshEnemy)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当场景中有敌人时，该协程会挂起等待，不会执行后面随机生成敌人的代码</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> waitUntilNoEnemy;  <span class="comment">//直到敌人数量为0，才会执行后面的代码</span></span><br><span class="line"></span><br><span class="line">            waveUI.SetActive(<span class="literal">true</span>); <span class="comment">//场景敌人数量为0时，激活波数UI对象</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> waitEnemyRefreshTime;  <span class="comment">//每波刷新前都要等待</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果不继承MonoBehaviour，则不能启用协程</span></span><br><span class="line">            <span class="comment">//刚开始场景中没有敌人，所以启用随机生成敌人的协程</span></span><br><span class="line"></span><br><span class="line">            waveUI.SetActive(<span class="literal">false</span>);<span class="comment">//开始生成敌人之前，失活波数UI对象</span></span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">StartCoroutine</span>(<span class="params">RandomSpawn(</span>))</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">RandomSpawn</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//限制敌人数量，并实现每3波最敌人数量就会+1</span></span><br><span class="line">        enemyAmount = Mathf.Clamp(enemyAmount, minEnmeyAmount + waveNumber / <span class="number">3</span>, maxEnmeyAmount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; enemyAmount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从敌人预制体数组中随机取一个敌人预制体对象</span></span><br><span class="line">            <span class="keyword">var</span> enemy= enemyPrefabs[Random.Range(<span class="number">0</span>, enemyPrefabs.Length)];</span><br><span class="line">            PoolManager.Instance().GetObject(enemy.name);   <span class="comment">//利用对象池创建敌人    </span></span><br><span class="line">            enemyList.Add(enemy);   <span class="comment">//将敌人添加到链表中          </span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        waveNumber++;   <span class="comment">//当前波数敌人生成完毕后，波数+1</span></span><br><span class="line">      <span class="comment">//  print(waveNumber);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清楚链表中的所有敌人对象，提供给外部调用。</span></span><br><span class="line">    <span class="comment">//public void ClearEnemyList()</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    enemyList.Clear();</span></span><br><span class="line">    <span class="comment">//    print(enemyList.Count + &quot;555555&quot;);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//上述方法的lambda表达式形式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ClearEnemyList</span>(<span class="params"></span>)</span> =&gt; enemyList.Clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>1、不要忘记开始时将WaveUI对象关联到EnemyManager脚本的参数中</p><p>2、开始时还要将WaveUI面板失活</p></blockquote></li></ol><hr><h3 id="制作动态波数UI"><a href="#制作动态波数UI" class="headerlink" title="制作动态波数UI"></a>制作动态波数UI</h3><blockquote><p>思路：利用动画系统的录制功能，改变位置打关键帧，让两条横线从屏幕外移动到屏幕中</p><p>让文本向上缩放</p></blockquote><ol><li>按ctrl + 6，快速打开Animator动画窗口，然后选中<strong>WaveUI</strong>对象，点击Create按钮为其创建动画</li><li>创建Animation文件夹，再从里面创建一个WaveUI文件夹，将动画组件放入其中，命名为Show</li><li>选中<strong>WaveUI</strong>对象，点击Animation窗口的录制按钮<ol><li>选中<strong>Line Button</strong>对象，将其<strong>PosX</strong>改为-1200，将<strong>LineTop</strong>对象的<strong>Poxs</strong>改为1200，将<strong>WaveText</strong>对象的<strong>Scale</strong>的<strong>Y轴</strong>改为1。此时动画组件会自动记录我们的修改，并打上关键帧</li><li>然后在60帧和120帧，也就是1s和2s的位置将它们的值设置为 0 ，0，0</li><li>最后在3s位置，将它们的值设置为1200，-1200，1即可</li></ol></li></ol><hr><h2 id="音频管理器"><a href="#音频管理器" class="headerlink" title="音频管理器"></a>音频管理器</h2><blockquote><p>思路：我们制作的音频管理器应该具备三个功能</p><p>1、设置音量</p><p>2、播放音效</p><p>3、播放音乐</p></blockquote><h3 id="创建音频管理器对象"><a href="#创建音频管理器对象" class="headerlink" title="创建音频管理器对象"></a>创建音频管理器对象</h3><ol><li>在场景中创建一个空对象，为其命名为AudioManager，再创建两个子对象为其命名为SFX Player(音效播放器) 和 Music Player(音乐播放器)</li><li><p>给SFX Player 和 Music Player 添加<strong>Audio Source</strong>组件</p><blockquote><p>注意：Unity中播放音频必须的三个条件</p><p>1、Audio Source音源组件，用于音频播放，设置音频的音量等属性</p><p>2、Audio Listener音频接收器组件，用于接收音源组件所播放出的声音，默认会创建到相机上。想要听到声音，场景中必须要有一个激活的Audio Listener组件</p><p>3、音频文件</p></blockquote></li><li><p>导入音频素材，将BGM素材关联到Music Player对象的Audio Source组件的AudioClip参数中，并勾选Loop</p></li><li>在Environment对象下，创建一个子对象，命名为Ambient Sound(环境音)，添加Audio Source组件，为它关联环境音</li><li>创建几个空对象，整理一下面板的层级关系</li></ol><h3 id="音频管理器添加脚本"><a href="#音频管理器添加脚本" class="headerlink" title="音频管理器添加脚本"></a>音频管理器添加脚本</h3><ol><li><p>新建一个<strong>AuidoManager</strong>脚本，将它挂载到AuidoManager对象上</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AudioManager</span> : <span class="title">SingletonBase</span>&lt;<span class="title">AudioManager</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//音效播放器，不要忘记外部将挂载AudioSource的对象与其进行关联</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] AudioSource sFXPlayer; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//播放音效方法</span></span><br><span class="line">    <span class="comment">//第一个参数填音源切片文件，第二个参数填音源大</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlaySFX</span>(<span class="params">AudioClip audioClip, <span class="built_in">float</span> volume</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        sFXPlayer.clip = audioClip;</span><br><span class="line">        sFXPlayer.volume = volume;</span><br><span class="line">        sFXPlayer.Play();   <span class="comment">//调用AudioSource的Playe方法播放音频</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>打开之前的<strong>Fire</strong>脚本</p><blockquote><p>在里面声明一个AudioClip类变量来保存子弹发射音效</p><p>声明一个浮点型变量，设置子弹音效的音量</p><p>调用AudioManager中的播放音效函数，然后传入刚才声明的两个参数</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Fire</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform firePos;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="built_in">float</span> fireTime = <span class="number">0.5f</span>;  <span class="comment">//子弹开火的间隔时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明一个AudioClip类变量来保存子弹发射音效，不要忘记与外部关联</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] AudioClip bulletSFX;</span><br><span class="line">    <span class="comment">//声明一个浮点型变量，设置子弹音效的音量</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> bulletSFXVolume = <span class="number">1f</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="built_in">int</span> bulletNums = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">bool</span> isStart = <span class="literal">false</span>;</span><br><span class="line">    WaitForSeconds waitForSeconds; <span class="comment">//直接将协程的值保存下来</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//在Start中初始化，这样就不会多次声明</span></span><br><span class="line">        waitForSeconds = <span class="keyword">new</span> WaitForSeconds(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        MyFire();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MyFire</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        fireTime += Time.deltaTime;   <span class="comment">//时间累加</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKey(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (fireTime &gt; <span class="number">0.1f</span> &amp;&amp; bulletNums &gt; <span class="number">0</span>) <span class="comment">//每隔0.25s可以发射一次子弹</span></span><br><span class="line">            &#123;</span><br><span class="line">                GameObject bullet = PoolManager.Instance().GetObject(<span class="string">&quot;Player Projectile&quot;</span>); <span class="comment">//从对象池中创建子弹</span></span><br><span class="line">                bullet.transform.position = firePos.position;<span class="comment">//为子弹赋值位置</span></span><br><span class="line">                fireTime = <span class="number">0</span>;</span><br><span class="line">                bulletNums--;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//子弹为0的时候，开启协程</span></span><br><span class="line">        <span class="keyword">if</span> (bulletNums == <span class="number">0</span> &amp;&amp; !isStart)</span><br><span class="line">        &#123;</span><br><span class="line">            StartCoroutine(BulletTime());</span><br><span class="line">            isStart = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两秒后补充子弹</span></span><br><span class="line">    <span class="function">IEnumerator <span class="title">BulletTime</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;       </span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> waitForSeconds;   <span class="comment">//挂起1秒再进入协程     </span></span><br><span class="line">        bulletNums = <span class="number">10</span>;</span><br><span class="line">        isStart = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>不要忘记保存脚本后，将脚本与面版上的参数进行关联</p><blockquote><p>注意：此时我们运行游戏，会发现音效一顿一顿的，即每次开火时，音效还没播放完成就会重新播放</p><p>这是因为我们在PlaySFX方法中调用了AuidoSource的Play()方法，它在播放音频时，每次都会重新播放</p><p>所以我们可以用使用<strong>PlayOneShot()</strong>方法，这个方法并<strong>不会覆盖掉正在播放中的其他声音</strong></p></blockquote></li></ol><ol><li><p>打开之前的<strong>AuidoManager</strong>脚本，修改其中PlaySFX方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AudioManager</span> : <span class="title">SingletonBase</span>&lt;<span class="title">AudioManager</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] AudioSource sFXPlayer; <span class="comment">//音效播放器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//播放音效方法</span></span><br><span class="line">    <span class="comment">//第一个参数填音源切片文件，第二个参数填音源大</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlaySFX</span>(<span class="params">AudioClip audioClip, <span class="built_in">float</span> volume</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        sFXPlayer.PlayOneShot(audioClip, volume);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>通过用代码修改AudioSource中的<strong>Pitch(音高)</strong>，来实现音效的随机化</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AudioManager</span> : <span class="title">SingletonBase</span>&lt;<span class="title">AudioManager</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] AudioSource sFXPlayer; <span class="comment">//音效播放器</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> minPith = <span class="number">0.9f</span>;   <span class="comment">//最音高</span></span><br><span class="line">     </span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> maxPith = <span class="number">1.1f</span>;  <span class="comment">//最大音高</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//播放音效方法</span></span><br><span class="line">    <span class="comment">//第一个参数填音源切片文件，第二个参数填音源大</span></span><br><span class="line">    <span class="comment">//适合播放UI音效</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlaySFX</span>(<span class="params">AudioClip audioClip, <span class="built_in">float</span> volume</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        sFXPlayer.PlayOneShot(audioClip, volume);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//适合播放子弹等连续的音效</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlayRandomSFX</span>(<span class="params">AudioClip audioClip, <span class="built_in">float</span> volume</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        sFXPlayer.pitch = Random.Range(minPith, maxPith);</span><br><span class="line">        PlaySFX(audioClip, volume);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[System.Serializable]   //加了这个特性后，类中的共有变量才会公开到Unity中</span></span><br><span class="line"><span class="comment">//public class AudioData</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    //写一个封装类，将重复定义的属性封装在其中</span></span><br><span class="line"><span class="comment">//    public AudioClip audioClip;</span></span><br><span class="line"><span class="comment">//    public float volume;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>   不要忘记修改<strong>Fire</strong>脚本中的播放音效代码</p>   <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Fire</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform firePos;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="built_in">float</span> fireTime = <span class="number">0.5f</span>;  <span class="comment">//子弹开火的间隔时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明一个AudioClip类变量来保存子弹发射音效</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] AudioClip bulletSFX;</span><br><span class="line">    <span class="comment">//声明一个浮点型变量，设置子弹音效的音量</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> bulletSFXVolume = <span class="number">1f</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="built_in">int</span> bulletNums = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">bool</span> isStart = <span class="literal">false</span>;</span><br><span class="line">    WaitForSeconds waitForSeconds; <span class="comment">//直接将协程的值保存下来</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//在Start中初始化，这样就不会多次声明</span></span><br><span class="line">        waitForSeconds = <span class="keyword">new</span> WaitForSeconds(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        MyFire();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MyFire</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        fireTime += Time.deltaTime;   <span class="comment">//时间累加</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKey(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (fireTime &gt; <span class="number">0.1f</span> &amp;&amp; bulletNums &gt; <span class="number">0</span>) <span class="comment">//每隔0.25s可以发射一次子弹</span></span><br><span class="line">            &#123;</span><br><span class="line">                GameObject bullet = PoolManager.Instance().GetObject(<span class="string">&quot;Player Projectile&quot;</span>); <span class="comment">//从对象池中创建子弹</span></span><br><span class="line">                bullet.transform.position = firePos.position;<span class="comment">//为子弹赋值位置</span></span><br><span class="line">                fireTime = <span class="number">0</span>;</span><br><span class="line">                bulletNums--;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//调用AudioManaer中PlaySFX方法，适用于播放UI音效</span></span><br><span class="line">                <span class="comment">// AudioManager.instance.PlaySFX(bulletSFX,bulletSFXVolume);</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//调用AudioManaer中PlayRandomSFX方法</span></span><br><span class="line">                AudioManager.instance.PlayRandomSFX(bulletSFX,bulletSFXVolume);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//子弹为0的时候，开启协程</span></span><br><span class="line">        <span class="keyword">if</span> (bulletNums == <span class="number">0</span> &amp;&amp; !isStart)</span><br><span class="line">        &#123;</span><br><span class="line">            StartCoroutine(BulletTime());</span><br><span class="line">            isStart = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两秒后补充子弹</span></span><br><span class="line">    <span class="function">IEnumerator <span class="title">BulletTime</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;       </span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> waitForSeconds;   <span class="comment">//挂起1秒再进入协程     </span></span><br><span class="line">        bulletNums = <span class="number">10</span>;</span><br><span class="line">        isStart = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="补全音效"><a href="#补全音效" class="headerlink" title="补全音效"></a>补全音效</h3><ol><li><p>打开之前的<strong>PlayerController</strong>类，为其添加闪避音效</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="built_in">float</span> moveSpeed;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="built_in">float</span> rotationSpeed;</span><br><span class="line">    <span class="built_in">float</span> hor, ver;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  float minX, maxX, minY, maxY;</span></span><br><span class="line">    [<span class="meta">Header(<span class="meta-string">&quot;----闪避-----&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> dodgeEnergy = <span class="number">25</span>;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> maxRoll = <span class="number">360</span>;       <span class="comment">//玩家闪避时最多旋转两圈</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> rollSpeed = <span class="number">360</span>;     <span class="comment">//每秒的翻滚速度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明一个AudioClip类变量来保存闪避音效</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] AudioClip dodgeSFX;</span><br><span class="line">    <span class="comment">//声明一个浮点型变量，设置闪避音效的音量</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> dodgeSFXVolume = <span class="number">1f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">float</span> nowRoll;  <span class="comment">//当前的旋转角度</span></span><br><span class="line">    <span class="built_in">bool</span> isDogeing = <span class="literal">false</span>; <span class="comment">//正在闪避</span></span><br><span class="line"></span><br><span class="line">    Collider2D cd2d;  <span class="comment">//获取玩家碰撞体</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        cd2d = GetComponent&lt;Collider2D&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Move();</span><br><span class="line">        Rotation();</span><br><span class="line">        Dodge();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Move</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        hor = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        ver = Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.transform.Translate(Vector3.right * moveSpeed * Time.deltaTime * hor);</span><br><span class="line">        <span class="keyword">this</span>.transform.Translate(Vector3.up * moveSpeed * Time.deltaTime * ver,Space.World);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将人物的位置限制在相机视口范围内</span></span><br><span class="line">        <span class="comment">//this.transform.position = new Vector3(Mathf.Clamp(transform.position.x, minX, maxX), </span></span><br><span class="line">        <span class="comment">//    Mathf.Clamp(transform.position.y, minY, maxY),this.transform.position.z);</span></span><br><span class="line">        <span class="keyword">this</span>.transform.position = <span class="keyword">new</span> Vector3(Mathf.Clamp(transform.position.x, View.instance.minX, View.instance.maxX),</span><br><span class="line">    Mathf.Clamp(transform.position.y, View.instance.minY, View.instance.maxY), <span class="keyword">this</span>.transform.position.z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Rotation</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetKey(KeyCode.W))</span><br><span class="line">        &#123;</span><br><span class="line">            Quaternion q = Quaternion.AngleAxis(<span class="number">45</span>,Vector3.right);</span><br><span class="line">            <span class="keyword">this</span>.transform.rotation = Quaternion.Slerp(<span class="keyword">this</span>.transform.rotation, q, Time.deltaTime * rotationSpeed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Input.GetKey(KeyCode.S))</span><br><span class="line">        &#123;</span><br><span class="line">            Quaternion q = Quaternion.AngleAxis(<span class="number">-45</span>, Vector3.right);</span><br><span class="line">            <span class="keyword">this</span>.transform.rotation = Quaternion.Slerp(<span class="keyword">this</span>.transform.rotation, q, Time.deltaTime * rotationSpeed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Quaternion q = Quaternion.AngleAxis(<span class="number">0</span>, Vector3.right);</span><br><span class="line">            <span class="keyword">this</span>.transform.rotation = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Dodge</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//如果按下回车键,则触发闪避</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.E))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//正在闪避或者能量不足时，不能进行闪避</span></span><br><span class="line">            <span class="keyword">if</span> (isDogeing || !FindObjectOfType&lt;PlayerEnergy&gt;().IsEnough(dodgeEnergy))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            StartCoroutine(PlayerDodge());  <span class="comment">//开启闪避协程</span></span><br><span class="line">            <span class="comment">//改变人物缩放值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//玩家闪避协程</span></span><br><span class="line">    <span class="function">IEnumerator <span class="title">PlayerDodge</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//播放闪避音效</span></span><br><span class="line">        AudioManager.instance.PlaySFX(dodgeSFX, dodgeSFXVolume);</span><br><span class="line"></span><br><span class="line">        isDogeing = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//触发闪避时需要消耗能量</span></span><br><span class="line">        PlayerEnergy.instance.UseEnergy(dodgeEnergy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//触发闪避时玩家无敌</span></span><br><span class="line">        <span class="comment">//这里有好几种方法，可以改变玩家图层，让子弹检测不到</span></span><br><span class="line">        <span class="comment">//还可以将玩家的IsTirgger开始，让玩家变成触发器，这样就不能与子弹碰撞</span></span><br><span class="line">        cd2d.isTrigger = <span class="literal">true</span>;    <span class="comment">//闪避开始时为true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//触发闪避时视觉上人物X轴会进行翻转</span></span><br><span class="line">        <span class="keyword">while</span> (nowRoll &lt; maxRoll)    <span class="comment">//当前旋转于最大旋转</span></span><br><span class="line">        &#123;</span><br><span class="line">            nowRoll += rollSpeed * Time.deltaTime;</span><br><span class="line">            transform.rotation = Quaternion.AngleAxis(nowRoll, Vector3.right);  <span class="comment">//利用四元数沿着X轴旋转</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nowRoll = <span class="number">0</span>;    <span class="comment">//重置当前旋转，否则改值会一直大于maxRoll，这样的话人物只能旋转一次</span></span><br><span class="line">        cd2d.isTrigger = <span class="literal">false</span>;   <span class="comment">//闪避结束后为false</span></span><br><span class="line">        isDogeing = <span class="literal">false</span>;  <span class="comment">//闪避结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>打开LiftSystem类，添加死亡音效</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LifeSystem</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">protected</span> GameObject deathVFX;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>] StatsBar hpBar;    <span class="comment">//声明一个血条</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">bool</span> showHpBar = <span class="literal">true</span>; <span class="comment">//是否显示血条</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">float</span> hp; <span class="comment">//当前血量</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">float</span> hpMax;  <span class="comment">//最大血量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明一个AudioClip类变量来保存死亡音效</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] AudioClip deathSFX;</span><br><span class="line">    <span class="comment">//声明一个浮点型变量，设置死亡音效的音量</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> deathSFXVolume = <span class="number">1f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//激活时就让当前血量等于最大血量,设置虚函数是为了方便子类重写</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnEnable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        hp = hpMax;</span><br><span class="line">        <span class="keyword">if</span> (showHpBar)  <span class="comment">//如果显示血条</span></span><br><span class="line">        &#123;</span><br><span class="line">            ShowHpBar();<span class="comment">//调用显血函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            HideHpBar();<span class="comment">//关闭时则调用隐藏函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowHpBar</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        hpBar.gameObject.SetActive(<span class="literal">true</span>);   <span class="comment">//激活血条</span></span><br><span class="line">        hpBar.Init(hp,hpMax);   <span class="comment">//血条初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HideHpBar</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        hpBar.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//受伤函数，可以传入一个浮点数用于表示伤害值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">TakeDamage</span>(<span class="params"><span class="built_in">float</span> damage</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        hp -= damage;   <span class="comment">//每次受伤时就减血</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (showHpBar &amp;&amp; gameObject.activeSelf)  <span class="comment">//如果血条显示且角色处于激活状态</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//受伤时就调用血条的更新状态条函数，传入当前血量和最大血量</span></span><br><span class="line">            hpBar.UpdateStats(hp,hpMax);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(hp &lt;= <span class="number">0</span>) <span class="comment">//如果血量为0，就调用死亡函数</span></span><br><span class="line">        &#123;</span><br><span class="line">            Die();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//死亡函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Die</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        AudioManager.instance.PlaySFX(deathSFX,deathSFXVolume);</span><br><span class="line">        hp = <span class="number">0</span>; <span class="comment">//这里将hp = 0是为了死亡时将血条清空</span></span><br><span class="line">        <span class="comment">//如果死亡，就播放死亡特效。死亡特效也是交由对象池管理</span></span><br><span class="line">        GameObject obj = PoolManager.Instance().GetObject(deathVFX.name);</span><br><span class="line">        obj.transform.position = <span class="keyword">this</span>.transform.position;</span><br><span class="line">        <span class="comment">//死亡后对象禁用，而不是销毁</span></span><br><span class="line">        gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加血函数，我们需要传入参数，表示回复量的大</span></span><br><span class="line">    <span class="comment">//当玩家捡到道具时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AddHp</span>(<span class="params"><span class="built_in">float</span> addHp</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hp != hpMax) <span class="comment">//血量不满时，才会加血</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//  hp += addHp;    这里可以用Clamp函数，简单的防止加血溢出的情况</span></span><br><span class="line">             hp = Mathf.Clamp(hp + addHp, <span class="number">0</span>, hpMax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (showHpBar)  <span class="comment">//如果血条显示</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//加血时就调用血条的更新状态条函数，传入当前血量和最大血量</span></span><br><span class="line">            hpBar.UpdateStats(hp, hpMax);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用协程来实现缓慢回血效果，我们可以传入挂起时间，表示多久回一次血</span></span><br><span class="line">    <span class="comment">//还可以传入一个浮点数，表示回血百分比</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> IEnumerator <span class="title">RestoreHp</span>(<span class="params">WaitForSeconds waitTime, <span class="built_in">float</span> percent</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">while</span>(hp &lt; hpMax)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> waitTime;</span><br><span class="line">            AddHp(hpMax * percent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用协程来实现中毒效果，我们可以传入挂起时间，表示多久回一次血</span></span><br><span class="line">    <span class="comment">//还可以传入一个浮点数，表示回血百分比</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> IEnumerator <span class="title">DamageTimeHp</span>(<span class="params">WaitForSeconds waitTime, <span class="built_in">float</span> percent</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">while</span> (hp &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> waitTime;</span><br><span class="line">            TakeDamage(hpMax * percent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>打开之前的<strong>Projectile</strong>脚本，子弹命中时，播放命中音效</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Projectile</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">protected</span> GameObject bulletHitVFX; <span class="comment">//子弹击中特效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> GameObject hitVFX;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">protected</span> <span class="built_in">float</span> damage;   <span class="comment">//子弹伤害</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">protected</span> <span class="built_in">float</span> moveSpeed = <span class="number">10</span>;   <span class="comment">//子弹移动速度</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">protected</span> Vector2 moveDirection;  <span class="comment">//子弹移动方向</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明一个AudioClip类变量子弹命中音效</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] AudioClip bulletSFX;</span><br><span class="line">    <span class="comment">//声明一个浮点型变量，设置子弹命中的音量</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> bulletSFXVolume = <span class="number">1f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">       EnemyMove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span>  <span class="title">EnemyMove</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.transform.Translate(moveDirection * moveSpeed * Time.deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnCollisionEnter2D</span>(<span class="params">Collision2D collision</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//判断是否碰撞到了挂载生命系统的对象。</span></span><br><span class="line">        <span class="comment">//TryGetComponent&lt;&gt;()，该函数返回的是一个bool值，若成功则返回T,否则返回F</span></span><br><span class="line">        <span class="keyword">if</span> (collision.gameObject.TryGetComponent&lt;LifeSystem&gt;(<span class="keyword">out</span> LifeSystem ls))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//播放子弹击中音效</span></span><br><span class="line">            AudioManager.instance.PlaySFX(bulletSFX,bulletSFXVolume);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//子弹碰撞到挂载生命系统的对象，则调用受伤函数</span></span><br><span class="line">            ls.TakeDamage(damage);</span><br><span class="line">            <span class="comment">//创建命中特效，传入特效名，交给对象池管理</span></span><br><span class="line">            hitVFX = PoolManager.Instance().GetObject(bulletHitVFX.name);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过collosion.GetContact()函数获取两个对象碰撞的接触点</span></span><br><span class="line">            <span class="keyword">var</span> contactPoint = collision.GetContact(<span class="number">0</span>); <span class="comment">//0表示取第一个接触点</span></span><br><span class="line">          </span><br><span class="line">            hitVFX.transform.position = contactPoint.point; <span class="comment">//创建特效的位置</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//子弹造成伤害后，将子弹禁用，存入对象池中</span></span><br><span class="line">            PoolManager.Instance().SaveObject(<span class="keyword">this</span>.gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="子弹系统"><a href="#子弹系统" class="headerlink" title="子弹系统"></a>子弹系统</h2><h3 id="创建子弹条"><a href="#创建子弹条" class="headerlink" title="创建子弹条"></a><strong>创建子弹条</strong></h3><ol><li>选中UI_HP_HUD,然后Ctrl + D，复制一份能量条，为其命名为UI_Bullet_HUD</li><li>更改Text文本中的名称，以及内容，还有颜色</li><li>在Mask文件夹下更改能量条的前景色与中景色</li><li>移除UI_Bullet_HUD对象上的StatsBar_HUD脚本，为其新建一个<strong>BulletBar</strong>脚本，继承于<strong>EnergyBar_HUD</strong></li><li><p>为<strong>BulletBar</strong>脚本的参数进行对象关联</p><h3 id="为子弹条添加脚本"><a href="#为子弹条添加脚本" class="headerlink" title="为子弹条添加脚本"></a>为子弹条添加脚本</h3></li><li><p>新建一个<strong>PlayerBullet</strong>脚本，不要忘记挂载到玩家上</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerBullet</span> : <span class="title">SingletonBase</span>&lt;<span class="title">PlayerBullet</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//声明一个子弹条类变量</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] BulletBar bulletBar;   </span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> maxBulletNums = <span class="number">10</span>;    <span class="comment">//最大子弹数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> nowBulletNums = <span class="number">10</span>;     <span class="comment">//当前子弹数</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> RestoryBulletTime = <span class="number">1</span>;   <span class="comment">//补充子弹时间</span></span><br><span class="line"></span><br><span class="line">    WaitForSeconds waitTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//初始化子弹条</span></span><br><span class="line">        bulletBar.Init(nowBulletNums, maxBulletNums);</span><br><span class="line">        waitTime = <span class="keyword">new</span> WaitForSeconds(RestoryBulletTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消耗子弹的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FireBullet</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        print(nowBulletNums);</span><br><span class="line">        <span class="keyword">if</span>(nowBulletNums &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nowBulletNums--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新能量条</span></span><br><span class="line">        bulletBar.UpdateStats(nowBulletNums, maxBulletNums);</span><br><span class="line">        StartCoroutine(RestoryBullet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复子弹的协程</span></span><br><span class="line">    <span class="function">IEnumerator <span class="title">RestoryBullet</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">while</span>(nowBulletNums &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> waitTime;</span><br><span class="line">            nowBulletNums = maxBulletNums;</span><br><span class="line">            bulletBar.UpdateStats(nowBulletNums, maxBulletNums);</span><br><span class="line">            print(nowBulletNums + <span class="string">&quot;9999&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>打开之前的<strong>Fire</strong>脚本</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Fire</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform firePos;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="built_in">float</span> fireTime = <span class="number">0.5f</span>;  <span class="comment">//子弹开火的间隔时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明一个AudioClip类变量来保存子弹发射音效</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] AudioClip bulletSFX;</span><br><span class="line">    <span class="comment">//声明一个浮点型变量，设置子弹音效的音量</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> bulletSFXVolume = <span class="number">1f</span>;</span><br><span class="line"></span><br><span class="line">    WaitForSeconds waitForSeconds; <span class="comment">//直接将协程的值保存下来</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//在Start中初始化，这样就不会多次声明</span></span><br><span class="line">        waitForSeconds = <span class="keyword">new</span> WaitForSeconds(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        MyFire();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MyFire</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        fireTime += Time.deltaTime;   <span class="comment">//时间累加</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKey(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//每隔0.1s可以发射一次子弹,且子弹数大于0</span></span><br><span class="line">            <span class="keyword">if</span> (fireTime &gt; <span class="number">0.1f</span> &amp;&amp; PlayerBullet.instance.nowBulletNums &gt; <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                print(PlayerBullet.instance.nowBulletNums + <span class="string">&quot;  8888&quot;</span>);</span><br><span class="line">                PlayerBullet.instance.FireBullet();    <span class="comment">//消耗子弹</span></span><br><span class="line">                GameObject bullet = PoolManager.Instance().GetObject(<span class="string">&quot;Player Projectile&quot;</span>); <span class="comment">//从对象池中创建子弹</span></span><br><span class="line">                bullet.transform.position = firePos.position;<span class="comment">//为子弹赋值位置</span></span><br><span class="line">                fireTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//调用AudioManaer中PlayRandomSFX方法</span></span><br><span class="line">                AudioManager.instance.PlayRandomSFX(bulletSFX,bulletSFXVolume);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>打开<strong>EnemyManager</strong>脚本，当关卡数增加的时候，子弹数也增加</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyManager</span> : <span class="title">SingletonBase</span>&lt;<span class="title">EnemyManager</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//lambda表达式，返回给外部一个获取 当前波数的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> WaveNumber =&gt; waveNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回给外部一个获取 敌人刷新时间的方法</span></span><br><span class="line">    <span class="comment">//public float EnemyRefreshTime =&gt; enemyRefreshTime;</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>] GameObject waveUI; <span class="comment">//声明waveUI对象</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>] GameObject[] enemyPrefabs;     <span class="comment">//敌人预制体数组，不要忘记外部进行关联</span></span><br><span class="line">   </span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> enemySpawnTime = <span class="number">1</span>;    <span class="comment">//敌人生成时间</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> minEnmeyAmount = <span class="number">3</span>; <span class="comment">//最敌人数量</span></span><br><span class="line">   </span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> maxEnmeyAmount = <span class="number">9</span>;    <span class="comment">//最大敌人数量</span></span><br><span class="line">   </span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">bool</span> refreshEnemy = <span class="literal">true</span>; <span class="comment">//是否刷新敌人</span></span><br><span class="line">   </span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> enemyRefreshTime = <span class="number">2</span>;  <span class="comment">//敌人刷新时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> waveNumber = <span class="number">1</span>; <span class="comment">//敌人波数从1开始</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> enemyAmount;    <span class="comment">//敌人每波的数量</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    WaitForSeconds waitEnemySpawnTime;    <span class="comment">//等待敌人生成的时间</span></span><br><span class="line"></span><br><span class="line">    WaitForSeconds waitEnemyRefreshTime;    <span class="comment">//等待敌人刷新时间</span></span><br><span class="line"></span><br><span class="line">    WaitUntil waitUntilNoEnemy; <span class="comment">//声明一个挂起等待类变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个敌人列表变量</span></span><br><span class="line">    List&lt;GameObject&gt; enemyList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123; </span><br><span class="line">        <span class="keyword">base</span>.Awake();</span><br><span class="line">        <span class="comment">//在Awake中初始化</span></span><br><span class="line">        waitEnemySpawnTime = <span class="keyword">new</span> WaitForSeconds(enemySpawnTime);</span><br><span class="line">        waitEnemyRefreshTime = <span class="keyword">new</span> WaitForSeconds(enemyRefreshTime);</span><br><span class="line">        enemyList = <span class="keyword">new</span> List&lt;GameObject&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//WaitUntil的构造函数中需要传入一个bool类型的委托</span></span><br><span class="line">        waitUntilNoEnemy = <span class="keyword">new</span> WaitUntil(NoEnemy);  <span class="comment">//初始化一个WaitUntil对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//waitUntilNoEnemy = new WaitUntil( () =&gt; enemyList.Count == 0); lambda表达式的匿名函数写法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">NoEnemy</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//判断链表中是否有敌人，有敌人则返回flase，没有则返回true</span></span><br><span class="line">        <span class="keyword">return</span> enemyList.Count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">Start</span>(<span class="params"></span>) <span class="comment">//将Start函数改为协程，让其在游戏开始阶段就调用协程中的所有内容</span></span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">while</span> (refreshEnemy)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当场景中有敌人时，该协程会挂起等待，不会执行后面随机生成敌人的代码</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> waitUntilNoEnemy;  <span class="comment">//直到敌人数量为0，才会执行后面的代码</span></span><br><span class="line"></span><br><span class="line">            waveUI.SetActive(<span class="literal">true</span>); <span class="comment">//场景敌人数量为0时，激活波数UI对象</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> waitEnemyRefreshTime;  <span class="comment">//每波刷新前都要等待</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果不继承MonoBehaviour，则不能启用协程</span></span><br><span class="line">            <span class="comment">//刚开始场景中没有敌人，所以启用随机生成敌人的协程</span></span><br><span class="line"></span><br><span class="line">            waveUI.SetActive(<span class="literal">false</span>);<span class="comment">//开始生成敌人之前，失活波数UI对象</span></span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">StartCoroutine</span>(<span class="params">RandomSpawn(</span>))</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">RandomSpawn</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//限制敌人数量，并实现每3波最敌人数量就会+1</span></span><br><span class="line">        enemyAmount = Mathf.Clamp(enemyAmount, minEnmeyAmount + waveNumber / <span class="number">3</span>, maxEnmeyAmount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; enemyAmount; i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="comment">//从敌人预制体数组中随机取一个敌人预制体对象</span></span><br><span class="line">            <span class="keyword">var</span> enemy= enemyPrefabs[Random.Range(<span class="number">0</span>, enemyPrefabs.Length)];</span><br><span class="line">            PoolManager.Instance().GetObject(enemy.name);   <span class="comment">//利用对象池创建敌人    </span></span><br><span class="line">            enemyList.Add(enemy);   <span class="comment">//将敌人添加到链表中          </span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        waveNumber++;   <span class="comment">//当前波数敌人生成完毕后，波数+1</span></span><br><span class="line"> /------------------------------------------------------------------------/    </span><br><span class="line">        PlayerBullet.instance.maxBulletNums ++;  <span class="comment">//子弹随着波数增加</span></span><br><span class="line">        print(<span class="string">&quot;最大子弹&quot;</span> + PlayerBullet.instance.maxBulletNums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  print(waveNumber);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清楚链表中的所有敌人对象，提供给外部调用。</span></span><br><span class="line">    <span class="comment">//public void ClearEnemyList()</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    enemyList.Clear();</span></span><br><span class="line">    <span class="comment">//    print(enemyList.Count + &quot;555555&quot;);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//上述方法的lambda表达式形式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ClearEnemyList</span>(<span class="params"></span>)</span> =&gt; enemyList.Clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="场景加载器"><a href="#场景加载器" class="headerlink" title="场景加载器"></a>场景加载器</h2><h3 id="制作开始界面"><a href="#制作开始界面" class="headerlink" title="制作开始界面"></a>制作开始界面</h3><ol><li>Ctrl + D 复制一个新的场景，为其命名为<strong>MainMenu</strong>(主菜单)</li><li>只保留场景中的主相机、环境、以及音频管理器，其他对象全部删除</li><li>创建一个Button，为其命名为Start Game<ol><li>选中<strong>Button</strong>，点击其<strong>锚点设置键</strong>，同时按住<strong>shift + alt</strong> 再点击中心位置，这样可以同时将button的<strong>中心点</strong>和<strong>位置</strong>设置在画布正中央</li><li>更改Button中的文本信息，改变其文本大、文本字体等</li></ol></li><li>点击<strong>File/Bulid Setting</strong> 再将场景拖动到窗口中，只有窗口中的场景才能加载到游戏中</li></ol><h3 id="创建场景加载器"><a href="#创建场景加载器" class="headerlink" title="创建场景加载器"></a>创建场景加载器</h3><blockquote><p>思路：</p><p>通过场景加载器来控制场景的切换</p></blockquote><ol><li>在场景中创建一个空对象，为其命名为<strong>Scene Loader</strong></li><li><p>为该对象新建一个<strong>SceneLoader</strong>脚本，不要忘记挂载到对象上</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.SceneManagement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SceneLoader</span> : <span class="title">SingletonBase</span>&lt;<span class="title">SceneLoader</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 场景加载函数，参数是需要传入场景的字符串名</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Load</span>(<span class="params"><span class="built_in">string</span> sceneName</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//通过场景名来加载场景</span></span><br><span class="line">        SceneManager.LoadScene(sceneName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载游戏场景函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadGamePlay</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Load(<span class="string">&quot;Gameplay&quot;</span>);<span class="comment">//调用Load函数，加载GamePlay场景   </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>为Button添加监听事件(利用<strong>面板关联脚本</strong>的方式添加监听)</p><ol><li>选中Button按钮，点击<strong>On Click()</strong>旁边的<strong>加号</strong></li><li>将Scene Loader对象拖拽到面板的None中，用于关联对象</li><li>选择它身上的C#脚本，再选择对应的脚本的<strong>公开</strong>监听函数即刻</li></ol><blockquote><p>注意：</p><p>这里也可以用代码的形式添加Button监听事件</p><p>不过需要新建一个C#脚本，挂载到Button上</p><p>然后再从脚本中写逻辑</p></blockquote></li></ol><h3 id="场景切换时淡入淡出"><a href="#场景切换时淡入淡出" class="headerlink" title="场景切换时淡入淡出"></a>场景切换时淡入淡出</h3><blockquote><p>思路：</p><p>创建一个Image挡住整个游戏画面</p><p>然后通过代码修改Image的透明度</p></blockquote><ol><li>给SceneLoader对象创建一个Image子对象</li><li>修改Image的宽高，使其铺满整个画布</li><li><p>打开之前的<strong>SceneLoader</strong>脚本，为其添加淡入淡出效果</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.SceneManagement;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SceneLoader</span> : <span class="title">SingletonBase</span>&lt;<span class="title">SceneLoader</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] Image transitionImage; <span class="comment">//转场图片</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> fadeSpeed = <span class="number">2f</span>;</span><br><span class="line"></span><br><span class="line">    Color fadeColor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 场景加载函数，参数是需要传入场景的字符串名</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Load</span>(<span class="params"><span class="built_in">string</span> sceneName</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//通过场景名来加载场景</span></span><br><span class="line">        SceneManager.LoadScene(sceneName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function">IEnumerator <span class="title">fade</span>(<span class="params"><span class="built_in">string</span> sceneName</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    <span class="comment">//画面淡入</span></span><br><span class="line">        <span class="comment">//不能让其一直开启，否则会消耗性能</span></span><br><span class="line">        transitionImage.gameObject.SetActive(<span class="literal">true</span>); <span class="comment">//激活转场图片</span></span><br><span class="line">        <span class="comment">//当该图片的透明度于1时</span></span><br><span class="line">        <span class="keyword">while</span>(fadeColor.a &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Mathf.Clamp01将浮点数限制在0~1之间</span></span><br><span class="line">            fadeColor.a = Mathf.Clamp01(fadeColor.a + Time.deltaTime * fadeSpeed);</span><br><span class="line"></span><br><span class="line">            transitionImage.color = fadeColor;  <span class="comment">//不断更改图片的透明度</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Load(sceneName);    <span class="comment">//淡出后加载场景</span></span><br><span class="line">    <span class="comment">//画面淡入</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fadeColor.a &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fadeColor.a = Mathf.Clamp01(fadeColor.a - Time.deltaTime * fadeSpeed);</span><br><span class="line"></span><br><span class="line">            transitionImage.color = fadeColor;  <span class="comment">//不断更改图片的透明度</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        transitionImage.gameObject.SetActive(<span class="literal">false</span>);    <span class="comment">//淡入后禁用转场图片</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载游戏场景函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadGamePlay</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//开启协程</span></span><br><span class="line">        StartCoroutine(fade(<span class="string">&quot;Gameplay&quot;</span>));   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>这里切换场景时有时会卡一下，这是由于同步加载引起的</p><p>所以可以使用场景异步加载的方式实现切换</p></blockquote></li></ol><ol><li><p>异步切换场景</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.SceneManagement;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SceneLoader</span> : <span class="title">SingletonBase</span>&lt;<span class="title">SceneLoader</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] Image transitionImage; <span class="comment">//转场图片</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> fadeSpeed = <span class="number">2f</span>;</span><br><span class="line"></span><br><span class="line">    Color fadeColor;</span><br><span class="line"></span><br><span class="line">   <span class="function">IEnumerator <span class="title">fade</span>(<span class="params"><span class="built_in">string</span> sceneName</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    <span class="comment">//画面淡入</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> loadAsync = SceneManager.LoadSceneAsync(sceneName);<span class="comment">//异步加载场景</span></span><br><span class="line">        <span class="comment">//allowSceneActivation属性用于设置加载好的场景是否为激活状态</span></span><br><span class="line">        loadAsync.allowSceneActivation = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不能让其一直开启，否则会消耗性能</span></span><br><span class="line">        transitionImage.gameObject.SetActive(<span class="literal">true</span>); <span class="comment">//激活转场图片</span></span><br><span class="line">        <span class="comment">//当该图片的透明度于1时</span></span><br><span class="line">        <span class="keyword">while</span>(fadeColor.a &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Mathf.Clamp01将浮点数限制在0~1之间</span></span><br><span class="line">            fadeColor.a = Mathf.Clamp01(fadeColor.a + Time.deltaTime * fadeSpeed);</span><br><span class="line"></span><br><span class="line">            transitionImage.color = fadeColor;  <span class="comment">//不断更改图片的透明度</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        loadAsync.allowSceneActivation = <span class="literal">true</span>;  <span class="comment">//淡出完成后设置激活的场景为true</span></span><br><span class="line">    <span class="comment">//画面淡入</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fadeColor.a &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fadeColor.a = Mathf.Clamp01(fadeColor.a - Time.deltaTime * fadeSpeed);</span><br><span class="line"></span><br><span class="line">            transitionImage.color = fadeColor;  <span class="comment">//不断更改图片的透明度</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        transitionImage.gameObject.SetActive(<span class="literal">false</span>);    <span class="comment">//淡入后禁用转场图片</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载游戏场景函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadGamePlay</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//开启协程</span></span><br><span class="line">        StartCoroutine(fade(<span class="string">&quot;Gameplay&quot;</span>));   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>loadAsync.allowSceneActivation = false; 这里先将加载好的场景失活，等到需要切换场景时，再设置它为true即可激活</p></blockquote></li></ol><hr><h2 id="得分系统"><a href="#得分系统" class="headerlink" title="得分系统"></a>得分系统</h2><h3 id="制作分数UI"><a href="#制作分数UI" class="headerlink" title="制作分数UI"></a>制作分数UI</h3><ol><li>Ctrl + D之前的HUD对象，将其重命名为UI_Score</li><li>分数UI不需要图片对象，所以<strong>删除Mask</strong>对象，<strong>只保留两个Text文本</strong>用来显示文本和分数。之前挂载的脚本也一并移除</li><li>一个Text命名为Score Text，用于显示分数。一个Text 命名为Title Text，用于显示内容</li><li>将两个Text设置到合适的位置，并设置其<strong>锚点</strong>到右上角，确保屏幕缩放时保证分辨率自适应</li></ol><h3 id="分数显示脚本"><a href="#分数显示脚本" class="headerlink" title="分数显示脚本"></a>分数显示脚本</h3><ol><li><p>创建一个新脚本，命名为<strong>ScoreDisplay</strong>，不要忘记将其挂载到ScoreText对象上</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ScoreDisplay</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置静态，方便其他类中调用，适用于只有一个实例的情况</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Text scoreText;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//获取文本组件</span></span><br><span class="line">        scoreText = GetComponent&lt;Text&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新文本的方法，参数传入玩家的得分</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UpdateText</span>(<span class="params"><span class="built_in">int</span> score</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//将玩家得分转换为字符串，再传入文本框中</span></span><br><span class="line">        scoreText.text = score.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>创建一个空对象，命名为ScoreManager，为其新建一个<strong>ScoreManager</strong>脚本挂载到它身上</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ScoreManager</span> : <span class="title">SingletonBase</span>&lt;<span class="title">ScoreManager</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> nowScore;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置分数的方法，每次游戏开始时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ResetScore</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        score = <span class="number">0</span>;  <span class="comment">//分数设置为0</span></span><br><span class="line">        nowScore = <span class="number">0</span>;   <span class="comment">//当前分数也为0</span></span><br><span class="line">        ScoreDisplay.UpdateText(score); <span class="comment">//更新UI分数文本</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得分的方法，击败敌人或拾取道具时调用，参数传入所得的分数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddScore</span>(<span class="params"><span class="built_in">int</span> _score</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        nowScore += _score;    <span class="comment">//加分</span></span><br><span class="line">        StartCoroutine(AddScoreCoroutine());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用协程动态增加分数，分数增加时开启协程</span></span><br><span class="line">    <span class="function">IEnumerator <span class="title">AddScoreCoroutine</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">while</span>(score &lt; nowScore)</span><br><span class="line">        &#123;</span><br><span class="line">            score++;</span><br><span class="line">            ScoreDisplay.UpdateText(score);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>打开之前的<strong>ScoreDisplay</strong>脚本，当游戏开始时，调用重置分数的方法，将分数初始化</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ScoreDisplay</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置静态，方便其他类中调用，适用于只有一个实例的情况</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Text scoreText;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//获取文本组件</span></span><br><span class="line">        scoreText = GetComponent&lt;Text&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用重置分数方法</span></span><br><span class="line">        ScoreManager.instance.ResetScore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新文本的方法，参数传入玩家的得分</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UpdateText</span>(<span class="params"><span class="built_in">int</span> score</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//将玩家得分转换为字符串，再传入文本框中</span></span><br><span class="line">        scoreText.text = score.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>打开之前的<strong>Enemy</strong>脚本，当<strong>敌人死亡</strong>时，调用<strong>加分</strong>的方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy</span> : <span class="title">LifeSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> score = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> deathEnergyBonus = <span class="number">3</span>;   <span class="comment">//敌人死亡时玩家的能量奖励</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span> enemyDieNum; <span class="comment">//敌人死亡次数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写敌人死亡函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Die</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">base</span>.Die();</span><br><span class="line">        <span class="comment">//当敌人死亡之前，将会给玩家增加能量</span></span><br><span class="line">        PlayerEnergy.instance.AddEnergy(deathEnergyBonus);</span><br><span class="line"></span><br><span class="line">        enemyDieNum++;  <span class="comment">//敌人死亡次数+1</span></span><br><span class="line">        <span class="keyword">if</span>(enemyDieNum == EnemyManager.instance.enemyAmount)    <span class="comment">//敌人死亡次数等于当前敌人数量</span></span><br><span class="line">        &#123;</span><br><span class="line">            EnemyManager.instance.ClearEnemyList();</span><br><span class="line">            enemyDieNum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//敌人死亡后玩家加分</span></span><br><span class="line">        ScoreManager.instance.AddScore(score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="使用曝气"><a href="#使用曝气" class="headerlink" title="使用曝气"></a>使用曝气</h2><ol><li><p>新建一个PlayerSkill脚本，不要忘记将它挂载到游戏对象上</p><blockquote><p>我们将在这个脚本中实现曝气时的属性提升，以及粒子特效播放</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerSkill</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] GameObject triggerVFX;</span><br><span class="line">    [<span class="meta">SerializeField</span>] GameObject engineVFXNormal;</span><br><span class="line">    [<span class="meta">SerializeField</span>] GameObject engineVFXSkill;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>] AudioClip onSFX;</span><br><span class="line">    [<span class="meta">SerializeField</span>] AudioClip offSFX;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="meta-string">&quot;----技能-----&quot;</span>)</span>]</span><br><span class="line">    <span class="built_in">bool</span> isSkill;   <span class="comment">//判断技能是否正在开启</span></span><br><span class="line">    <span class="comment">//这里的三个参数都是提升系数</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> skillMoveSpeed;   <span class="comment">//曝气后的速度</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> skillDamage;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> skillBulletSpeed;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> skillPlayerBulletNums;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Skill();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//曝气方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Skill</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//当能量已满时，可以释放曝气</span></span><br><span class="line">        <span class="keyword">if</span> (PlayerEnergy.instance.IsEnough(PlayerEnergy.MAX_ENERGY))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Tab))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//曝气开启</span></span><br><span class="line">                SkillOn();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (PlayerEnergy.instance.energy == <span class="number">0</span> &amp;&amp; isSkill)</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">            SkillOff();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//曝气开启</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SkillOn</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//视觉特效</span></span><br><span class="line">        triggerVFX.SetActive(<span class="literal">true</span>);</span><br><span class="line">        engineVFXNormal.SetActive(<span class="literal">false</span>);</span><br><span class="line">        engineVFXSkill.SetActive(<span class="literal">true</span>);</span><br><span class="line">        AudioManager.instance.PlayRandomSFX(onSFX, <span class="number">0.4f</span>);</span><br><span class="line"></span><br><span class="line">        isSkill = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//属性提升</span></span><br><span class="line">        FindObjectOfType&lt;PlayerController&gt;().moveSpeed *= skillMoveSpeed;</span><br><span class="line">      <span class="comment">//  FindObjectOfType&lt;PlayerProjectile&gt;().damage *= skillDamage;</span></span><br><span class="line">     <span class="comment">//   FindObjectOfType&lt;Projectile&gt;().moveSpeed *= skillBulletSpeed;</span></span><br><span class="line">        FindObjectOfType&lt;PlayerBullet&gt;().nowBulletNums *= skillPlayerBulletNums;</span><br><span class="line"></span><br><span class="line">        PlayerEnergy.instance.PlayerSkillOn();  <span class="comment">//调用开启能量消耗协程的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//曝气结束</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SkillOff</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//关闭视觉特效</span></span><br><span class="line">        triggerVFX.SetActive(<span class="literal">false</span>);</span><br><span class="line">        engineVFXNormal.SetActive(<span class="literal">true</span>);</span><br><span class="line">        engineVFXSkill.SetActive(<span class="literal">false</span>);</span><br><span class="line">        AudioManager.instance.PlayRandomSFX(offSFX, <span class="number">0.4f</span>);</span><br><span class="line"></span><br><span class="line">        isSkill = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//属性还原</span></span><br><span class="line">        FindObjectOfType&lt;PlayerController&gt;().moveSpeed /= skillMoveSpeed;</span><br><span class="line">        print(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">      <span class="comment">//  FindObjectOfType&lt;PlayerProjectile&gt;().damage /= skillDamage;</span></span><br><span class="line">     <span class="comment">//   FindObjectOfType&lt;PlayerProjectile&gt;().moveSpeed /= skillBulletSpeed;</span></span><br><span class="line">        FindObjectOfType&lt;PlayerBullet&gt;().nowBulletNums /= skillPlayerBulletNums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>打开之前的<strong>PlayerEnergy</strong>脚本，我们将在这里写曝气时消耗能量的协程</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerSkill</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] GameObject triggerVFX;</span><br><span class="line">    [<span class="meta">SerializeField</span>] GameObject engineVFXNormal;</span><br><span class="line">    [<span class="meta">SerializeField</span>] GameObject engineVFXSkill;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>] AudioClip onSFX;</span><br><span class="line">    [<span class="meta">SerializeField</span>] AudioClip offSFX;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="meta-string">&quot;----技能-----&quot;</span>)</span>]</span><br><span class="line">    <span class="built_in">bool</span> isSkill;   <span class="comment">//判断技能是否正在开启</span></span><br><span class="line">    <span class="comment">//这里的三个参数都是提升系数</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> skillMoveSpeed;   <span class="comment">//曝气后的速度</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> skillDamage;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> skillBulletSpeed;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> skillPlayerBulletNums;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Skill();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//曝气方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Skill</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//当能量已满时，可以释放曝气</span></span><br><span class="line">        <span class="keyword">if</span> (PlayerEnergy.instance.IsEnough(PlayerEnergy.MAX_ENERGY))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Tab))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//曝气开启</span></span><br><span class="line">                SkillOn();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (PlayerEnergy.instance.energy == <span class="number">0</span> &amp;&amp; isSkill)</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">            SkillOff();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//曝气开启</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SkillOn</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//视觉特效</span></span><br><span class="line">        triggerVFX.SetActive(<span class="literal">true</span>);<span class="comment">//曝气特效</span></span><br><span class="line">        engineVFXNormal.SetActive(<span class="literal">false</span>);<span class="comment">//关闭蓝色喷气</span></span><br><span class="line">        engineVFXSkill.SetActive(<span class="literal">true</span>);<span class="comment">//开启红色喷气</span></span><br><span class="line">        AudioManager.instance.PlayRandomSFX(onSFX, <span class="number">0.4f</span>);</span><br><span class="line"></span><br><span class="line">        isSkill = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//属性提升</span></span><br><span class="line">        FindObjectOfType&lt;PlayerController&gt;().moveSpeed *= skillMoveSpeed;</span><br><span class="line">        FindObjectOfType&lt;PlayerProjectile&gt;().damage *= skillDamage;</span><br><span class="line">        FindObjectOfType&lt;PlayerProjectile&gt;().moveSpeed *= skillBulletSpeed;</span><br><span class="line">        FindObjectOfType&lt;PlayerBullet&gt;().nowBulletNums *= skillPlayerBulletNums;</span><br><span class="line"></span><br><span class="line">        PlayerEnergy.instance.PlayerSkillOn();  <span class="comment">//调用开启能量消耗协程的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//曝气结束</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SkillOff</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//关闭视觉特效</span></span><br><span class="line">        triggerVFX.SetActive(<span class="literal">false</span>);</span><br><span class="line">        engineVFXNormal.SetActive(<span class="literal">true</span>);</span><br><span class="line">        engineVFXSkill.SetActive(<span class="literal">false</span>);</span><br><span class="line">        AudioManager.instance.PlayRandomSFX(offSFX, <span class="number">0.4f</span>);</span><br><span class="line"></span><br><span class="line">        isSkill = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//属性还原</span></span><br><span class="line">        FindObjectOfType&lt;PlayerController&gt;().moveSpeed /= skillMoveSpeed;</span><br><span class="line">        FindObjectOfType&lt;PlayerProjectile&gt;().damage /= skillDamage;</span><br><span class="line">        FindObjectOfType&lt;PlayerProjectile&gt;().moveSpeed /= skillBulletSpeed;</span><br><span class="line">        FindObjectOfType&lt;PlayerBullet&gt;().nowBulletNums /= skillPlayerBulletNums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>FindObjectOfType&lt;&gt;()这个方法只能找到场景中已经激活的对象，不能找还未创建或失活的对象</p><p>所以这里我们需要创建一个子弹对象，取消它的速度，让它一直在场景中，这样就不会出现曝气时没有子弹对象而报错的情况</p></blockquote></li></ol><ol><li>导入粒子特效和音频素材，将它们关联到Player的面板上</li></ol><h2 id="释放技能"><a href="#释放技能" class="headerlink" title="释放技能"></a>释放技能</h2><p>   这里是曝气的第二阶段，除了人物的属性提升之外，还增加一段会跟踪的子弹</p><h3 id="制作曝气时的子弹"><a href="#制作曝气时的子弹" class="headerlink" title="制作曝气时的子弹"></a>制作曝气时的子弹</h3><blockquote><p>我们需要将曝气时的子弹变为红色，所以要更改子弹的材质</p></blockquote><ol><li>复制一个玩家子弹，将其重命名为<strong>PlayerBulletSkill</strong><ol><li>选中它的子对象<strong>Particle</strong>，点开<strong>Particle System</strong>(粒子系统)，找到Renderer渲染组件。点击它身上的<strong>Material</strong>就能找到Particle对象上挂载的材质了</li><li>复制一份我们找到的玩家子弹材质，为其重命名为<strong>M_PlayerBulletSkill</strong>。然后只需要将新子弹材质的Emission改为红色，发光强度设置为5</li><li>最后将<strong>新材质</strong>拖拽到粒子系统中的Renderer渲染组件的Material参数即可</li></ol></li><li><p><strong>子弹轨迹</strong>颜色也是如此，选中玩家子弹下的Trail对象，点击它身上的材质</p><ol><li>我们复制子弹的尾迹材质，重命名为WEIJI_Player_Projectile_Skill，更改它的发光颜色为红色</li><li>将新的材质拖拽到尾<strong>Trail</strong>对象的Material参数中即可</li></ol></li><li><p>在Resources文件夹中找到VFX_PlayerProjectileHit<strong>玩家子弹爆炸特效对象</strong>，复制一份，为其命名为VFX_PlayerProjectileHitSkill</p><ol><li>然后我们将步骤1中的红色材质<strong>M_PlayerBulletSkill</strong>拖拽给爆炸特效的材质中即可完成特效材质更换</li></ol></li><li><p>将曝气子弹的设置应用到预制体上，然后从场景上删除</p></li></ol><h3 id="发射曝气子弹"><a href="#发射曝气子弹" class="headerlink" title="发射曝气子弹"></a>发射曝气子弹</h3><blockquote><p>思路：</p><p>可以使用Find等方法去获取敌人位置，但如果一直在Update中调用遍历查找的方法，会十分耗性能</p><p>所以我们可以回到之前的敌人管理器脚本中</p><p>我们在该脚本中写了一个链表存储敌人，所以可以直接通过链表查找，它的时间复杂度远于使用Find等方法查找</p></blockquote><ol><li><p>打开之前的<strong>Fire</strong>脚本，声明曝气子弹对象，再写一个协程，当我们开启曝气后，会自动发射曝气子弹</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Fire</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform firePos;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> fireTime = <span class="number">0.5f</span>;  <span class="comment">//子弹开火的间隔时间</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> skillFireTime = <span class="number">0.5f</span>;  <span class="comment">//子弹开火的间隔时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> expendBulletNum = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明一个AudioClip类变量来保存子弹发射音效</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] AudioClip bulletSFX;</span><br><span class="line">    <span class="comment">//声明一个浮点型变量，设置子弹音效的音量</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> bulletSFXVolume = <span class="number">1f</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="meta-string">&quot;爆发子弹，别忘记拖拽&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">SerializeField</span>] GameObject bulletSkill;  </span><br><span class="line"></span><br><span class="line">    WaitForSeconds waitForSeconds; <span class="comment">//直接将协程的值保存下来</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//在Start中初始化，这样就不会多次声明</span></span><br><span class="line">        waitForSeconds = <span class="keyword">new</span> WaitForSeconds(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        MyFire();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MyFire</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        fireTime += Time.deltaTime;   <span class="comment">//时间累加</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKey(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">//每隔0.1s可以发射一次子弹,且子弹数大于0</span></span><br><span class="line">                <span class="keyword">if</span> (fireTime &gt; <span class="number">0.1f</span> &amp;&amp; PlayerBullet.instance.nowBulletNums &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    PlayerBullet.instance.FireBullet(expendBulletNum);    <span class="comment">//消耗子弹</span></span><br><span class="line">                    GameObject bullet = PoolManager.Instance().GetObject(<span class="string">&quot;Player Projectile&quot;</span>); <span class="comment">//从对象池中创建子弹</span></span><br><span class="line">                    bullet.transform.position = firePos.position;<span class="comment">//为子弹赋值位置</span></span><br><span class="line">                    fireTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//调用AudioManaer中PlayRandomSFX方法</span></span><br><span class="line">                    AudioManager.instance.PlayRandomSFX(bulletSFX, bulletSFXVolume);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当处于爆气状态时，发射红色子弹，发射间隔时间减少</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">PlayerSkill</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">while</span> (FindObjectOfType&lt;PlayerSkill&gt;().isSkill)</span><br><span class="line">        &#123;</span><br><span class="line">            skillFireTime += Time.deltaTime;</span><br><span class="line">            <span class="comment">//每隔0.1s可以发射一次子弹,且子弹数大于0</span></span><br><span class="line">            <span class="keyword">if</span> (skillFireTime &gt; <span class="number">0.07f</span> &amp;&amp; PlayerBullet.instance.nowBulletNums &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                PlayerBullet.instance.FireBullet(expendBulletNum);    <span class="comment">//消耗子弹</span></span><br><span class="line">                GameObject bullet = PoolManager.Instance().GetObject(bulletSkill.name); <span class="comment">//从对象池中创建子弹</span></span><br><span class="line">                bullet.transform.position = firePos.position;<span class="comment">//为子弹赋值位置</span></span><br><span class="line">                skillFireTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//调用AudioManaer中PlayRandomSFX方法</span></span><br><span class="line">                AudioManager.instance.PlayRandomSFX(bulletSFX, bulletSFXVolume);</span><br><span class="line">            &#125;      </span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>打开之前的<strong>PlayerSkill</strong>脚本，我们将在这里开启 和 关闭曝气时发射红色子弹的协程</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerSkill</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>] GameObject triggerVFX;</span><br><span class="line">    [<span class="meta">SerializeField</span>] GameObject engineVFXNormal;</span><br><span class="line">    [<span class="meta">SerializeField</span>] GameObject engineVFXSkill;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>] AudioClip onSFX;</span><br><span class="line">    [<span class="meta">SerializeField</span>] AudioClip offSFX;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="meta-string">&quot;----技能-----&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isSkill;   <span class="comment">//判断技能是否正在开启</span></span><br><span class="line">    <span class="comment">//这里的三个参数都是提升系数</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> skillMoveSpeed;   <span class="comment">//曝气后的速度</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> skillDamage;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> skillBulletSpeed;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> skillPlayerBulletNums;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Skill();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//曝气方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Skill</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//当能量已满时，可以释放曝气</span></span><br><span class="line">        <span class="keyword">if</span> (PlayerEnergy.instance.IsEnough(PlayerEnergy.MAX_ENERGY))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Tab))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//曝气开启</span></span><br><span class="line">                SkillOn();</span><br><span class="line">                StartCoroutine(FindObjectOfType&lt;Fire&gt;().PlayerSkill()); <span class="comment">//开启爆发协程               </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (PlayerEnergy.instance.energy == <span class="number">0</span> &amp;&amp; isSkill)</span><br><span class="line">        &#123;</span><br><span class="line">            SkillOff();</span><br><span class="line">            StopCoroutine(FindObjectOfType&lt;Fire&gt;().PlayerSkill());  <span class="comment">//关闭爆发协程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//曝气开启</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SkillOn</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//曝气结束</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SkillOff</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这样当我们按下tab键后，就能自动发射红色子弹，以及自己的蓝色子弹了</p></blockquote></li></ol><h3 id="曝气子弹追踪"><a href="#曝气子弹追踪" class="headerlink" title="曝气子弹追踪"></a>曝气子弹追踪</h3><ol><li><p>打开之前的EnemyManager脚本，我们会在里面添加一个获得敌人链表中对象的方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyManager</span> : <span class="title">SingletonBase</span>&lt;<span class="title">EnemyManager</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//lambda表达式加三元运算符，当链表数量为0时，返回null，否则随机返回一个敌人</span></span><br><span class="line">    <span class="keyword">public</span> GameObject RandomEnemy =&gt; enemyList.Count ==<span class="number">0</span> ? <span class="literal">null</span> : enemyList[Random.Range(<span class="number">0</span>,enemyList.Count)];</span><br><span class="line"></span><br><span class="line">  -------------------------------------------------------------------</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>新建一个<strong>PlayerBulletSkill</strong>脚本，让它继承于<strong>Projectile</strong>脚本</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerBulletSkill</span> : <span class="title">Projectile</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>打开<strong>Projectile</strong>脚本，里面需要添加设置敌人位置的方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Projectile</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">protected</span> GameObject bulletHitVFX; <span class="comment">//子弹击中特效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> GameObject hitVFX;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> damage;   <span class="comment">//子弹伤害</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> moveSpeed = <span class="number">10</span>;   <span class="comment">//子弹移动速度</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">protected</span> Vector2 moveDirection;  <span class="comment">//子弹移动方向</span></span><br><span class="line">    <span class="comment">//声明一个AudioClip类变量子弹命中音效</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] AudioClip bulletSFX;</span><br><span class="line">    <span class="comment">//声明一个浮点型变量，设置子弹命中的音量</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">float</span> bulletSFXVolume = <span class="number">1f</span>;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">protected</span> GameObject target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">       EnemyMove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span>  <span class="title">EnemyMove</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.transform.Translate(moveDirection * moveSpeed * Time.deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnCollisionEnter2D</span>(<span class="params">Collision2D collision</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">-----------------------------------------------</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//调用子弹位置赋值方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">SetTarget</span>(<span class="params">GameObject target</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;<span class="comment">//将敌人位置赋值给子弹 </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li></li></ol><ol><li>新建一个<strong>BulletGuidanceSystem</strong>脚本，不要忘记将它挂载到曝气子弹上</li><li></li></ol><hr><h2 id="子弹时间"><a href="#子弹时间" class="headerlink" title="子弹时间"></a>子弹时间</h2><blockquote><p>Unity中的时间流速是由Time.timeScale控制的</p><p>所以我们可以通过修改Time.timeScale的值，来达到子弹时间的效果</p></blockquote><ol><li>在场景中新建一个空对象，为其命名为<strong>TimeController</strong></li><li><p>为<strong>TimeController</strong>新建一个同名脚本</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TimeController</span>:<span class="title">SingletonBase</span>&lt;<span class="title">TimeController</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//声明Unity时间流速变量</span></span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="built_in">float</span> bulletTimeScale = <span class="number">0.1f</span>;</span><br><span class="line"><span class="comment">//声明物理帧更新时间流速</span></span><br><span class="line">    <span class="built_in">float</span> defauleFixedDeltaTime;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">base</span>.Awake();</span><br><span class="line">        defauleFixedDeltaTime = Time.fixedDeltaTime;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//子弹时间方法，修改Unity的时间流速，并开启恢复时间流速的协程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BulletTime</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Time.timeScale = bulletTimeScale;</span><br><span class="line">     <span class="comment">//   Time.fixedDeltaTime = defauleFixedDeltaTime * Time.timeScale;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//利用协程和Lerp线性插值，恢复时间流速。参数传入子弹时间的持续时间</span></span><br><span class="line"><span class="function">IEnumerator <span class="title">SlowOutCoroutine</span>(<span class="params"><span class="built_in">float</span> duration</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(t &lt; <span class="number">1f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这里不能用Time.deltaTime，因为它会受到timeScale的影响</span></span><br><span class="line">            t += Time.unscaledDeltaTime / duration;</span><br><span class="line">            Time.timeScale = Mathf.Lerp(bulletTimeScale, <span class="number">1f</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>如果之前使用了物理帧更新时间，则要将其一起修改，否则看起来会卡卡的，这是因为Unity当前的时间流速改变，而物理帧更新时间的流速来说原来的样子</p><p>如果子弹时间的持续明显较长，则是每帧增加的时间中使用了Time.deltatime</p></blockquote></li></ol><blockquote><p>当前脚本的初始化工作建议在Awake()函数中进行</p><p>由于我们自定义的函数，默认在同一代码块中是随机调用的</p><p>如果所有的脚本都在Start()函数中进行初始化，又在Start()中相互引用</p><p>就可能出现某个脚本引用时还未初始化的情况，这时就会报错空引用异常</p><p>而Awake函数比Start函数先执行，所以一定能保证该脚本再使用前已经初始化了</p><p>所以Awake函数中<strong>尽量初始化当前脚本</strong></p><p>而Start函数则留给<strong>其他脚本进行初始化</strong> 和 <strong>调用其他脚本中的函数</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Demo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大排序</title>
      <link href="blog/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F/"/>
      <url>blog/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="复杂度-n-2-排序"><a href="#复杂度-n-2-排序" class="headerlink" title="复杂度(n^2)排序"></a>复杂度(n^2)排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n[]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h3><p>时间复杂度(n^2)，空间复杂度(O1)，稳定排序，不需要额外的空间</p><p><strong>核心思想</strong>：</p><p>总共n个数，需要排n-1轮</p><p>每轮对比个数=总数-排序次数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//0324-冒泡排序从大到小</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = nums.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &lt; nums[j]) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = nums[j];</span><br><span class="line">nums[j] = nums[i];</span><br><span class="line">nums[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123; <span class="number">8</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">5</span> &#125;;</span><br><span class="line">sort(nums);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nums[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h3><p>时间复杂度(n^2),<strong>非稳定排序</strong></p><p><strong>核心思想</strong>：</p><ol><li>在<strong>未排序</strong>序列中找到<strong>最小(大)值</strong>，存放到排序序列的<strong>起始位置</strong></li><li>从剩余未排序元素中继续寻找最小(大)值，然后放到已排序列的末尾</li><li>以此类推，直到所有元素排序完毕</li></ol><p><strong>主要步骤：</strong></p><ol><li><p>先设假设<strong>0号下标</strong>所对应的元素为<strong>最小值所对应的下标</strong></p></li><li><p>然后依次遍历<strong>1~(n-1)</strong>号下标所对应的元素，找到<strong>未排序元素</strong>中的<strong>最小值</strong></p><ol><li><strong>更新最小值所对应的下标</strong></li></ol></li><li><p>通过交换，就能将最小值放在序列中的第一位。即一次选出一个最小值</p></li><li><p>依次类推，通过双重循环遍历就能选出所有元素</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionsort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();   </span><br><span class="line">    <span class="keyword">int</span> minIndex; <span class="comment">//最小值对应的下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        minIndex = i;<span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[minIndex] &gt; nums[j]) &#123;</span><br><span class="line">                minIndex = j;<span class="comment">//更新最小值对应的下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[i], nums[minIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123; <span class="number">8</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    selectionsort(nums);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; nums[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h3><p>时间复杂度<strong>(n^2)</strong>，<strong>稳定</strong>排序</p><p><strong>适用场景</strong>：</p><ol><li>序列<strong>基本有序</strong>时，效率高</li><li>待排序<strong>个数较少</strong>时，效率高</li></ol><p><strong>核心思想</strong>：</p><ol><li>从第一个元素开始，该元素可以认为已经被排序 </li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描 </li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置 </li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 </li><li>将新元素插入到该位置后 </li><li>重复步骤2~5</li></ol><p><strong>主要步骤</strong>：</p><ol><li>数组下标<strong>1</strong>的数和下标<strong>0</strong>的数进行<strong>比较</strong><ol><li>若下标1的数大于下标0的数，则二者<strong>交换</strong></li><li>否则保持<strong>位置不变</strong></li></ol></li><li>再将下标<strong>2</strong>的数和下标<strong>1</strong>的数进行<strong>比较</strong><ol><li>若下标<strong>2</strong>的数大于下标<strong>1</strong>的数，则二者<strong>交换</strong>，再用<strong>下标1</strong>的数和<strong>下标0</strong>的数比较</li><li>否则保持<strong>位置不变</strong></li></ol></li><li>最后一直到下标<strong>n-2</strong>的数和下标<strong>n-1</strong>的数进行比较<ol><li>若下标<strong>n-2</strong>的数大于下标<strong>n-1</strong>的数，则二者<strong>交换</strong>，并且一直向前比较</li></ol></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"><span class="meta">#include&lt;vector&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort</span>(<span class="params">vector&lt;<span class="built_in">int</span>&gt;&amp; nums</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> n = nums.size();<span class="comment">//获得vector最大长度   </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、默认0号下标所对应元素 已经排好序</span></span><br><span class="line">    <span class="comment">//2、所以 i 代表从 1 号开始 未排好序的元素下标</span></span><br><span class="line">    <span class="comment">//3、j 代表 i 前方已经排好序的元素下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;   <span class="comment">//i 表示从 1 号开始的下标</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            <span class="built_in">int</span> j = i - <span class="number">1</span>;        <span class="comment">//j 表示已排序序列的最大数对应下标</span></span><br><span class="line">            <span class="built_in">int</span> temp = nums[i];   <span class="comment">//临时存放 i 号下标所对应的元素</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; nums[j]) &#123;</span><br><span class="line">                nums[j + <span class="number">1</span>] = nums[j];  <span class="comment">//因为j+1所对应的元素已经提前存好，所以可以放心往后移动元素</span></span><br><span class="line">                j--;    <span class="comment">//元素后移, j 最小会退到 -1 然后跳出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            nums[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; nums = &#123; <span class="number">8</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    insertionSort(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; nums[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="复杂度-n-log-n-排序"><a href="#复杂度-n-log-n-排序" class="headerlink" title="复杂度(n log n)排序"></a>复杂度(n log n)排序</h2><h3 id="1-归并排序"><a href="#1-归并排序" class="headerlink" title="1. 归并排序"></a>1. 归并排序</h3><p>缺点：</p><p>需要用到一个<strong>与原始序列相同大小的辅助序列</strong></p><p>核心思想：</p><p> 1、把长度为<strong>n</strong>的输入序列 分成两个长度为<strong>n/2</strong>的子序列；</p><p> 2、对这两个子序列分别采用<strong>归并</strong>排序；</p><p> 3、 将两个排序好的子序列合并成一个最终的排序序列。</p><p><strong>基本步骤</strong>：</p><ol><li>让数组中的<strong>每个数单独</strong>成为<strong>长度为1的有序区间</strong></li><li>然后将<strong>相邻</strong>的<strong>有序</strong>区间<strong>合并</strong>为长度为2的有序区间</li><li>再将<strong>相邻</strong>的<strong>有序</strong>区间<strong>合并</strong>为长度为4的有序区间</li><li>直到数组中的<strong>所有数</strong>，合并成<strong>统一</strong>的有序区间</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//low是整个序列中首元素所对应的下标，也是左区间首元素下标</span></span><br><span class="line"><span class="comment">//high是整个序列中尾元素所对应下标，也是右区间尾元素下标</span></span><br><span class="line"><span class="comment">//mid是整个区级的分隔点，也是左区间尾元素的下标，代表左区间的high</span></span><br><span class="line"><span class="comment">//mid+1是右区间首元素下标，代表右区间的low</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSortCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numsTemp, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (low &gt;= high)<span class="comment">//当区间只有一个元素时，结束递归</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> len = high - low;<span class="comment">//序列最大下标</span></span><br><span class="line"><span class="keyword">int</span> mid = low + len / <span class="number">2</span>;<span class="comment">//序列从mid开始分隔</span></span><br><span class="line"><span class="keyword">int</span> leftStart = low, leftEnd = mid, rightStart = mid + <span class="number">1</span>, rightEnd = high;</span><br><span class="line">mergeSortCore(nums, numsTemp, leftStart, leftEnd);<span class="comment">//递归左区间</span></span><br><span class="line">mergeSortCore(nums, numsTemp, rightStart, rightEnd);<span class="comment">//递归右区间</span></span><br><span class="line"><span class="keyword">int</span> index = low;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (leftStart &lt;= leftEnd &amp;&amp; rightStart &lt;= rightEnd)&#123;</span><br><span class="line">numsTemp[index++] = nums[leftStart] &lt; nums[rightStart] ? nums[leftStart++] : nums[rightStart++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (leftStart &lt;= leftEnd) &#123;</span><br><span class="line">numsTemp[index++] = nums[leftStart++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (rightStart &lt;= rightEnd)&#123;</span><br><span class="line">numsTemp[index++] = nums[rightStart++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (index = low; index &lt;= high; index++) &#123;</span><br><span class="line">nums[index] = numsTemp[index];<span class="comment">//将排序完的辅助序列，复制给原序列</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个与原始序列相同的辅助序列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = nums.size();</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">numsTemp</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">mergeSortCore(nums, numsTemp, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123; <span class="number">8</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">5</span> &#125;;</span><br><span class="line">mergeSort(nums);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nums[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2. 快速排序"></a>2. 快速排序</h3><p><strong>核心思想</strong>：</p><ol><li>选取数值第一个数作为基准<ol><li>小于等于该数的值都放在左边</li><li>大于等于该数的值都放在右边</li></ol></li><li>然后对左右区间重复上述步骤，直到各区间只有一个数</li></ol><p><strong>主要步骤</strong>：</p><ol><li>将<strong>第一个元素</strong>设置为<strong>基准数</strong>，用来做<strong>参照</strong>作用</li><li>设置<strong>两个哨兵</strong> <strong>L</strong> 和 <strong>R</strong> ，分别指向序列<strong>最左边</strong>和<strong>最右边</strong>，并从<strong>两端</strong>开始探测<ol><li>先从<strong>右往左</strong>找一个<strong>小于基准</strong>的数</li><li>再从<strong>左往右</strong>找一个<strong>大于基准</strong>的数</li><li>之后再<strong>交换</strong>两个哨兵所对应的数</li><li>最后哨兵 <strong>L</strong> 和 <strong>R</strong> 重复1~3步骤，直到相遇才结束。(每次必须是 哨兵 <strong>R</strong> 先动)</li></ol></li><li>此时哨兵<strong>相遇的位置</strong>就是<strong>基准数的预期位置</strong>，所以用其和<strong>第一个元素</strong>进行交换，完成对 基准数左右两边的区分</li><li>最后利用<strong>递归</strong>，重复对基准数左右两边实现上述的2~3步骤，直到各区间<strong>只有一个数</strong></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"><span class="meta">#include&lt;vector&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、选取第一个数为基准</span></span><br><span class="line"><span class="comment">//2、比基准小的数交换到前面，比基准大的数交换到后慢</span></span><br><span class="line"><span class="comment">//3、对左右区间重复第二步，直到区间只有一个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span>(<span class="params">vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> frist, <span class="built_in">int</span> last</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 定义哨兵 L 和 R 以及选取第一个数为基准数 </span></span><br><span class="line">    <span class="built_in">int</span> left = frist;<span class="comment">//frist 表示数组首元素下标</span></span><br><span class="line"><span class="built_in">int</span> right = last;<span class="comment">//last 表示数组尾元素下标</span></span><br><span class="line"><span class="built_in">int</span> key = nums[left];<span class="comment">//将数组的首元素作为基准</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当区间只剩一个元素时，跳出函数</span></span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两个哨兵相遇后跳出</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="comment">//右哨兵向左移动，直到遇到小于基准的数时跳出 停下来</span></span><br><span class="line"><span class="keyword">while</span> (nums[right]&gt;=key &amp;&amp; left&lt;right)&#123;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//左哨兵向右移动，直到遇见大于基准的数 停下来</span></span><br><span class="line"><span class="keyword">while</span> (nums[left] &lt;= key &amp;&amp; left &lt; right)&#123;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//若左哨兵和右哨兵未相遇，则交换其所指的数</span></span><br><span class="line"><span class="keyword">if</span> (frist &lt; last) &#123;</span><br><span class="line"><span class="built_in">int</span> temp = nums[right];</span><br><span class="line">nums[right] = nums[left];</span><br><span class="line">nums[left] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若左右哨兵相遇，则交换基准元素，将其归位</span></span><br><span class="line">nums[frist] = nums[left];</span><br><span class="line">nums[left] = key;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理左边的数据</span></span><br><span class="line">quickSort(nums, frist, left - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//处理右边的数据</span></span><br><span class="line">quickSort(nums, left + <span class="number">1</span>, last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="built_in">int</span>&gt; nums = &#123; <span class="number">8</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//传入vector，以及首元素下标和尾元素下标</span></span><br><span class="line">quickSort(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">cout &lt;&lt; nums[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-堆排序"><a href="#3-堆排序" class="headerlink" title="3.堆排序"></a>3.堆排序</h3><h2 id="复杂度-n-log-n-2）"><a href="#复杂度-n-log-n-2）" class="headerlink" title="复杂度(n (log n)^2）"></a>复杂度(n (log n)^2）</h2><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序来自于改良的插入排序，插入排序<strong>增量为1</strong></p><p>希尔排序的关键：在于<strong>增量的选择</strong>，其增量是<strong>从大到小</strong>调整</p><p><strong>特点</strong>：</p><ol><li><strong>缩小增量</strong></li><li><strong>多遍插入排序</strong></li></ol><p><strong>核心思想</strong>：</p><ol><li>定义一个<strong>递减</strong>的增量序列。如h1=n/2  ，h2 = n/4 … 直到增量序列到 <strong>1</strong> 为止</li><li>对每一个增量进行 “<strong>增量间隔</strong>” 插入排序</li></ol><p><strong>主要步骤</strong>：</p><ol><li>定义一个初始增量，使用<strong>循环遍历</strong>让初始增量<strong>不断递减</strong>，直到增量为 <strong>1</strong><ol><li>利用循环遍历记录下每一个增量的值，因为<strong>增量的大小</strong> 也<strong>决定了</strong>从<strong>第几个元素开始进行插入排序</strong></li></ol></li><li>进行插入排序，要注意增量改变带来的变化</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"><span class="meta">#include&lt;vector&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数写 增量的循环遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span>(<span class="params">vector&lt;<span class="built_in">int</span>&gt;&amp; nums</span>)</span> &#123;</span><br><span class="line"><span class="built_in">int</span> len = nums.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行分组，最开始的时候增量gap为数组长度的一半</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> gap = len / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从 i 开始的元素不断隔着增量gap 与前面的元素进行比较</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">shellSortCore(nums, gap, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSortCore</span>(<span class="params">vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> gap , <span class="built_in">int</span> i </span>)</span> &#123;</span><br><span class="line"><span class="built_in">int</span> j = i - gap;<span class="comment">//j 表示已排序序列的最大数对应下标</span></span><br><span class="line"><span class="built_in">int</span> temp = nums[i];<span class="comment">//临时存放i的数据，最后需要插入到合适位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; nums[j]) &#123;</span><br><span class="line">nums[j+gap] = nums[j];</span><br><span class="line">j -= gap;</span><br><span class="line">&#125;</span><br><span class="line">nums[j + gap] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="built_in">int</span>&gt; nums = &#123; <span class="number">8</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">5</span> &#125;;</span><br><span class="line">shellSort(nums);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">cout &lt;&lt; nums[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="复杂度-n"><a href="#复杂度-n" class="headerlink" title="复杂度( n )"></a>复杂度( n )</h2><h3 id="桶排序思想"><a href="#桶排序思想" class="headerlink" title="桶排序思想"></a>桶排序思想</h3><p>时间复杂度O(n)的排序算法</p><h4 id="1-计数排序"><a href="#1-计数排序" class="headerlink" title="1. 计数排序"></a>1. 计数排序</h4><p><strong>核心思想</strong>：</p><ol><li>根据数据内容 摆放好带顺序的”桶“</li><li>将数据放到相应的”桶“内</li><li>最后将”桶“内的数据倒出</li></ol><p>列如：</p><p>张三，李四，王五的成绩分别为：B，D，A</p><p>而成绩的范围是A~E，所以我们可以摆放五个”桶”</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity简单对话系统</title>
      <link href="blog/Unity%E7%AE%80%E5%8D%95%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F/"/>
      <url>blog/Unity%E7%AE%80%E5%8D%95%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简单的对话系统"><a href="#简单的对话系统" class="headerlink" title="简单的对话系统"></a>简单的对话系统</h2><ol><li>创建一个<strong>DialogueManager</strong>脚本，用于管理对话</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DialogueManager</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DialogueManager instance;<span class="comment">//设置一个伪单例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> GameObject dialogueBox;  <span class="comment">//用于关联Panel</span></span><br><span class="line"><span class="keyword">public</span> Text dialogueText, nameText; <span class="comment">//用于更新对话窗口的输出文本以及对话者名字</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">TextArea(1, 3)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span>[] dialogueLines;  <span class="comment">//存储对话内容</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">int</span> currentLine;   <span class="comment">//数组对话行数的当前索引</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">instance = <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">if</span>(instance != <span class="keyword">this</span>)</span><br><span class="line">            &#123;</span><br><span class="line">Destroy(gameObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">DontDestroyOnLoad(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">dialogueText.text = dialogueLines[currentLine];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update is called once per frame</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dialogueBox.activeInHierarchy)<span class="comment">//当整个面板失活时，就不进行自增和更新文本</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">if</span> (Input.GetMouseButtonUp(<span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(isScrolling == <span class="literal">false</span>)<span class="comment">//只有当文本滚动完成后，才能点击到下一行对话</span></span><br><span class="line">                &#123;</span><br><span class="line">currentLine++;  <span class="comment">//切换下一行对话</span></span><br><span class="line"><span class="keyword">if</span> (currentLine &lt; dialogueLines.Length)</span><br><span class="line">&#123;   <span class="comment">//防止数组越界</span></span><br><span class="line">CheckName();</span><br><span class="line">dialogueText.text = dialogueLines[currentLine]; <span class="comment">//更新文本</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">dialogueBox.SetActive(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单例模式中封装的方法，方便其他类中调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowDialogue</span>(<span class="params"><span class="built_in">string</span>[] _newLines</span>)<span class="comment">//人物对话通过参数传递</span></span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">dialogueLines = _newLines;<span class="comment">//更新不同人物的对话</span></span><br><span class="line">currentLine = <span class="number">0</span>;<span class="comment">//对话从第一句说话开始</span></span><br><span class="line"></span><br><span class="line">CheckName();</span><br><span class="line"></span><br><span class="line">dialogueText.text = dialogueLines[currentLine]; <span class="comment">//更新文本</span></span><br><span class="line">dialogueBox.SetActive(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CheckName</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"><span class="comment">//StartsWith(&quot;n-&quot;)判断字符串是否以某些字符开头</span></span><br><span class="line"><span class="keyword">if</span> (dialogueLines[currentLine].StartsWith(<span class="string">&quot;n-&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//将名字这一行内容显示在nameText组件中，而下一行才是显示在文本框中</span></span><br><span class="line">nameText.text = dialogueLines[currentLine].Replace(<span class="string">&quot;n-&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">currentLine++;<span class="comment">//行数++</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>创建<strong>Talkable</strong>脚本，具体对话内容在该脚本中实现</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Talkable</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="built_in">bool</span> isEnter;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span>[] lines;</span><br><span class="line">[<span class="meta">TextArea(1, 3)</span>]</span><br><span class="line"></span><br><span class="line">RaycastHit hit;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">Ray r = Camera.main.ScreenPointToRay(Input.mousePosition);</span><br><span class="line"><span class="keyword">if</span> (Physics.Raycast(r, <span class="keyword">out</span> hit ) )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( hit.collider.tag == <span class="string">&quot;Player&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">isEnter = <span class="literal">true</span>;<span class="comment">//射线碰撞到玩家，设置为true</span></span><br><span class="line">print(<span class="string">&quot;检测碰撞到了对象&quot;</span>);</span><br><span class="line"><span class="comment">//加入判断条件，即面板处于失活，且射线范围在人物内时，才开启面板。否则，面板就能重复开启</span></span><br><span class="line"><span class="keyword">if</span> (isEnter &amp;&amp; DialogueManager.instance.dialogueBox.activeSelf == <span class="literal">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">DialogueManager.instance.ShowDialogue(lines);</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">isEnter = <span class="literal">false</span>;</span><br><span class="line">print(<span class="string">&quot;退出方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="打字机效果"><a href="#打字机效果" class="headerlink" title="打字机效果"></a>打字机效果</h3><p>如果需要文本出现时，有滚动的打字机效果。那么可以在<strong>DialogueManager</strong>脚本中使用协程来实现</p><p>代码改动如下</p><blockquote><p>协程逻辑并不难实现，重要是要考虑到在哪里开启协程函数</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DialogueManager</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DialogueManager instance;<span class="comment">//设置一个伪单例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> GameObject dialogueBox;  <span class="comment">//用于关联Panel</span></span><br><span class="line"><span class="keyword">public</span> Text dialogueText, nameText; <span class="comment">//用于更新对话窗口的输出文本以及对话者名字</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">TextArea(1, 3)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span>[] dialogueLines;  <span class="comment">//存储对话内容</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">int</span> currentLine;   <span class="comment">//数组对话行数的当前索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> isScrolling;</span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="built_in">float</span> rollTime = <span class="number">0.15f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">instance = <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">if</span>(instance != <span class="keyword">this</span>)</span><br><span class="line">            &#123;</span><br><span class="line">Destroy(gameObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">DontDestroyOnLoad(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">dialogueText.text = dialogueLines[currentLine];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update is called once per frame</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dialogueBox.activeInHierarchy)<span class="comment">//当整个面板失活时，就不进行自增和更新文本</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">if</span> (Input.GetMouseButtonUp(<span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(isScrolling == <span class="literal">false</span>)<span class="comment">//只有当文本滚动完成后，才能点击到下一行对话</span></span><br><span class="line">                &#123;</span><br><span class="line">currentLine++;  <span class="comment">//切换下一行对话</span></span><br><span class="line"><span class="keyword">if</span> (currentLine &lt; dialogueLines.Length)</span><br><span class="line">&#123;   <span class="comment">//防止数组越界</span></span><br><span class="line">CheckName();</span><br><span class="line"><span class="comment">//dialogueText.text = dialogueLines[currentLine]; //更新文本,用打字机效果替换改文本</span></span><br><span class="line">StartCoroutine(ScrollingText());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">dialogueBox.SetActive(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单例模式中封装的方法，方便其他类中调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowDialogue</span>(<span class="params"><span class="built_in">string</span>[] _newLines</span>)<span class="comment">//人物对话通过参数传递</span></span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">dialogueLines = _newLines;<span class="comment">//更新不同人物的对话</span></span><br><span class="line">currentLine = <span class="number">0</span>;<span class="comment">//对话从第一句说话开始</span></span><br><span class="line"></span><br><span class="line">CheckName();</span><br><span class="line"></span><br><span class="line"><span class="comment">//dialogueText.text = dialogueLines[currentLine]; //更新文本用协程打字机效果替换一行一行显示</span></span><br><span class="line">StartCoroutine(ScrollingText());</span><br><span class="line">dialogueBox.SetActive(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CheckName</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"><span class="comment">//StartsWith(&quot;n-&quot;)判断字符串是否以某些字符开头</span></span><br><span class="line"><span class="keyword">if</span> (dialogueLines[currentLine].StartsWith(<span class="string">&quot;n-&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//将名字这一行内容显示在nameText组件中，而下一行才是显示在文本框中</span></span><br><span class="line">nameText.text = dialogueLines[currentLine].Replace(<span class="string">&quot;n-&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">currentLine++;<span class="comment">//行数++</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用协程实现打字机效果</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> IEnumerator <span class="title">ScrollingText</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"><span class="keyword">var</span> wait = <span class="keyword">new</span> WaitForSeconds(rollTime);</span><br><span class="line">isScrolling = <span class="literal">true</span>;</span><br><span class="line">dialogueText.text = <span class="string">&quot;&quot;</span>;<span class="comment">//保证每句话一开始都是从0个字母开始</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">char</span> letter <span class="keyword">in</span> dialogueLines[currentLine].ToCharArray())</span><br><span class="line">        &#123;</span><br><span class="line">dialogueText.text += letter;</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> wait;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">isScrolling = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Json数据持久化</title>
      <link href="blog/Json%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>blog/Json%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Json配置规则"><a href="#Json配置规则" class="headerlink" title="Json配置规则"></a>Json配置规则</h2><p>Json格式是一种键值对结果</p><p><strong>Json的语法规则</strong></p><p>符号含义：</p><ul><li>大括号 {} 中间包裹的内容一般代表对象</li><li>中括号 [] 数组</li><li>冒号 :    表示键值对的对应关系，左侧是键，右侧是值</li><li>逗号 ,  表示数据分割</li><li>双引号 “” 键名/字符串</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大括号包裹的就是一个对象</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>:<span class="string">&quot;孙悟空&quot;</span>,</span><br><span class="line"><span class="attr">&quot;age&quot;</span> : <span class="number">1000</span>,</span><br><span class="line"><span class="attr">&quot;sex&quot;</span> : <span class="literal">true</span>,</span><br><span class="line"><span class="attr">&quot;ids&quot;</span> : [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line"><span class="attr">&quot;students&quot;</span> : [&#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;小红&quot;</span>,<span class="attr">&quot;age&quot;</span>:<span class="number">10</span>,<span class="attr">&quot;sex&quot;</span>:<span class="literal">false</span>&#125;,</span><br><span class="line">&#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;小明&quot;</span>,<span class="attr">&quot;age&quot;</span>:<span class="number">10</span>,<span class="attr">&quot;sex&quot;</span>:<span class="literal">false</span>&#125;],</span><br><span class="line"><span class="attr">&quot;dic&quot;</span>: &#123;<span class="attr">&quot;1&quot;</span>:<span class="string">&quot;12&quot;</span>,<span class="attr">&quot;12&quot;</span>:<span class="string">&quot;123&quot;</span>&#125;<span class="comment">//字典转换为Json语法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>如果数据表示对象，那么最外层有大括号</li><li>一定是键值对形式</li><li>键一定是字符串格式</li><li>键值对用逗号分开</li><li>数组用[ ] 包裹</li><li>对象用{ } 包裹</li></ol><hr><h2 id="JsonUtlity"><a href="#JsonUtlity" class="headerlink" title="JsonUtlity"></a>JsonUtlity</h2><p>JsonUtlity 是Unity自带的用于解析Json的公共类</p><p>它可以<strong>将内存中对象序列化为Json格式的字符串</strong></p><p><strong>将Json字符串反序列化为类对象</strong> </p><p>主要用于将Json的内容<strong>序列化和反序列化</strong></p><h3 id="在文件中存取字符串"><a href="#在文件中存取字符串" class="headerlink" title="在文件中存取字符串"></a>在文件中存取字符串</h3><ul><li>存储字符串到指定路径文件中</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要引用命名空间using System.IO</span></span><br><span class="line"><span class="comment">//参数1：存在路径 参数2 内容</span></span><br><span class="line">File.WriteAllText(Application.persistentDataPath + <span class="string">&quot;/Test.Json&quot;</span>,<span class="string">&quot;张三的文件&quot;</span>);</span><br><span class="line">print(Application.persistentDataPath);<span class="comment">//打印路径，方便找到内容</span></span><br><span class="line"><span class="comment">//如果要用该API存储文件，一定要保证该文件夹存在</span></span><br></pre></td></tr></table></figure><ul><li>在指定路径文件中读取字符串</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = File.ReadAllText(Application.persitentDataPath + <span class="string">&quot;/Test.json&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="使用JsonUtlity进行序列化"><a href="#使用JsonUtlity进行序列化" class="headerlink" title="使用JsonUtlity进行序列化"></a>使用JsonUtlity进行序列化</h3><p>序列化：<strong>把内存中的数据 存储到硬盘上</strong></p><blockquote><p>方法：使用JsonUtility公共类中提供了现成的方法ToJson()，将对象传入该方法中，它会返回一个String类型的Json字符串，然后用File.WriteAllText()方法将字符串存储到本地</p><p>注意：</p><p>1、float类型在序列化时会有一些误差，但反序列化后数据将保持一致</p><p>2、当一个类成为了另一个类的成员时，它不能直接序列化，需要加上序列化特性[System.Serializable]</p><p>3、想要序列化非公共的属性，需要在前面加上[SerializeField]特性</p><p>4、JsonUtlity类不支持序列化字典</p><p>5、在序列化遇到null时，并不会将结果转化为null,而是该类型的初始值</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line">[<span class="meta">System.Serializable</span>]<span class="comment">//加了这个字段后，才能序列化自定义类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> hp;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Enemy</span>(<span class="params"><span class="built_in">int</span> hp, <span class="built_in">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.hp = hp;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最外层的类，不需要加字段，若该类中包含了其它类，则那个类必加字段</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> jumpCount;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> moveSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="built_in">int</span>&gt; bag;   <span class="comment">//用链表存储背包</span></span><br><span class="line">    <span class="keyword">public</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; dic; <span class="comment">//字典，键用int类型,值用string类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Enemy e1;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Enemy&gt; e2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test01</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        File.WriteAllText(Application.persistentDataPath + <span class="string">&quot;/Test.json&quot;</span>, <span class="string">&quot;存储的json文件&quot;</span>);</span><br><span class="line">        print(Application.persistentDataPath);<span class="comment">//打印路径，方便找到内容</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//为类对象的属性赋值</span></span><br><span class="line">        Player p = <span class="keyword">new</span> Player();</span><br><span class="line">        p.jumpCount = <span class="number">1</span>;</span><br><span class="line">        p.moveSpeed = <span class="number">2.0f</span>;</span><br><span class="line"></span><br><span class="line">        p.bag = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        p.dic = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;() &#123; &#123; <span class="number">1</span>, <span class="string">&quot;123&quot;</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        p.e1 = <span class="keyword">new</span> Enemy(<span class="number">1</span>,<span class="string">&quot;蘑菇&quot;</span>);</span><br><span class="line">        <span class="comment">//不支持字典</span></span><br><span class="line">        p.e2 = <span class="keyword">new</span> List&lt;Enemy&gt;() &#123; <span class="keyword">new</span> Enemy(<span class="number">2</span>, <span class="string">&quot;鸭子&quot;</span>), <span class="keyword">new</span> Enemy(<span class="number">3</span>, <span class="string">&quot;老鹰&quot;</span>) &#125;;</span><br><span class="line">        <span class="comment">//在序列化遇到null时，并不会将结果转化为null,而是该类型的初始值</span></span><br><span class="line">        p.e1 = <span class="literal">null</span>;    <span class="comment">//序列化结果为 0 和 &quot;&quot;</span></span><br><span class="line">        <span class="comment">//通过JsonUtility.ToJson()得到Json字符串</span></span><br><span class="line">        <span class="built_in">string</span> jsonStr =  JsonUtility.ToJson(p);</span><br><span class="line">        File.WriteAllText(Application.persistentDataPath + <span class="string">&quot;/Test1.json&quot;</span>,jsonStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用JsonUtlity进行反序列化"><a href="#使用JsonUtlity进行反序列化" class="headerlink" title="使用JsonUtlity进行反序列化"></a>使用JsonUtlity进行反序列化</h3><p>反序列化：就是将硬盘中的数据，读取到内存中</p><blockquote><p>方法：JsonUtility.FromJson(“string name”)</p><p>1、先通过File.ReadAllText()方法，读取指定位置的Json字符串</p><p>2、再将读取的字符串内容 通过JsonUtility.FromJson()方法赋值给类对象</p><p>注意：</p><p>1、JsonUtlity无法直接读取单纯的数据类型，它<strong>只能读取被类包裹的数据</strong></p><p>即，如果该Json文件中只有一个数据集合，那么就没法通过JsonUtility.FromJson()方法将该集合转换为类对象中的属性</p><p>只有为该集合添加一对中括号,即将其包裹在类中，这样该集合就相当于类的成员变量，之后才能进行转换。</p><p>2、Json的文本编码格式必须是UTF-8，否则也无法读取</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="meta">System.Serializable</span>]<span class="comment">//加了这个字段后，才能序列化自定义类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> hp;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Enemy</span>(<span class="params"><span class="built_in">int</span> hp, <span class="built_in">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.hp = hp;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最外层的类，不需要加字段，若该类中包含了其它类，则那个类必加字段</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> jumpCount;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> moveSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="built_in">int</span>&gt; bag;   <span class="comment">//用链表存储背包</span></span><br><span class="line">    <span class="keyword">public</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; dic; <span class="comment">//字典，键用int类型,值用string类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Enemy e1;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Enemy&gt; e2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test01</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        File.WriteAllText(Application.persistentDataPath + <span class="string">&quot;/Test.json&quot;</span>, <span class="string">&quot;存储的json文件&quot;</span>);</span><br><span class="line">        print(Application.persistentDataPath);<span class="comment">//打印路径，方便找到内容</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//为类对象的属性赋值</span></span><br><span class="line">        Player p = <span class="keyword">new</span> Player();</span><br><span class="line">        p.jumpCount = <span class="number">1</span>;</span><br><span class="line">        p.moveSpeed = <span class="number">2.0f</span>;</span><br><span class="line"></span><br><span class="line">        p.bag = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        p.dic = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;() &#123; &#123; <span class="number">1</span>, <span class="string">&quot;123&quot;</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        p.e1 = <span class="keyword">new</span> Enemy(<span class="number">1</span>,<span class="string">&quot;蘑菇&quot;</span>);</span><br><span class="line">        <span class="comment">//不支持字典</span></span><br><span class="line">        p.e2 = <span class="keyword">new</span> List&lt;Enemy&gt;() &#123; <span class="keyword">new</span> Enemy(<span class="number">2</span>, <span class="string">&quot;鸭子&quot;</span>), <span class="keyword">new</span> Enemy(<span class="number">3</span>, <span class="string">&quot;老鹰&quot;</span>) &#125;;</span><br><span class="line">        <span class="comment">//在序列化遇到null时，并不会将结果转化为null,而是该类型的初始值</span></span><br><span class="line">        p.e1 = <span class="literal">null</span>;    <span class="comment">//序列化结果为 0 和 &quot;&quot;</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">//序列化</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过JsonUtility.ToJson()得到Json字符串</span></span><br><span class="line">        <span class="built_in">string</span> jsonStr =  JsonUtility.ToJson(p);</span><br><span class="line">        File.WriteAllText(Application.persistentDataPath + <span class="string">&quot;/Test1.json&quot;</span>,jsonStr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反序列化</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取文件中的Json字符串</span></span><br><span class="line">        jsonStr = File.ReadAllText(Application.persistentDataPath + <span class="string">&quot;/Test1.json&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用JsonUtility.FromJson()方法，将Json字符串内容转换为类对象中的属性</span></span><br><span class="line">        Player p1 =  JsonUtility.FromJson&lt;Player&gt;(jsonStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-Demo</title>
      <link href="blog/Unity-Demo/"/>
      <url>blog/Unity-Demo/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="JUMP-DEMO"><a href="#JUMP-DEMO" class="headerlink" title="JUMP_DEMO"></a>JUMP_DEMO</h2><h3 id="01-使用Tilemap编辑地图"><a href="#01-使用Tilemap编辑地图" class="headerlink" title="01 使用Tilemap编辑地图"></a>01 使用Tilemap编辑地图</h3><h4 id="使用Tilemap绘制背景图"><a href="#使用Tilemap绘制背景图" class="headerlink" title="使用Tilemap绘制背景图"></a>使用Tilemap绘制背景图</h4><blockquote><p>1、先在Window-2D-Tile Palette 中创建调色板窗口</p><p>2、点击左边的<strong>Create New Palette</strong>，然后选择一个保持路径</p><p>3、将背景图的<strong>Pixels Per Unit</strong> 改为16，适应16像素网格大小</p><p>4、将所需要的资源拖入到Palette窗口中</p><p>5、在Hierarchy窗口，右键创建2Dobject-Tilemap</p><p>5、在调色板窗口点击<strong>Edit</strong>，启用编辑窗口</p><p>6、然后用调色板窗口中的吸管工具，在Scene窗口进行绘制</p></blockquote><h4 id="使用Tilemap绘制地形"><a href="#使用Tilemap绘制地形" class="headerlink" title="使用Tilemap绘制地形"></a>使用Tilemap绘制地形</h4><blockquote><p>1、点击Create New Palette，新建一个调色板用来绘画地形</p><p>2、将地形图的<strong>Pixels Per Unit</strong> 改为16</p><p>3、再将地形图导入新建的调色板</p><p>4、创建一个2Dobject-Tilemap，用来在上面绘制地形</p><p>5、点击Edit启用编辑调色板编辑窗口</p><p>6、使用吸管工具在Scene窗口进行绘制</p></blockquote><p><strong>注意</strong>：如果素材没有事先切好，则需要自己手动在Sprite Editor里面切割</p><blockquote><p>1、选中素材，将其Sprite Mode 改为 Multiple(图集元素分割模式)</p><p>2、点击Sprite Editor，开启图片编辑器</p><p>3、点击编辑器上的Slice，将模式改为<strong>Grid By Cell Size</strong>(按单元格大小切割)，以及下方的Piexl Size，改为16×16像素，也就是之前<strong>Pixels Per Unit</strong>中设置的像素</p><p>4、最后点击Apply，即可将图集切割成单元格的形式，之后再按照上述方法绘制即可</p></blockquote><p><strong>注意</strong>：我们可以在Project窗口，搜索框的右边第一个按钮，统一改变所有图片或图集素材的Pixels Per Unit像素大小</p><blockquote><p>1、鼠标移动到该按钮上，显示Sreach by Type就说明没找错</p><p>2、点击该按钮，在下拉列表中点击Texture选项，就会出现所有的图片或图集素材</p><p>3、全选素材后，统一将其Pixels Per Unit像素大小改为16</p><p>4、再次点击该按钮，取消Texture的勾选，即可回到原来面板</p></blockquote><hr><h3 id="02-图层相关"><a href="#02-图层相关" class="headerlink" title="02 图层相关"></a>02 图层相关</h3><ul><li><p>通过修改<strong>Tilemap Renderer</strong>组件中的 <strong>Sorting Layer</strong>参数，来设置图片出现的顺序</p><blockquote><p>1、选中之前背景图的Tilemap对象，找到它的Sorting Layer参数</p><p>2、点击该参数后，我们为其新建一个Background图层</p><p>3、然后将背景图对象的Sorting Layer参数修改为Background</p><p>4、再选中之前地形图的Tilemap对象，找到它的Sorting Layer参数</p><p>5、同样为它新建一个Frontground图层</p><p>6、然后将地形图对象的Sorting Layer参数改为Frontground</p></blockquote></li></ul><p><strong>注意</strong>：这里的图层逻辑</p><ul><li>在<strong>同一个图层</strong>下，即在同一个Sorting Layer参数下，<strong>Order In Layer参数大的显示在前面</strong></li><li>在<strong>不同图层</strong>下，<strong>Sorting Layer参数越在下方，显示在越前面</strong>。这时Order In Layer的大小将不能影响图层排序</li></ul><hr><h3 id="03-角色创建"><a href="#03-角色创建" class="headerlink" title="03 角色创建"></a>03 角色创建</h3><h4 id="通过为2D-Sprite关联图片来创建角色"><a href="#通过为2D-Sprite关联图片来创建角色" class="headerlink" title="通过为2D Sprite关联图片来创建角色"></a>通过为2D Sprite关联图片来创建角色</h4><blockquote><p>1、创建一个2D Sprite对象，命名为Player</p><p>2、将人物素材的<strong>Pixels Per Unit</strong> 改为16像素</p><p>3、找到Sprite Remderer组件，将人物待机图片拖动到Sprite参数中</p><p>4、选中Player对象，在Sorting Layer中添加一个新的Player图层，更改人物图层后，人物就能显示在最前方</p></blockquote><h4 id="为地形添加碰撞器"><a href="#为地形添加碰撞器" class="headerlink" title="为地形添加碰撞器"></a>为地形添加碰撞器</h4><blockquote><p>1、选中之前的地形对象</p><p>2、点击Add Component，为其添加Tilemap Collider 2D组件</p><p>3、勾选Tilemap Collider组件中的<strong>Used By Composite</strong>参数</p><p>4、再为地形添加<strong>Composite Collider2D</strong>组件(它会自动添加一个刚体)</p><p>5、再将自动添加的刚体类型Body Type参数设置为<strong>Static</strong></p><p>这样的好处：</p><p>如果仅添加Tilemap Collider组件，那么它会将地形的每一个像素单元都编辑成碰撞体。</p><p>而勾选了<strong>Used By Composite</strong>参数和<strong>Composite Collider2D</strong>组件后</p><p>只会将地形边缘整个编辑成碰撞体，这样可以节约性能</p></blockquote><h4 id="为人物添加刚体和碰撞器"><a href="#为人物添加刚体和碰撞器" class="headerlink" title="为人物添加刚体和碰撞器"></a>为人物添加刚体和碰撞器</h4><blockquote><p>1、选中Player对象，点击Add Component，为其添加<strong>Rigidbody 2D</strong>组件，和 <strong>Capsule Collider 2D</strong>组件</p><p>2、点击<strong>Capsule Collider 2D</strong>组件中的<strong>Edit Collider</strong>，将碰撞器的范围缩小到合适的位置</p></blockquote><p>注意：<strong>碰撞产生的条件，双方都要有碰撞器，其中有一个要有刚体</strong></p><hr><h3 id="04-角色移动-amp-跳跃"><a href="#04-角色移动-amp-跳跃" class="headerlink" title="04 角色移动&amp;跳跃"></a>04 角色移动&amp;跳跃</h3><p><strong>注意：</strong>人物的运动函数的调用，全部写在Up</p><h4 id="创建C-脚本实现角色的移动"><a href="#创建C-脚本实现角色的移动" class="headerlink" title="创建C#脚本实现角色的移动"></a>创建C#脚本实现角色的移动</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Playermove</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> runSpeed = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D rb;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//获取刚体组件</span></span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FixedUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Move();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Move</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//获取按键时的水平方向</span></span><br><span class="line">        <span class="built_in">float</span> direction = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (direction != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当按键时，水平方向就有一个速度，竖直方向上的速度来自于重力</span></span><br><span class="line">            rb.velocity = <span class="keyword">new</span> Vector2(runSpeed * direction, rb.velocity.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这里要注意的事情</p><p>1、别忘记将脚本挂在到人物上</p><p>2、找到刚体组件中的Consyraints参数，将它的Z轴勾选，也就是约束它的Z轴，不然人物移动过程中会”翻车”</p></blockquote><h4 id="角色跳跃"><a href="#角色跳跃" class="headerlink" title="角色跳跃"></a>角色跳跃</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Playermove</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> runSpeed = <span class="number">1</span>;  <span class="comment">//移动时的速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> upForce = <span class="number">3</span>; <span class="comment">//跳跃时向上的力</span></span><br><span class="line">    <span class="keyword">public</span> LayerMask ground;    <span class="comment">//地面</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> isGround;  <span class="comment">//判断是否在地面，用于锁定跳跃输入 </span></span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D rb;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//获取刚体组件</span></span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FixedUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Move();</span><br><span class="line">        Jump();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Move</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//获取按键时的水平方向</span></span><br><span class="line">        <span class="built_in">float</span> direction = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (direction != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当按键时，水平方向就有一个速度，竖直方向上的速度来自于重力</span></span><br><span class="line">            rb.velocity = <span class="keyword">new</span> Vector2(runSpeed * direction, rb.velocity.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Jump</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        isGround = rb.IsTouchingLayers(ground); <span class="comment">//检测人物是否接触地面</span></span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.Space) &amp;&amp; isGround)<span class="comment">//按下空格，并且人物在地面上</span></span><br><span class="line">        &#123;</span><br><span class="line">            rb.AddForce(<span class="keyword">new</span> Vector2(<span class="number">0</span>,upForce), ForceMode2D.Impulse);<span class="comment">//给刚体一个向上的力</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="角色长按跳跃"><a href="#角色长按跳跃" class="headerlink" title="角色长按跳跃"></a><strong>角色长按跳跃</strong></h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Playermove</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> runSpeed = <span class="number">1</span>;  <span class="comment">//移动时的速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> upForce = <span class="number">3</span>; <span class="comment">//跳跃时向上的力</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> addUpForce = <span class="number">0.1f</span>; <span class="comment">//长按时跳跃额外的力</span></span><br><span class="line">    <span class="keyword">public</span> LayerMask ground;    <span class="comment">//地面</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> jumpTime = <span class="number">0.0f</span>;  <span class="comment">//跳跃时间</span></span><br><span class="line">    <span class="built_in">bool</span> isGround;  <span class="comment">//判断是否在地面，用于锁定跳跃输入 </span></span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D rb;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//获取刚体组件</span></span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FixedUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Move();</span><br><span class="line">        Jump();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Move</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//获取按键时的水平方向</span></span><br><span class="line">        <span class="built_in">float</span> direction = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (direction != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当按键时，水平方向就有一个速度，竖直方向上的速度来自于重力</span></span><br><span class="line">            rb.velocity = <span class="keyword">new</span> Vector2(runSpeed * direction, rb.velocity.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Jump</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        isGround = rb.IsTouchingLayers(ground); <span class="comment">//检测人物是否接触地面</span></span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.Space) &amp;&amp; isGround)<span class="comment">//按下空格，并且人物在地面上</span></span><br><span class="line">        &#123;</span><br><span class="line">            jumpTime = Time.time + <span class="number">0.2f</span>;    <span class="comment">//跳跃时间等于当前时间加上0.2s</span></span><br><span class="line">            rb.AddForce(<span class="keyword">new</span> Vector2(<span class="number">0</span>,upForce), ForceMode2D.Impulse);<span class="comment">//给刚体一个向上的力</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按住空格，人物不在地面，当前时间小于跳跃时间</span></span><br><span class="line">        <span class="keyword">if</span>(Input.GetKey(KeyCode.Space) &amp;&amp; !isGround &amp;&amp; Time.time &lt; jumpTime)</span><br><span class="line">        &#123;</span><br><span class="line">            rb.AddForce(<span class="keyword">new</span> Vector2(<span class="number">0</span>,addUpForce), ForceMode2D.Impulse);<span class="comment">//给刚体添加额外力</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>在脚本中将Ground参数设置为ground</li><li>选中地形对象，为其新增一个名为gorund的<strong>Layer</strong></li><li>将地形对象的图层修改为ground</li></ol><blockquote><p>这样才能进行人物和地面的检测</p></blockquote><p>注意：可以为人物在下落时，而外添加一个力，这样能优化跳跃效果</p><hr><h3 id="05-角色动画"><a href="#05-角色动画" class="headerlink" title="05 角色动画"></a>05 角色动画</h3><h4 id="通过Animation动画系统角色添加待机动画"><a href="#通过Animation动画系统角色添加待机动画" class="headerlink" title="通过Animation动画系统角色添加待机动画"></a>通过Animation动画系统角色添加<strong>待机动画</strong></h4><blockquote><p>1、打开动画窗口<strong>Window-&gt;Animation-&gt;Animation（或者Ctrl+6）</strong></p><p>2、选中人物对象，点击Animation窗口中的<strong>Create</strong> 创建动画，选择保存位置后，创建完毕</p><p>3、在动画保存的位置，选中三角形的动画文件，点击Inspector面板右侧的”三个点”，切换为<strong>Debug模式</strong></p><p>4、在Debug模式中找到<strong>Sample Rate参数(每秒帧率)，将其改为15</strong>。之前再将模式切换回来</p><p>5、选中人物对象，找到人物的待机动画，直接拖入到Animation窗口，即可完成创建</p></blockquote><h4 id="通过Animation给人物添加更多动画"><a href="#通过Animation给人物添加更多动画" class="headerlink" title="通过Animation给人物添加更多动画"></a>通过Animation给人物添加更多动画</h4><blockquote><p>1、在Animation窗口左侧找到创建好的Idel待机动画</p><p>2、左键点击后会出现一个下拉框，点击<strong>Create new Clip</strong>，选择保存位置后，创建更多的动画</p><p>3、还是在动画保存的位置，选中三角形的动画文件，点击Inspector面板右侧的”三个点”，<strong>切换为Debug模式</strong></p><p>4、在Debug模式中找到<strong>Sample Rate参数(每秒帧率)，将其改为15</strong>。之前再将模式切换回来</p><p>5、<strong>选中人物对象</strong>，找到人物的跑步的动画，直接拖入到Animation窗口，即可完成创建</p><p>6、添加更多动画也是类似，重复上述操作即可</p></blockquote><p>注意：</p><p>若是添加的动画人物突然缩小，则需要点击该动画素材，查看其<strong>Pixels Per Unit</strong>参数是否为16个像素</p><h4 id="在Animator状态机窗口为动画添加联系"><a href="#在Animator状态机窗口为动画添加联系" class="headerlink" title="在Animator状态机窗口为动画添加联系"></a>在Animator状态机窗口为动画添加联系</h4><blockquote><p>1、点击Animator进入状态机窗口</p><p>2、选中Idel状态，从它开始，右键选择Make Transition，就可以<strong>连接到其它状态</strong></p><p>3、将所有状态连接完毕后，点击Animator窗口左侧的Parameters(参数页签)，为这些状态<strong>添加切换条件</strong></p></blockquote><h3 id="06-代码实现移动动画-amp-amp-人物反转"><a href="#06-代码实现移动动画-amp-amp-人物反转" class="headerlink" title="06 代码实现移动动画&amp;&amp;人物反转"></a>06 代码实现移动动画&amp;&amp;人物反转</h3><p>连接Idel和Run两个状态后，在它们的参数页签添加一个<strong>float</strong>类型的参数。</p><p>参数大小设置为<strong>0.1</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Playermove</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> runSpeed = <span class="number">1</span>;  <span class="comment">//移动时的速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> upForce = <span class="number">3</span>; <span class="comment">//跳跃时向上的力</span></span><br><span class="line">    <span class="keyword">public</span> LayerMask ground;    <span class="comment">//地面</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> isGround;  <span class="comment">//判断是否在地面，用于锁定跳跃输入 </span></span><br><span class="line">    <span class="built_in">float</span> direction;    <span class="comment">//方向</span></span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D rb;</span><br><span class="line">    <span class="keyword">private</span> Animator animator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//获取刚体组件</span></span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FixedUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Move();</span><br><span class="line">        Jump();</span><br><span class="line">        MyAnimator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Move</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//获取按键时的水平方向</span></span><br><span class="line">        direction = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (direction != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当按键时，水平方向就有一个速度，竖直方向上的速度来自于重力</span></span><br><span class="line">            rb.velocity = <span class="keyword">new</span> Vector2(runSpeed * direction, rb.velocity.y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实现人物反转</span></span><br><span class="line">        <span class="keyword">if</span> (direction &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.transform.rotation = Quaternion.AngleAxis(<span class="number">-180</span>, Vector2.up);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(direction &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.transform.rotation = Quaternion.AngleAxis(<span class="number">0</span>, Vector2.up);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Jump</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        isGround = rb.IsTouchingLayers(ground); <span class="comment">//检测人物是否接触地面</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space) &amp;&amp; isGround)<span class="comment">//按下空格，并且人物在地面上</span></span><br><span class="line">        &#123;</span><br><span class="line">            rb.AddForce(<span class="keyword">new</span> Vector2(<span class="number">0</span>, upForce), ForceMode2D.Impulse);<span class="comment">//给刚体一个向上的力</span></span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MyAnimator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//移动动画</span></span><br><span class="line">        animator.SetFloat(<span class="string">&quot;IsRun&quot;</span>, Mathf.Abs(direction));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>用键盘的AD键利用SetBool方法播放动画，可能会导致人物在移动结束时”滑步“</p></blockquote><h3 id="07-代码实现跳跃-amp-amp-下落"><a href="#07-代码实现跳跃-amp-amp-下落" class="headerlink" title="07 代码实现跳跃&amp;&amp;下落"></a>07 代码实现跳跃&amp;&amp;下落</h3><p>最终连接状态图如下：</p><p><img src="../../../../BaiduNetdiskDownload/JUMP_DEMO.assets/image-20220627085308866.png" alt="image-20220627085308866" style="zoom:150%;" /></p><blockquote><p>其中页签参数为：</p><p>Idel-&gt;Run参数为：IsRun &gt; 0.1</p><p>Run-&gt;Idel参数为：IsRun &lt; 0.1</p><p>Run-&gt;Jump参数为：Jump为true</p><p>Idel-&gt;Jump参数为：Jump为true</p><p>Jump-&gt;Fall参数为：IsFall为true，Jump为false(这里若无，则会一直卡在Jump状态)</p><p>Fall-&gt;Idel参数为：IsIdel为true，IsFall为false(这里若无，则会一直卡在Fall状态)</p></blockquote><p>注意：若是出现卡在一个状态不动的情况，可以试试同时将上一个状态改为false</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">move</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> runSpeed = <span class="number">1</span>;  <span class="comment">//移动时的速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> upForce = <span class="number">3</span>; <span class="comment">//跳跃时向上的力</span></span><br><span class="line">    <span class="keyword">public</span> LayerMask ground;    <span class="comment">//地面</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> isGround;  <span class="comment">//判断是否在地面，用于锁定跳跃输入 </span></span><br><span class="line">    <span class="built_in">float</span> direction;    <span class="comment">//方向</span></span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D rb;</span><br><span class="line">    <span class="keyword">private</span> Animator animator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//获取刚体组件</span></span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Move();</span><br><span class="line">        Jump();</span><br><span class="line">        MyAnimator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Move</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//获取按键时的水平方向</span></span><br><span class="line">        direction = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (direction != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当按键时，水平方向就有一个速度，竖直方向上的速度来自于重力</span></span><br><span class="line">            rb.velocity = <span class="keyword">new</span> Vector2(runSpeed * direction, rb.velocity.y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实现人物反转</span></span><br><span class="line">        <span class="keyword">if</span> (direction &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.transform.rotation = Quaternion.AngleAxis(<span class="number">-180</span>, Vector2.up);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (direction &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.transform.rotation = Quaternion.AngleAxis(<span class="number">0</span>, Vector2.up);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Jump</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        isGround = rb.IsTouchingLayers(ground); <span class="comment">//检测人物是否接触地面</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space) &amp;&amp; isGround)<span class="comment">//按下空格，并且人物在地面上</span></span><br><span class="line">        &#123;</span><br><span class="line">            rb.AddForce(<span class="keyword">new</span> Vector2(<span class="number">0</span>, upForce), ForceMode2D.Impulse);<span class="comment">//给刚体一个向上的力</span></span><br><span class="line">            animator.SetBool(<span class="string">&quot;IsJump&quot;</span>,<span class="literal">true</span>);    <span class="comment">//播放跳跃动画</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MyAnimator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//移动动画</span></span><br><span class="line">        animator.SetFloat(<span class="string">&quot;IsRun&quot;</span>, Mathf.Abs(direction));</span><br><span class="line">        <span class="comment">//下落动画</span></span><br><span class="line">        <span class="keyword">if</span> (rb.velocity.y &lt; <span class="number">0.1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            animator.SetBool(<span class="string">&quot;IsFall&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            animator.SetBool(<span class="string">&quot;IsJump&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isGround)</span><br><span class="line">        &#123;</span><br><span class="line">            animator.SetBool(<span class="string">&quot;IsIdel&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            animator.SetBool(<span class="string">&quot;IsFall&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="08-摄像机跟随"><a href="#08-摄像机跟随" class="headerlink" title="08 摄像机跟随"></a>08 摄像机跟随</h3><h4 id="方法1：让相机成为人物的子对象"><a href="#方法1：让相机成为人物的子对象" class="headerlink" title="方法1：让相机成为人物的子对象"></a>方法1：让相机成为人物的子对象</h4><p>这种方法简单便捷，但有个很明显的问题，它会一直跟着人物移动。若人物掉出了地图，相机也会跟着人物一起掉出地图</p><h4 id="方法2：Cinemachine实现跟随"><a href="#方法2：Cinemachine实现跟随" class="headerlink" title="方法2：Cinemachine实现跟随"></a>方法2：Cinemachine实现跟随</h4><p>Cinemachine插件安装</p><blockquote><p>1、打开Window-&gt;Packges Mangener</p><p>2、将My Assets改为Unity Registry</p><p>3、在搜索框中搜索Cinemachine完成安装</p><p>4、之后Cniemachine就会出现在上方的菜单栏</p></blockquote><p>Cinemachine创建</p><blockquote><p>1、点击菜单栏中的Cniemachine，创建一个2D Camera</p><p>2、此时Hierarchy窗口中会出现一个CM vcam1对象</p><p>3、我们将人物对象拖动到CM对象上的Follow参数中，让CM跟随人物</p></blockquote><p>Cinemachine参数</p><blockquote><p>1、在Lens参数下的Orthograpgic Size中，可以设置<strong>相机视口的大小</strong></p><p>2、Body参数默认为<strong>Framing Transpo</strong></p><p>3、红色区域为禁止区，人物肯定不能到达的地方</p><p>4、蓝色区域为缓冲区，人物能够到达的范围，，在<strong>Soft Zone</strong>设置大小</p><p>5、在Framing Transpo参数下，设置<strong>Dead Zone</strong>的大小，可以为人物设置一个安全区，在范围内，相机不跟随移动</p><p>6、在Framing Transpo参数下，设置Screen X 或 Y的大小，可以设置相机的偏移位置    </p><p>7、Damping参数可以设置相机跟随时的阻尼</p></blockquote><h4 id="限制相机在背景中移动"><a href="#限制相机在背景中移动" class="headerlink" title="限制相机在背景中移动"></a>限制相机在背景中移动</h4><blockquote><p>1、在CM对象中找到Add Extension，点击select为其添加<strong>Cinemachine Confiner</strong>组件</p><p>2、为背景对象添加Polygon Collider2D(多边形碰撞体),并编辑碰撞范围，且勾上IsTrigger</p><p>3、将背景对象拖动到<strong>Cinemachine Confiner</strong>组件中的Bounding Shape 2D参数中即可</p></blockquote><p>注意：这样做的好处是，<strong>当人物掉出地图外时，相机不会跟着一起出去</strong></p><h3 id="09-物品收集"><a href="#09-物品收集" class="headerlink" title="09 物品收集"></a>09 物品收集</h3><h4 id="创建物品"><a href="#创建物品" class="headerlink" title="创建物品"></a>创建物品</h4><blockquote><p>1、创建一个2D sprite</p><p>2、将默认的物体图片关联sprite</p><p>3、为物品创建动画</p><p>4、为物品创建碰撞体，并编辑碰撞体，且勾选IsTrigger</p><p>5、为物品添加一个Tag标签</p><p>6、使用触发检测检查是否与该标签的物体接触</p></blockquote><h4 id="用代码销毁物品"><a href="#用代码销毁物品" class="headerlink" title="用代码销毁物品"></a>用代码销毁物品</h4><p>将脚本挂载在<strong>人物</strong>身上</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Fruits</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> apple = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//触发函数</span></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> Text appleText;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (collision.tag == <span class="string">&quot;Apple&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(collision.gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="将物品设置为预设体"><a href="#将物品设置为预设体" class="headerlink" title="将物品设置为预设体"></a>将物品设置为预设体</h4><blockquote><p>1、在Assect文件夹下创建一个Prefabs文件夹，用来存放预设体</p><p>2、将想要制作成预设体的物体拖入文件夹中即可</p><p>注意；若想要取消预设体，则需要删除预设体文件夹中的文件，选中当前对象，右键Unpack prefab</p></blockquote><h3 id="10-避免卡墙-amp-amp-空中多段跳"><a href="#10-避免卡墙-amp-amp-空中多段跳" class="headerlink" title="10 避免卡墙&amp;&amp;空中多段跳"></a>10 避免卡墙&amp;&amp;空中多段跳</h3><p>通过为人物的碰撞器添加物理材质，来达到避免卡墙的效果</p><blockquote><p>1、在Assects文件夹下创建一个Material(材质)文件夹</p><p>2、在Material文件夹下创建一个Physics Material 2D文件，将其的Friction(摩擦力系数)改为0</p><p>3、将Physics Material 2D拖动到地形碰撞器的Material参数中</p></blockquote><h4 id="空中多段跳"><a href="#空中多段跳" class="headerlink" title="空中多段跳"></a>空中多段跳</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">move</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> runSpeed = <span class="number">1</span>;  <span class="comment">//移动时的速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> upForce = <span class="number">3</span>; <span class="comment">//跳跃时向上的力</span></span><br><span class="line">    <span class="keyword">public</span> LayerMask ground;    <span class="comment">//地面</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> jumpCount = <span class="number">2</span>;  <span class="comment">//最大跳跃次数</span></span><br><span class="line">    <span class="built_in">bool</span> isGround;  <span class="comment">//判断是否在地面，用于锁定跳跃输入 </span></span><br><span class="line">    <span class="built_in">float</span> direction;    <span class="comment">//方向</span></span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D rb;</span><br><span class="line">    <span class="keyword">private</span> Animator animator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//获取刚体组件</span></span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Move();</span><br><span class="line">        Jump();</span><br><span class="line">        MyAnimator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Move</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//获取按键时的水平方向</span></span><br><span class="line">        direction = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (direction != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当按键时，水平方向就有一个速度，竖直方向上的速度来自于重力</span></span><br><span class="line">            rb.velocity = <span class="keyword">new</span> Vector2(runSpeed * direction, rb.velocity.y);</span><br><span class="line">            <span class="comment">//防止摩擦力为0时自动移动的情况</span></span><br><span class="line">            <span class="keyword">if</span>(Mathf.Abs(rb.velocity.x) &lt; <span class="number">0.1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                rb.velocity = <span class="keyword">new</span> Vector2(<span class="number">0</span>,rb.velocity.y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实现人物反转</span></span><br><span class="line">        <span class="keyword">if</span> (direction &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.transform.rotation = Quaternion.AngleAxis(<span class="number">-180</span>, Vector2.up);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (direction &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.transform.rotation = Quaternion.AngleAxis(<span class="number">0</span>, Vector2.up);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Jump</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        isGround = rb.IsTouchingLayers(ground); <span class="comment">//检测人物是否接触地面</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space) &amp;&amp; jumpCount &gt; <span class="number">0</span> &amp;&amp; rb.velocity.y &gt; <span class="number">-0.01</span>)<span class="comment">//按下空格，跳跃次数大于0,且人物不下落</span></span><br><span class="line">        &#123;</span><br><span class="line">            rb.AddForce(<span class="keyword">new</span> Vector2(<span class="number">0</span>, upForce), ForceMode2D.Impulse);<span class="comment">//给刚体一个向上的力</span></span><br><span class="line">            animator.SetBool(<span class="string">&quot;IsJump&quot;</span>, <span class="literal">true</span>);    <span class="comment">//播放跳跃动画</span></span><br><span class="line">            jumpCount--;</span><br><span class="line">            print(<span class="string">&quot;跳起来&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rb.velocity.y &lt; <span class="number">0.01</span> &amp;&amp; rb.velocity.y &gt; <span class="number">-0.01</span>)   <span class="comment">//此处若是用IsGround判断，容易出现在jumpCount--的瞬间，jumpCount = 2 </span></span><br><span class="line">        &#123;</span><br><span class="line">            jumpCount = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MyAnimator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//移动动画</span></span><br><span class="line">        animator.SetFloat(<span class="string">&quot;IsRun&quot;</span>, Mathf.Abs(direction));</span><br><span class="line">        <span class="comment">//下落动画</span></span><br><span class="line">        <span class="keyword">if</span> (rb.velocity.y &lt; <span class="number">0.1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            animator.SetBool(<span class="string">&quot;IsFall&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            animator.SetBool(<span class="string">&quot;IsJump&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isGround)</span><br><span class="line">        &#123;</span><br><span class="line">            animator.SetBool(<span class="string">&quot;IsIdel&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            animator.SetBool(<span class="string">&quot;IsFall&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>可以将IsGround判断替换为-0.01&lt;rb.velocity.y &lt; 0.01</p><p>这样可以理解为站在平台上</p><p>当摩擦力设置为0时，可能会出现人物自动缓慢移动</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加如下代码，防止摩擦力为0时自动移动的情况</span></span><br><span class="line"><span class="keyword">if</span>(Mathf.Abs(rb.velocity.x) &lt; <span class="number">0.1</span>)</span><br><span class="line">&#123;</span><br><span class="line">rb.velocity = <span class="keyword">new</span> Vector2(<span class="number">0</span>,rb.velocity.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><hr><h3 id="11-设计UI统计分数"><a href="#11-设计UI统计分数" class="headerlink" title="11 设计UI统计分数"></a>11 设计UI统计分数</h3><p>通过UGUI中的Text组件，来显示人物获取的分数</p><blockquote><p>1、在Hierarchy窗口中，右键鼠标，在下拉菜单中选中UI，点击创建Panel对象</p><p>2、再从UI中创建一个Text对象作为Panel的子对象</p><p><strong>3、</strong>将Canvas对象身上的Canvas Scaler组件上的UI渲染模式，改为Scale With Screen Size</p><p><strong>4、</strong>若是横屏游戏，还要将Canvas Scaler组件上的Match拖动到1</p><p>5、找到Text对象，在Text组件的Font参数中设置字体，在Font size中设置字体大小</p><p>6、将Text对象拖动到合适的位置</p><p>7、也可以添加一个image，将素材放到分数旁边</p></blockquote><p>通过代码更新分数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Fruits</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> apple = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//触发函数</span></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> Text appleText;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (collision.tag == <span class="string">&quot;Apple&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(collision.gameObject);</span><br><span class="line">            apple++;</span><br><span class="line">            appleText.text = <span class="string">&quot;Apple:&quot;</span> + apple;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码中要引入UnityEngine.UI</p><p>这里要注意，要将Text对象关联到脚本上的appleText参数中</p><p>如果面版发灰，那就选中Panel对象，将其Color的A值，设置为0即可</p></blockquote><h4 id="示例：通过吃道具增加跳跃"><a href="#示例：通过吃道具增加跳跃" class="headerlink" title="示例：通过吃道具增加跳跃"></a>示例：通过吃道具增加跳跃</h4><p>人物移动代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Playermove</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> runSpeed = <span class="number">1</span>;  <span class="comment">//移动时的速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> upForce = <span class="number">3</span>; <span class="comment">//跳跃时向上的力</span></span><br><span class="line">    <span class="keyword">public</span> LayerMask ground;    <span class="comment">//地面</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> jumpCount = <span class="number">1</span>;  <span class="comment">//最大跳跃次数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> nowjump = <span class="number">1</span>;<span class="comment">//现在跳跃次数</span></span><br><span class="line">    <span class="built_in">bool</span> isGround;  <span class="comment">//判断是否在地面，用于锁定跳跃输入 </span></span><br><span class="line">    <span class="built_in">float</span> direction;    <span class="comment">//方向</span></span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D rb;</span><br><span class="line">    <span class="keyword">private</span> Animator animator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//获取刚体组件</span></span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Move();</span><br><span class="line">        Jump();</span><br><span class="line">        MyAnimator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Move</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//获取按键时的水平方向</span></span><br><span class="line">        direction = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (direction != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当按键时，水平方向就有一个速度，竖直方向上的速度来自于重力</span></span><br><span class="line">            rb.velocity = <span class="keyword">new</span> Vector2(runSpeed * direction, rb.velocity.y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实现人物反转</span></span><br><span class="line">        <span class="keyword">if</span> (direction &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.transform.rotation = Quaternion.AngleAxis(<span class="number">-180</span>, Vector2.up);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (direction &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.transform.rotation = Quaternion.AngleAxis(<span class="number">0</span>, Vector2.up);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Jump</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        isGround = rb.IsTouchingLayers(ground); <span class="comment">//检测人物是否接触地面</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space) &amp;&amp; jumpCount &gt; <span class="number">0</span> &amp;&amp; rb.velocity.y &gt; <span class="number">-0.01</span>)<span class="comment">//按下空格，跳跃次数大于0,且人物不下落</span></span><br><span class="line">        &#123;</span><br><span class="line">            rb.AddForce(<span class="keyword">new</span> Vector2(<span class="number">0</span>, upForce), ForceMode2D.Impulse);<span class="comment">//给刚体一个向上的力</span></span><br><span class="line">            animator.SetBool(<span class="string">&quot;IsJump&quot;</span>, <span class="literal">true</span>);    <span class="comment">//播放跳跃动画</span></span><br><span class="line">            jumpCount--;</span><br><span class="line">            print(<span class="string">&quot;跳起来&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rb.velocity.y &lt; <span class="number">0.01</span> &amp;&amp; rb.velocity.y &gt; <span class="number">-0.01</span>)   <span class="comment">//此处若是用IsGround判断，容易出现在jumpCount--的瞬间，jumpCount = 2 </span></span><br><span class="line">        &#123;</span><br><span class="line">            jumpCount = nowjump;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MyAnimator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//移动动画</span></span><br><span class="line">        animator.SetFloat(<span class="string">&quot;IsRun&quot;</span>, Mathf.Abs(direction));</span><br><span class="line">        <span class="comment">//下落动画</span></span><br><span class="line">        <span class="keyword">if</span> (rb.velocity.y &lt; <span class="number">0.1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            animator.SetBool(<span class="string">&quot;IsFall&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            animator.SetBool(<span class="string">&quot;IsJump&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isGround)</span><br><span class="line">        &#123;</span><br><span class="line">            animator.SetBool(<span class="string">&quot;IsIdel&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            animator.SetBool(<span class="string">&quot;IsFall&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>道具销毁增加跳跃代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Fruits</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    Playermove pm;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//获取人物脚本</span></span><br><span class="line">        pm = GameObject.Find(<span class="string">&quot;Player&quot;</span>).GetComponent&lt;Playermove&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> apple = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//触发函数</span></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> Text appleText;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (collision.tag == <span class="string">&quot;Apple&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(collision.gameObject);</span><br><span class="line">            apple++;</span><br><span class="line">            appleText.text = <span class="string">&quot;Apple:&quot;</span> + apple;</span><br><span class="line">            pm.nowjump = <span class="number">2</span>;<span class="comment">//现在能跳两次</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>在不同游戏对象中一个脚本中获取另一个脚本属性或者方法的情况</p><p>1、在一个脚本中public 脚本名 obj，然后在面版上拖动对象。</p><p>obj.变量。即可获得·</p><p>2、脚本名 obj = GetGameObject.Find(“对象名”).GetComponent&lt;脚本&gt;().变量</p><p>3、脚本名 obj = GameObject.FindGameObjectWithTag(“标签名”).GetComponent&lt;脚本&gt;().变量</p><p>同一个游戏对象中获取另一个脚本方法</p><p>脚本名 obj = GetComponent&lt;脚本名&gt;();</p></blockquote><hr><h3 id="12-设计陷阱-amp-amp-死亡动画"><a href="#12-设计陷阱-amp-amp-死亡动画" class="headerlink" title="12 设计陷阱&amp;&amp;死亡动画"></a>12 设计陷阱&amp;&amp;死亡动画</h3><p>添加死亡动画</p><blockquote><p>1、选中人物，点击Animation窗口，Create New Cilp</p><p>2、选择保存路径，找到该路径下的文件，设置帧数</p><p>3、将素材拖到时间轴中</p><p>4、由于素材是受伤动画，所以在最后一帧，要自己录制Sprite Renderer的组件失活关键帧</p><p>5、在动画状态机中，Any State状态都可以到Dead状态</p><p>6、在状态机的Parametes条件页签中，添加Trigger条件，并且将退出时间设置为0</p></blockquote><p>通过为陷阱添加碰撞体，并添加碰撞检测函数实现功能</p><blockquote><p>1、创建陷阱预设体</p><ul><li>创建一个2D Sprite，将图片与其关联，并在Transform中置零</li><li>在Sprite Renderer中找到Sorting Layer参数，添加一个Trap层级</li></ul><p>2、为陷阱添加Box Collider 2D，并编辑碰撞器到合适大小</p><ul><li>之后将陷阱移动到Prefabs，创建预设体即可</li></ul><p>3、创建一个脚本，用代码完成碰撞检测函数，以及播放死亡动画</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Playerdie</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    Rigidbody2D rb2D;</span><br><span class="line">    Animator animator;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        rb2D = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionEnter2D</span>(<span class="params">Collision2D collision</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span>(collision.gameObject.tag == <span class="string">&quot;Trap&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Dead();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dead</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//人物碰到陷阱时应该不能动了，所以将刚体设置为静止</span></span><br><span class="line">        rb2D.bodyType = RigidbodyType2D.Static;</span><br><span class="line">        animator.SetTrigger(<span class="string">&quot;IsDead&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>1、2D刚体中，将Body Type参数改为Static，就会变为静态刚体</p><p><strong>物体不会动也不受力，只会进行碰撞检测</strong></p><p>2、当人物身上挂在的脚本过多，人物死亡时就不宜直接Destory，而是通过死亡动画将人物隐藏，并通过修改刚体类型限制其移动</p></blockquote><h3 id="13-死亡后重新加载场景"><a href="#13-死亡后重新加载场景" class="headerlink" title="13 死亡后重新加载场景"></a>13 死亡后重新加载场景</h3><p>通过SceneManager 触碰陷阱时重新加载场景</p><blockquote><p>1、在脚本中其中引入using UnityEngine.SceneManagement命名空间</p><p>2、编写触碰陷阱时重新加载场景代码</p><p>3、在人物死亡动画中添加帧事件(将时间轴移动到对应的帧数上，点击add event)，死亡时调用重新加载场景函数</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.SceneManagement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Playerdie</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    Rigidbody2D rb2D;</span><br><span class="line">    Animator animator;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        rb2D = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionEnter2D</span>(<span class="params">Collision2D collision</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//触碰陷阱</span></span><br><span class="line">        <span class="keyword">if</span>(collision.gameObject.tag == <span class="string">&quot;Trap&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Dead();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dead</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//人物碰到陷阱时应该不能动了，所以将刚体设置为静止</span></span><br><span class="line">        rb2D.bodyType = RigidbodyType2D.Static;</span><br><span class="line">        animator.SetTrigger(<span class="string">&quot;IsDead&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新加载场景函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Restart</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">     <span class="comment">//重新加载当前激活的场景</span></span><br><span class="line">SceneManager.LoadScene(SceneManager.GetActiveScene().name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过SceneManager 掉落地图时重新加载场景</p><blockquote><p>1、在背景图边缘的碰撞器旁边新增一个空物体DieLine，为其增加一个<strong>Edge 碰撞体</strong>，<strong>勾选IsTrigger</strong>，用于制作死亡线</p><p>2、为DieLine添加一个标签，方便进行触发检测</p><p>3、在脚本中添加触发检测函数</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.SceneManagement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Playerdie</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    Rigidbody2D rb2D;</span><br><span class="line">    Animator animator;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        rb2D = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionEnter2D</span>(<span class="params">Collision2D collision</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//触碰陷阱</span></span><br><span class="line">        <span class="keyword">if</span>(collision.gameObject.tag == <span class="string">&quot;Trap&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Dead();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//掉出地图</span></span><br><span class="line">        <span class="keyword">if</span> (collision.tag == <span class="string">&quot;DieLine&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Invoke(<span class="string">&quot;Restart&quot;</span>, <span class="number">0.5f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dead</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//人物碰到陷阱时应该不能动了，所以将刚体设置为静止</span></span><br><span class="line">        rb2D.bodyType = RigidbodyType2D.Static;</span><br><span class="line">        animator.SetTrigger(<span class="string">&quot;IsDead&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新加载场景函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Restart</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//重新加载当前激活的场景</span></span><br><span class="line">        SceneManager.LoadScene(SceneManager.GetActiveScene().name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="14-创建敌人"><a href="#14-创建敌人" class="headerlink" title="14 创建敌人"></a>14 创建敌人</h3><p>1、在资源商店中下载素材 并导入</p><p>2、创建一个敌人</p><blockquote><p>1、创建一个2D Sprite对象，命名为Enemy</p><p>2、将人物素材的<strong>Pixels Per Unit</strong> 改为16像素</p><p>3、找到Sprite Remderer组件，将敌人待机图片拖动到Sprite参数中</p><p>4、选中Enemy对象，在Sorting Layer中添加一个新的Enemy图层，更改敌人图层后，就能显示在最前方</p></blockquote><p>3、为碰撞器并编辑到合适大小</p><p>4、设计Enmey脚本，为敌人添加Enmey标签，当人物碰撞到敌人时，人物死亡并重新加载场景</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    Animator animator;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//敌人死亡</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dead</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Destroy(<span class="keyword">this</span>.gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Playermove</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Enemy enemy;</span><br><span class="line">    <span class="keyword">public</span> Playerdie pd;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> runSpeed = <span class="number">1</span>;  <span class="comment">//移动时的速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> upForce = <span class="number">3</span>; <span class="comment">//跳跃时向上的力</span></span><br><span class="line">    <span class="keyword">public</span> LayerMask ground;    <span class="comment">//地面</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> jumpCount = <span class="number">1</span>;  <span class="comment">//最大跳跃次数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> nowjump = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">bool</span> isGround;  <span class="comment">//判断是否在地面，用于锁定跳跃输入 </span></span><br><span class="line">    <span class="built_in">float</span> direction;    <span class="comment">//方向</span></span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D rb;</span><br><span class="line">    <span class="keyword">private</span> Animator animator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//获取刚体组件</span></span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">        pd = GetComponent&lt;Playerdie&gt;(); <span class="comment">//获取人物死亡脚本</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Move();</span><br><span class="line">        Jump();</span><br><span class="line">        MyAnimator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Move</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//获取按键时的水平方向</span></span><br><span class="line">        direction = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (direction != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当按键时，水平方向就有一个速度，竖直方向上的速度来自于重力</span></span><br><span class="line">            rb.velocity = <span class="keyword">new</span> Vector2(runSpeed * direction, rb.velocity.y);</span><br><span class="line">            <span class="comment">//防止摩擦力为0时自动移动的情况</span></span><br><span class="line">            <span class="keyword">if</span>(Mathf.Abs(rb.velocity.x) &lt; <span class="number">0.1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                rb.velocity = <span class="keyword">new</span> Vector2(<span class="number">0</span>,rb.velocity.y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实现人物反转</span></span><br><span class="line">        <span class="keyword">if</span> (direction &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.transform.rotation = Quaternion.AngleAxis(<span class="number">-180</span>, Vector2.up);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (direction &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.transform.rotation = Quaternion.AngleAxis(<span class="number">0</span>, Vector2.up);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Jump</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        isGround = rb.IsTouchingLayers(ground); <span class="comment">//检测人物是否接触地面</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space) &amp;&amp; jumpCount &gt; <span class="number">0</span> &amp;&amp; rb.velocity.y &gt; <span class="number">-0.01</span>)<span class="comment">//按下空格，跳跃次数大于0,且人物不下落</span></span><br><span class="line">        &#123;</span><br><span class="line">            rb.AddForce(<span class="keyword">new</span> Vector2(<span class="number">0</span>, upForce), ForceMode2D.Impulse);<span class="comment">//给刚体一个向上的力</span></span><br><span class="line">            animator.SetBool(<span class="string">&quot;IsJump&quot;</span>, <span class="literal">true</span>);    <span class="comment">//播放跳跃动画</span></span><br><span class="line">            jumpCount--;</span><br><span class="line">            print(<span class="string">&quot;跳起来&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rb.velocity.y &lt; <span class="number">0.01</span> &amp;&amp; rb.velocity.y &gt; <span class="number">-0.01</span>)   <span class="comment">//此处若是用IsGround判断，容易出现在jumpCount--的瞬间，jumpCount = 2 </span></span><br><span class="line">        &#123;</span><br><span class="line">            jumpCount = nowjump;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//碰撞检测</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">OnCollisionEnter2D</span>(<span class="params">Collision2D collision</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (collision.gameObject.tag == <span class="string">&quot;Enemy&quot;</span>)</span><br><span class="line">        &#123;<span class="comment">//人物下落，消灭敌人</span></span><br><span class="line">            <span class="keyword">if</span> (animator.GetBool(<span class="string">&quot;IsFall&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                enemy.Dead();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//人物碰撞敌人，人物死亡</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pd.Dead();</span><br><span class="line">                pd.Restart();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MyAnimator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//移动动画</span></span><br><span class="line">        animator.SetFloat(<span class="string">&quot;IsRun&quot;</span>, Mathf.Abs(direction));</span><br><span class="line">        <span class="comment">//下落动画</span></span><br><span class="line">        <span class="keyword">if</span> (rb.velocity.y &lt; <span class="number">0.1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            animator.SetBool(<span class="string">&quot;IsFall&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            animator.SetBool(<span class="string">&quot;IsJump&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isGround)</span><br><span class="line">        &#123;</span><br><span class="line">            animator.SetBool(<span class="string">&quot;IsIdel&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            animator.SetBool(<span class="string">&quot;IsFall&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="15-切换创建且保存数据"><a href="#15-切换创建且保存数据" class="headerlink" title="15 切换创建且保存数据"></a>15 切换创建且保存数据</h3><p>1、使用DontDestoryOnLoad方法</p><blockquote><p>在游戏对象身上挂在一个脚本，在Start方法中写</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DontDestroyOnLoad(gameObject);</span><br><span class="line"><span class="comment">//即过场景时不销毁游戏对象</span></span><br></pre></td></tr></table></figure></blockquote><p>2、使用PlayerPrefs将数据保存在本地，到了新场景时再将数据读出来</p><blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PlayerPrefs.SetInt(<span class="string">&quot;appleNums&quot;</span>,<span class="number">10</span>);</span><br><span class="line">PlayerPrefs.GetInt(<span class="string">&quot;appleNums&quot;</span>);</span><br></pre></td></tr></table></figure></blockquote><p>3、使用单例模式</p><p>自己设计一个class，把要存储并传递的变量做成public static变量，也不需要实例化类，跳转后直接读取就行了</p><blockquote><p>实现步骤：</p><p>创建空物体GlobalObject</p><p>创建GlobalControl C#脚本</p><p>将脚本赋给GlobalObject</p></blockquote><h3 id="16-制作简易道具栏"><a href="#16-制作简易道具栏" class="headerlink" title="16 制作简易道具栏"></a>16 制作简易道具栏</h3><h4 id="创建背景栏UI"><a href="#创建背景栏UI" class="headerlink" title="创建背景栏UI"></a>创建背景栏UI</h4><blockquote><p>1、在Canvas面版中添加一个Image，为其命名为Slots，并且关联道具栏图片</p><p>2、选中图片对象，点击Rect Transform中的center参数，按住ait建，可以将图片和锚点同时移动到合适的位置</p></blockquote><h4 id="创建道具UI"><a href="#创建道具UI" class="headerlink" title="创建道具UI"></a>创建道具UI</h4><blockquote><p>1、在Canvas面版中再创建一个Image，为其命名为Banana，并且关联相应的图片</p><p>2、为其添加Button组件，并拖拽到预设体的文件夹中</p><p>3、删除原来场景中的图片对象，</p><p>注意：该对象是通过动态创建来点击的，而不是直接放在场景中的，场景中的道具还需要另外添加</p></blockquote><h4 id="声明数组存储道具"><a href="#声明数组存储道具" class="headerlink" title="声明数组存储道具"></a>声明数组存储道具</h4><p>1、新建一个Bag脚本，在其中创建一个数组作为容器用来存放道具</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">bag</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span>[ ] isFull;   <span class="comment">//检查背包是否装满</span></span><br><span class="line">    <span class="keyword">public</span> GameObject[] slots;  <span class="comment">//用来存放捡起的物体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、在Bag脚本界面，为Is Full 和 Slotes添加大小。并且把之前的图片对象<strong>Slots拖拽到Element参数中</strong></p><h4 id="为道具添加拾取功能"><a href="#为道具添加拾取功能" class="headerlink" title="为道具添加拾取功能"></a>为道具添加拾取功能</h4><p>1、创建一个Pickup脚本</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Pickup</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    bag bag;<span class="comment">//声明bag脚本</span></span><br><span class="line">    <span class="keyword">public</span> GameObject itemButton;<span class="comment">//用于动态创建需要使用的道具</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//获取人物对象上的bag脚本</span></span><br><span class="line">        bag = GameObject.FindGameObjectWithTag(<span class="string">&quot;Player&quot;</span>).GetComponent&lt;bag&gt;();  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span>(collision.gameObject.tag == <span class="string">&quot;Player&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; bag.slots.Length; i++)  <span class="comment">//检查背包中是否有空余位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(bag.isFull[i] == <span class="literal">false</span>)  <span class="comment">//检测当前背包是否被装满</span></span><br><span class="line">                &#123;</span><br><span class="line">                    bag.isFull[i] = <span class="literal">true</span>;</span><br><span class="line">                    Instantiate(itemButton, bag.slots[i].transform,<span class="literal">false</span>);<span class="comment">//将预制体生成在背包的位置，坐标为当前坐标系下</span></span><br><span class="line">                    Destroy(gameObject);<span class="comment">//销毁当前游戏道具</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="创建道具预设体"><a href="#创建道具预设体" class="headerlink" title="创建道具预设体"></a>创建道具预设体</h4><blockquote><p>1、先创建一个2D sprite，为其命名为Banana_Pickup。并为其关联道具图片</p><p>2、为该对象添加碰撞器</p><p>3、将Pickup脚本挂载到该对象上，并将之前创建道具UI预设体拖拽到itemButton参数中</p><p>4、将Banana_Pickup对象拖拽到预制体文件夹中，方便快速布置场景</p><p>注意：这里的道具是实际上布置在场景中的道具，而上述的道具则是通过预设体创建在道具栏中的道具</p></blockquote><h4 id="为道具UI添加点击事件"><a href="#为道具UI添加点击事件" class="headerlink" title="为道具UI添加点击事件"></a>为道具UI添加点击事件</h4><p>点击道具时增加跳跃功能</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JumpAdd</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Button btn;</span><br><span class="line">    <span class="keyword">private</span> Playermove pm;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        btn = GetComponent&lt;Button&gt;();</span><br><span class="line">        pm = GameObject.Find(<span class="string">&quot;Player&quot;</span>).GetComponent&lt;Playermove&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        btn.onClick.AddListener(ClickBtn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ClickBtn</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        pm.nowjump++;</span><br><span class="line">        Destroy(<span class="keyword">this</span>.gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="17-平台移动"><a href="#17-平台移动" class="headerlink" title="17 平台移动"></a>17 平台移动</h3><h4 id="创建平台素材"><a href="#创建平台素材" class="headerlink" title="创建平台素材"></a>创建平台素材</h4><blockquote><p>1、创建2D Sprite,命名为Platforms，为其关联平台素材。并设置其Sorting Layer为Frontground</p><p>2、为平台创建动画，在Debug模式中设置帧率</p><p>3、为平台设置两个碰撞体，处于上方的碰撞体勾选触发，下方的碰撞体用于角色站立</p><p>注意：如果出现人物”黏在”平台上的情况，那可能是触发检测的范围太大了</p></blockquote><h4 id="设置平台移动的范围"><a href="#设置平台移动的范围" class="headerlink" title="设置平台移动的范围"></a>设置平台移动的范围</h4><blockquote><p>1、创建两个空物体，并为它们添加标记</p></blockquote><h4 id="利用脚本实现平台来回移动"><a href="#利用脚本实现平台来回移动" class="headerlink" title="利用脚本实现平台来回移动"></a>利用脚本实现平台来回移动</h4><p>利用Vector3.MoveTowards方法实现平台来回移动</p><blockquote><p>用法：从当前位置移动到指定位置</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">move</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> moveSpeed = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> GameObject[] obj;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//平台中心点，向终点移动</span></span><br><span class="line">        <span class="keyword">this</span>.transform.position = Vector2.MoveTowards(<span class="keyword">this</span>.transform.position,obj[index].transform.position ,moveSpeed * Time.deltaTime);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//平台中心点与点的距离小于1，就切换</span></span><br><span class="line">        <span class="keyword">if</span>(Vector2.Distance(transform.position,obj[index].transform.position) &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span>(index &gt;= obj.Length)</span><br><span class="line">            &#123;</span><br><span class="line">                index = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                index = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：次数还可以增加一个等待时间的变量，让平台到达指定地点后等待一段时间再运动</p></blockquote><p>通过将人物添加为平台的子对象来实现人物跟随平台移动</p><blockquote><p>创建PlatformsTrigger脚本，挂载到平台上</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity-UGUI_Demo</title>
      <link href="blog/Unity-UGUI-Demo/"/>
      <url>blog/Unity-UGUI-Demo/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li><p>创建一些重要的文件夹</p><blockquote><p>Resources文件夹用于动态加载</p><p>StreamingAssets文件夹用于存放Json数据文件</p><p>ArtRes文件夹存放艺术资源</p></blockquote></li><li><p>导入Json相关脚本</p><blockquote><p>导入Json脚本后会自动创建Scripts文件夹</p></blockquote></li><li><p>将UI资源导入ArtRes文件夹</p></li><li><p>创建Canvas画布对象</p><blockquote><ol><li>将场景名改为LoginScene用于登入场景</li><li>随便创建一个UI对象，然后将其删除，只保留它的父对象Canvas</li><li>如果有3D模型或粒子特效要显示在前面，要将Canvas组件中的<strong>Render Mode</strong> 改为 <strong>Camera</strong>模式<ol><li>然后在场景当中 右键创建一个摄像机，然后将其<strong>Culling Mask</strong>参数<strong>只渲染UI层</strong>。再将其<strong>Clear Flags</strong>参数只渲染<strong>Depth only</strong>当前层级。最后移除该摄像机上的<strong>Audio Listener</strong>组件(该组件只能有一个)</li><li>选中主摄像机，让其<strong>Culling Mask</strong>参数不渲染UI层。再将其<strong>Clear Flags</strong>参数设置为<strong>Solid Color</strong>,再将背景色设置为纯黑色</li><li>将UI摄像机关联到摄像机模式上，摄像机渲染模式相关内容即可完成</li></ol></li><li>拼面板之前要设置<strong>Canvas Scaler分辨率自适应</strong>相关内容<ol><li>将UI Scale Mode 设置为<strong>Scale With Screen</strong>(缩放模式)</li><li>打开UI资源，打开大图素材，即可看到素材的分辨率</li><li>将Refernce Resolution(参考分辨率)设置为该素材分辨率</li><li>若是横屏游戏，Match要拖动到1。竖屏游戏，Match为0</li></ol></li><li>Canvas准备完毕，之后的面板在Canvas上拼凑即可</li></ol></blockquote></li></ul><p>注意：以下是知识点补充</p><h4 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h4><p>Canvas是画布，它用于渲染自己的所有<strong>UI子对象</strong>，也就是说我们一般会<strong>在画布上进行拼凑面板</strong>，一般一个场景只需要一个画布即可</p><h4 id="Render-Mode"><a href="#Render-Mode" class="headerlink" title="Render Mode"></a>Render Mode</h4><p>Canvas有三种渲染模式，常见的Overlay(覆盖模式),特点是将<strong>UI始终显示在前面</strong>。</p><p>还有Camera(摄像机模式),特点是将<strong>3D模式或粒子特效显示在UI前面</strong></p><h4 id="Canvas-Scaler"><a href="#Canvas-Scaler" class="headerlink" title="Canvas Scaler"></a>Canvas Scaler</h4><p>CanvasScaler是 <strong>画布缩放控制器</strong>，它用于<strong>分辨率自适应组件</strong></p><p>若想要分辨率自适应，就要选择<strong>缩放模式</strong>，<strong>画布随屏幕尺寸进行缩放大小</strong></p><h3 id="面板基类"><a href="#面板基类" class="headerlink" title="面板基类"></a>面板基类</h3><p>用面板基类来描述子类面板的一些共同特点</p><ul><li>显示面板，即动态创建</li><li>隐藏面板，即动态删除</li><li>显示时淡入，隐藏时淡出</li></ul><p>在Scripts中创建一个UI文件夹，并在其中创建一个BasePanel脚本</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将该类设置为抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">BasePanel</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//需要一个整体控制整体画布组淡入淡出的组件</span></span><br><span class="line">    <span class="keyword">private</span> CanvasGroup canvasGroup;</span><br><span class="line">    <span class="comment">//淡入淡出速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> alphaSpeed = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//设置一个是否显示的标识用于判断</span></span><br><span class="line">    <span class="built_in">bool</span> isShow;</span><br><span class="line">    <span class="comment">//当自己淡出成功时，执行的委托函数</span></span><br><span class="line">    UnityAction hideCallBack;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//子类可能会重写父类的方法，所有这里可以设置为虚函数，方便子类重写,添加额外的逻辑</span></span><br><span class="line">    <span class="comment">//Awake中得到CanvasGroup组件。Awake一般也不重写，除非该初始化内容一定要在子类中执行</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//一开始就获取面板 上挂载的组件 </span></span><br><span class="line">        canvasGroup = GetComponent&lt;CanvasGroup&gt;();</span><br><span class="line">        <span class="keyword">if</span>(canvasGroup == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果没有，我们手动通过代码添加</span></span><br><span class="line">            canvasGroup = <span class="keyword">this</span>.gameObject.AddComponent&lt;CanvasGroup&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Start中经常会初始化一些按钮事件的监听等操作</span></span><br><span class="line">    <span class="comment">//所以可以将Start函数设置为抽象函数，让子类必须重写，同时基类写成抽象类</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;       </span><br><span class="line">        Init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这样做的好处是 子类一开始就必须重写Init方法，而不需要重写Start,进行按钮事件监听等初始化操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示面板时 处理的逻辑，其中淡入淡出就要在这里操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ShowMe</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        isShow = <span class="literal">true</span>;</span><br><span class="line">        canvasGroup.alpha = <span class="number">0</span>; <span class="comment">//淡入效果从0开始</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//隐藏面板时 处理的逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">HideMe</span>(<span class="params"> UnityAction callBack</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        isShow = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//淡出效果从1开始</span></span><br><span class="line">        canvasGroup.alpha = <span class="number">1</span>; </span><br><span class="line">        <span class="comment">//记录传入的 当淡出成功后会执行的函数</span></span><br><span class="line">        hideCallBack = callBack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//如果标识为true 且aplha值还没到1。淡入</span></span><br><span class="line">        <span class="keyword">if</span>(isShow &amp;&amp; canvasGroup.alpha != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//alpha逐渐增加</span></span><br><span class="line">            canvasGroup.alpha += alphaSpeed * Time.deltaTime;</span><br><span class="line">            <span class="comment">//若alpha不小心加过头了，直接返回1</span></span><br><span class="line">            <span class="keyword">if</span>(canvasGroup.alpha &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                canvasGroup.alpha = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//淡出</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!isShow)</span><br><span class="line">        &#123;</span><br><span class="line">            canvasGroup.alpha -= alphaSpeed * Time.deltaTime;</span><br><span class="line">            <span class="keyword">if</span>(canvasGroup.alpha &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//为了等待淡出结束后，再删除面板，可以添加一个委托函数。否则就直接将面板删除了</span></span><br><span class="line">                canvasGroup.alpha = <span class="number">0</span>;          </span><br><span class="line">                <span class="comment">//若为空则不会执行，否则会执行</span></span><br><span class="line">                hideCallBack?.Invoke();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：知识点补充</p><p>通过为UI对象添加<strong>Canvas Group</strong>组件</p><p>其<strong>Alpha</strong>参数可以实现<strong>淡入淡出</strong>效果，<strong>Interactable</strong>参数可以实现<strong>UI对象是否禁用</strong></p><blockquote><p>思路：当面板之间切换时，更改Alpha的值</p><p>让Alpha从0~1，可以实现淡入显示面板的功能</p><p>让Alpha从1~0，可以实现淡出隐藏面板的功能</p></blockquote><hr><h3 id="UI管理器"><a href="#UI管理器" class="headerlink" title="UI管理器"></a>UI管理器</h3><p>因为我们的UI面板都是动态的创建和动态删除的，也就是说面板一开始并没在场景上，并不能通过自己来控制显隐</p><p>所以我们为其单独的制作一个UI管理器，将其制作成一个单例模式，用于整体的管理 <strong>显示、隐藏、获取</strong>面板等逻辑</p><ul><li>在UI文件夹下创建一个UIManager脚本</li></ul><blockquote><p>注意：</p><p>这里需要将UICamare 和 EventSyetem拖动到Canvas的子对象</p><p>是为了它们能够过场景中不删除</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、单例模式不需要继承Mono</span></span><br><span class="line"><span class="comment">//2、编写单例模式</span></span><br><span class="line"><span class="comment">//3、创建一个存储面板的容器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIManager</span> </span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一个私有的自己类型的变量</span></span><br><span class="line">    <span class="comment">//没有继承Mono 可以用new实例化对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> UIManager instance = <span class="keyword">new</span> UIManager();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//公共的静态成员属性，去获取私有成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UIManager Instance =&gt; instance;   <span class="comment">//匿名函数的方式获取</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用字典存储面板</span></span><br><span class="line">    <span class="comment">//里氏替换原则，父类装子类，用面板基类替换面板</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Dictionary</span>&lt;<span class="title">string</span>, <span class="title">BasePanel</span>&gt; panelDic</span> = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, BasePanel&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一开始就得到Canvas对象，方便我们将面板设置为它的子对象</span></span><br><span class="line">    <span class="keyword">private</span> Transform canvasTrans;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数写成私有的,避免外部去实例化对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UIManager</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        canvasTrans = GameObject.Find(<span class="string">&quot;Canvas&quot;</span>).transform;<span class="comment">//在构造函数时就去找场景中的Canvas的transform</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 因为再切换场景时，可能会有过渡界面，而它们都是在Canvas。所以要求过场景时不移除</span></span><br><span class="line"><span class="comment">         * 我们都是通过 动态创建 和 动态删除来隐藏面板的，所以过场景不删除它 影响不大</span></span><br><span class="line"><span class="comment">         * **/</span></span><br><span class="line">        GameObject.DontDestroyOnLoad(canvasTrans.gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个UI管理需要提供显示面板、隐藏面板、获得面板等功能</span></span><br><span class="line"><span class="comment">     * 当我们显示一个面板，想要获取它时，这些面板应该要存储到UI管理器中，所以要选择一个存储面板的容器</span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示面板时需要获取面板,只需要保证泛型T的类型和面板名类型一致</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">ShowPanel</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : BasePanel</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//显示面板，就是动态的创建面板预设体 然后设置父对象</span></span><br><span class="line">        <span class="comment">//这里要注意，动态创建的面板是要创建在Canvas下面，所以父对象一定要是Canvas</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> panelName = <span class="keyword">typeof</span>(T).Name; <span class="comment">//typeof(T)获取T的类型, 而typeof(T).name就是类名，也是预设体的名字</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果面板中已经存在了该面板</span></span><br><span class="line">        <span class="keyword">if</span> (panelDic.ContainsKey(panelName))    </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> panelDic[panelName] <span class="keyword">as</span> T;<span class="comment">//直接返回，不需要再创建了，保证面板的唯一性</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过类名就是预设体的面板名, 直接动态创建它</span></span><br><span class="line">        GameObject panelObj  = GameObject.Instantiate(Resources.Load&lt;GameObject&gt;(<span class="string">&quot;UI/&quot;</span> + panelName));</span><br><span class="line">        panelObj.transform.SetParent(canvasTrans, <span class="literal">false</span>);<span class="comment">//为UI面板设置父对象</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        T panel = panelObj.GetComponent&lt;T&gt;();<span class="comment">//接着 得到对应的面板脚本 然后存储起来</span></span><br><span class="line">        panelDic.Add(panelName, panel);<span class="comment">//把面板脚本存储到字典中 方便我们获取它</span></span><br><span class="line"></span><br><span class="line">        panel.ShowMe(); <span class="comment">//调用显示自己的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> panel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//隐藏面板</span></span><br><span class="line">    <span class="comment">//参数isFade的含义：如果希望面板淡出，就默认穿true 如果希望直接隐藏(删除)面板 那就传false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HidePanel</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">bool</span> isFade = <span class="literal">true</span> </span>) <span class="keyword">where</span> T : BasePanel</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="built_in">string</span> panelName = <span class="keyword">typeof</span>(T).Name;<span class="comment">//根据泛型类型 得到面板名字</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (panelDic.ContainsKey(panelName))<span class="comment">//判断当前显示的面板有没有改名字</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( isFade)</span><br><span class="line">            &#123;</span><br><span class="line">                panelDic[panelName].HideMe(() =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//面板淡出成功后 希望删除面板</span></span><br><span class="line">                    GameObject.Destroy(panelDic[panelName].gameObject);</span><br><span class="line">                    panelDic.Remove(panelName);<span class="comment">//删除面板后从字典移除</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//不执行淡出，直接删除面板</span></span><br><span class="line">                GameObject.Destroy(panelDic[panelName].gameObject);</span><br><span class="line">                panelDic.Remove(panelName);<span class="comment">//删除面板后从字典移除</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得面板</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">GetPanel</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : BasePanel</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="built_in">string</span> panelName = <span class="keyword">typeof</span>(T).Name;</span><br><span class="line">        <span class="keyword">if</span> (panelDic.ContainsKey(panelName))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> panelDic[panelName] <span class="keyword">as</span> T;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#知识点补充</title>
      <link href="blog/C-%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85/"/>
      <url>blog/C-%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><p>在C#中变量的类型可以分为 <strong>值类型</strong>和<strong>引用类型</strong></p><p>值类型的<strong>数据存放在栈中</strong>，<strong>表示实际的数据</strong>，<strong>继承自System.ValueType</strong>,栈中内存自动释放。</p><p><strong>基本的数据类型</strong>和<strong>结构体</strong> 就是属于值类型</p><p>引用类型的数据存储在<strong>堆</strong>中，该变量存放的是指向堆中数据的<strong>指针</strong>或<strong>引用</strong>，继承自<strong>System.Object</strong>,堆中的<strong>内存由GC释放</strong>。</p><p><strong>string</strong>，<strong>数组</strong>以及<strong>类</strong> 都属于引用类型</p><h2 id="ref和out"><a href="#ref和out" class="headerlink" title="ref和out"></a>ref和out</h2><p><strong>ref</strong> 和 <strong>out</strong> 是<strong>函数参数</strong>的修饰符</p><p>作用：</p><p>使用<strong>ref</strong> 和 <strong>out</strong>修饰的 <strong>形参</strong>，在其内容改变后会<strong>影响到其实参的值</strong>，</p><blockquote><p>通俗的来说，使用 ref 和 out 修饰形参后，函数内形参的值变为多少 ，实参的值也变为多少</p></blockquote><p>区别：</p><ol><li><strong>ref 作为实参时，必须进行初始化</strong>，而out 则不用。</li><li><strong>out 作为形参时，必须在函数内部进行赋值</strong>，而ref 不用</li></ol><h2 id="params-关键字-变长参数"><a href="#params-关键字-变长参数" class="headerlink" title="params 关键字(变长参数)"></a>params 关键字(变长参数)</h2><p>使用params 关键字可以让传入函数的数组长度<strong>不固定</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Sum</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">int</span>[] arr</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,...,<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li>params 关键字后面必须是数组</li><li>函数参数中<strong>最多出现一个params</strong> 关键字，并且只能在<strong>最后一个参数</strong></li></ul><h2 id="构造、析构和垃圾回收"><a href="#构造、析构和垃圾回收" class="headerlink" title="构造、析构和垃圾回收"></a>构造、析构和垃圾回收</h2><p>C#的构造函数和C++类似，一般不用手动析构，重点是C#的自动垃圾回收机制GC</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><strong>作用</strong>：</p><p>在实例化对象时，会调用构造函数用于<strong>对象初始化</strong>，如果不写，系统会默认提供一个无参构造</p><p>写法：</p><ol><li>没有返回值</li><li>函数名和类型相同</li><li>一般是public访问权限 (C++ 中不写访问权限)</li></ol><p>特点：</p><ol><li>构造函数允许发生重载</li><li>通过<strong>this</strong> 关键字一直指向当前对象</li></ol><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>垃圾回收的过程是<strong>遍历堆上动态分配的所有对象</strong>，通过识别它们<strong>是否被引用</strong>，来确定哪些对象是垃圾，哪些对象仍要被引用</p><p>GC只负责<strong>堆上</strong>内存的垃圾回收，<strong>引用类型都是存储在堆上</strong>，所以它的<strong>分配</strong>和<strong>释放</strong>时由CG来管理的</p><img src="/blog/C-%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85/image-20220403230858579-16556403745261.png" class=""><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主动进行垃圾回收，一般在loading过场时</span></span><br><span class="line">CG.Collect();</span><br></pre></td></tr></table></figure><h2 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h2><p>用于<strong>保护成员变量</strong>，为<strong>成员属性</strong>的<strong>获取</strong>和<strong>赋值</strong> <strong>添加逻辑处理</strong>，<strong>解决访问修饰符的局限性</strong></p><h3 id="get-和set"><a href="#get-和set" class="headerlink" title="get{}和set{}"></a>get{}和set{}</h3><p>作用：</p><p>通过访问成员属性的属性名，可以对<strong>private</strong> 和 <strong>protect</strong>修饰的成员变量进行<strong>获取</strong>和<strong>修改</strong></p><blockquote><p>jget{}语句块中将成员变量中的内容返回给属性名</p><p>再通过set{}语句块中的 value关键字，可以对成员变量中的内容进行修改</p></blockquote><p>基本语法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">访问修饰符 属性类型 属性名</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">get&#123;&#125;</span></span><br><span class="line"><span class="comment">set&#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><p>特点：get 和 set <strong>语句块前可以加访问修饰符</strong>，来设置该属性的可读或可写</p><ul><li>默认不加时 使用声明属性时的访问权限</li><li>添加的访问修饰符权限要 <strong>低于</strong>属性的访问权限</li><li>不能让get 和 set的访问权限都低于属性的权限</li></ul><blockquote><p>也就是说，不能出现 属性是私有访问权限，而get 和 set是公有权限的情况。</p><p>以及 get 和 set 至少有一个的访问权限要和属性的访问权限相同</p></blockquote><p>注意：</p><p>成员属性一般是用于<strong>私有</strong>的成员变量，我们不希望外部对其的值进行修改，所以一般来说只会用get{}语句块让外部进行读取，而不设置set{}语句块让外部修改</p><h3 id="自动属性"><a href="#自动属性" class="headerlink" title="自动属性"></a><strong>自动属性</strong></h3><p>如果有一个成员变量只希望外部能得不能改，并且又不需要做逻辑处理的话</p><p>就可以使用自动属性</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Peson</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Heigt&#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h2><p>用<strong>static</strong>修饰的类</p><p>特点：</p><ul><li>静态类中<strong>只能包含静态成员</strong></li><li>静态类<strong>不能被实例化</strong></li></ul><p>作用：</p><ul><li>将常用的静态成员写在静态类中，方便使用</li><li>静态类不能被实例化，更能体现<strong>工具类</strong>的<strong>唯一性</strong></li><li>比如，C#中的Console就是静态类</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>C# 语法和C++类似，但不需要声明继承访问权限。</p><p>C#仅支持单继承，而C++支持多继承</p><p>语法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span> : <span class="title">B</span>;</span><br></pre></td></tr></table></figure><p>注意：</p><p>子类和父类出现同名成员时，子类的成员会默认将父类的成员重写，这一点与C++相同</p><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>里氏替换原则是面向对象七大原则中最重要的原则</p><p>概念：</p><p><strong>任何父类出现的地方，子类都可以替代</strong></p><p>特点：</p><p>语法表现—父类容器装子类对象，因为子类对象包含了父类的所有内容</p><p>作用：</p><p>方便进行对象存储和管理</p><p><strong>is</strong> 和 <strong>as</strong></p><p><strong>is</strong>：<strong>判断一个对象是否为指定的类对象</strong>，返回值为bool</p><p>as：将父对象类型转换为子对象类型</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">GameObject</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Player</span> : <span class="title">GameObject</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlayerAtk</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GameObject obj = <span class="keyword">new</span> Player();<span class="comment">//用父类的类型创建子类对象,允许，但不能使用子类方法</span></span><br><span class="line"></span><br><span class="line">(obj <span class="keyword">as</span> Player).PlayerAtk();<span class="comment">//将父类的类型转换为子类类型后</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h2><p>用<strong>object</strong> 存储 <strong>值类型</strong>被称为<strong>装箱</strong>，再把<strong>object</strong> 转为<strong>值类型</strong> 被称为<strong>拆箱</strong></p><p>装箱</p><p>把<strong>值类型用引用类型存储</strong>，<strong>栈内存会移到堆内存</strong>中</p><p>拆箱</p><p>把<strong>引用类型存储的值类型取出来</strong>，<strong>堆内存会迁移到栈内存</strong>中</p><p>好处：不确定类型时，可以方便参数的存储和传递</p><p>坏处：内存迁移时，会增加性能消耗</p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>本质是一个<strong>object</strong> 类型的数组，所以可以为其添加任意类型的元素</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList arr = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">arr.Add(<span class="number">1</span>);<span class="comment">//增加任意类型的元素</span></span><br><span class="line"></span><br><span class="line">arr.Remove(<span class="number">1</span>);<span class="comment">//删除元素</span></span><br><span class="line"></span><br><span class="line">arr.Contains(<span class="number">1</span>);<span class="comment">//查找元素是否存在，返回值为bool</span></span><br><span class="line"></span><br><span class="line">arr.Count;<span class="comment">//数组长度</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>使用ArrayList的过程中会存在装箱，拆箱的问题。所以尽量少用</p><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>栈的本质也是一个object[ ] 数组，只是封装了特殊的存储规则</p><p>栈是一种“先进后出”的数据结构</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要引入命名空间System.Collections</span></span><br><span class="line">Stack stack = <span class="keyword">new</span> Stack();</span><br><span class="line"></span><br><span class="line">stack.Push(<span class="number">1</span>);<span class="comment">//往栈中压入元素</span></span><br><span class="line"></span><br><span class="line">Object v = stack.Pop();<span class="comment">//取栈中的最上方元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈无法查看指定位置的元素。只能查看栈顶的内容</span></span><br><span class="line">v = stack.Peek();</span><br><span class="line"></span><br><span class="line">stack.Contains(<span class="number">1</span>);<span class="comment">//查看元素是否存在栈中</span></span><br></pre></td></tr></table></figure><h2 id="Hashtalbe"><a href="#Hashtalbe" class="headerlink" title="Hashtalbe"></a>Hashtalbe</h2><p>Hashtable 又称散列表，是基于键的哈希代码组织起来的 <strong>键值对</strong>形式</p><h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><p>让泛型的类型有一定的限制，关键字<strong>where</strong></p><p>泛型一共有6种约束</p><ol><li>值类型：where 泛型字母：struct</li><li>引用类型：where 泛型字母：class</li><li>存在无参公共构造函数：where 泛型字母：new()</li><li>某个类本身或者其派生类：where 泛型字母：类名</li><li>某个接口的派生类：where 泛型字母：接口名</li><li>另一个泛型或其派生类型：where 泛型字母：另一个泛型字母</li></ol><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List的本质 是一共<strong>可变类型</strong>的<strong>泛型数组</strong></p><p>可以直接指定数组的内容，避免了装箱和拆箱</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要引入命名空间 using System.Collections.Generic</span></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">List&lt;<span class="built_in">string</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h2><p>可以将字典理解为 拥有泛型的Hashtable。它也是基于键的哈希代码组织起来的 键/值对</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//申明int类型的键，string类型的值</span></span><br><span class="line">Dictionary&lt;<span class="built_in">int</span>,<span class="built_in">string</span>&gt; dictionary = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>,<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//不能出现相同的键</span></span><br><span class="line">dictionary.Add(<span class="number">1</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">dictionary.Add(<span class="number">2</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">dicitionary.Remove(<span class="number">1</span>);<span class="comment">//删除键</span></span><br><span class="line"></span><br><span class="line">dicitionary.Clear();<span class="comment">//清空</span></span><br><span class="line"></span><br><span class="line">dicitionary[<span class="number">1</span>];<span class="comment">//通过键去查看值，找不到则返回空</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器遍历所有键</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">int</span> item <span class="keyword">in</span> dicitionary.Keys)&#123;</span><br><span class="line">   Console.WriteLine(item);<span class="comment">//输出所有值</span></span><br><span class="line">    Console.WriteLine(dicitionary[item]);<span class="comment">//输出所有键</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器遍历值</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">int</span> item <span class="keyword">in</span> dicitionary.Values)&#123;</span><br><span class="line">    Console.WriteLine(item);<span class="comment">//输出所有值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器遍历键值对</span></span><br><span class="line"><span class="keyword">foreach</span>(KeyValuePair&lt;<span class="built_in">int</span>,<span class="built_in">string</span>&gt; item <span class="keyword">in</span> dictionary)&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;键&quot;</span> + item.Key + <span class="string">&quot;值&quot;</span> + item.Va);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>委托的<strong>本质是一个类</strong>，它用于定义函数的类型，用来<strong>存储、传递函数</strong></p><p>作用：可以将函数的执行暂时挂起，等待有需要时再调用</p><blockquote><p>可以将委托理解为装载<strong>函数的容器</strong>，如果委托中不传入函数，那么它就没有意义</p><p>注意：委托既然理解为容器，那么传入的函数类型必须与装载它的委托类型相对应</p><p>即如果委托是无参无返回值的，那么传入的函数也必须是无参无返回值的</p></blockquote><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul><li><p>关键字：<strong>delegate</strong></p></li><li><p>语法：访问修饰符 delegate 返回值 委托名(参数列表);</p></li></ul><blockquote><p>委托的声明就是在函数的返回值前加一个delegate关键字</p><p>委托中默认不写访问修饰符它就是public的</p></blockquote><h3 id="自定义委托"><a href="#自定义委托" class="headerlink" title="自定义委托"></a>自定义委托</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义了一个公共的 无参无返回值的委托</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Fun</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个无参无返回的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将函数传入委托中</span></span><br><span class="line">Fun f = Function;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用委托</span></span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义了一个公共的 参数和返回值都为int的委托</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">fun1</span>(<span class="params"><span class="built_in">int</span> a</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意：虽然委托的写法与函数类似，但它并不具备重载的功能，也就是同一代码块中，委托是不能重名的</p></blockquote><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>由于委托可以直接进行赋值，就导致了容器内的函数有丢失的风险</p><blockquote><p>比如我一不小心将 delegate1 = delegate2</p><p>那么delegate1中的函数就丢失了</p><p>所以，这个时候事件Event的作用就体现出来了</p></blockquote><p>Event会对Delegate的直接赋值进行限制，而其它功能则不变</p><p>所以说事件的作用是<strong>让委托使用起来更具有安全性的</strong></p><blockquote><p>事件的使用也很简单，只需要在委托类型前加上event关键字即可</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个的委托</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">fun</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义了一个无参无返回值的委托</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">event</span> Action <span class="title">myEvent</span>(<span class="params"></span>)</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#知识点补充 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity基础程序框架</title>
      <link href="blog/Unity%E5%9F%BA%E7%A1%80%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/"/>
      <url>blog/Unity%E5%9F%BA%E7%A1%80%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当我们创建一个Unity工程准备做项目时，就要创建一些必要的文件夹</p><ul><li>Resouces文件夹：一般将需要动态加载的资源放到这下面</li><li>Scripts文件夹：存放脚本的文件夹</li><li>Scenes文件夹：存放场景</li><li>ArtRes文件夹：存放艺术资源</li></ul><blockquote><p>由于打包时，会将Resources下的所有文件全部打包到exe中，所以我们只会在Resources文件夹下存放少量需要使用的素材。而其它大量的素材是存放到ArtRes文件夹下的</p></blockquote><h2 id="单例模式基类模块"><a href="#单例模式基类模块" class="headerlink" title="单例模式基类模块"></a>单例模式基类模块</h2><p><strong>单例模式</strong></p><p>意图：保证<strong>一个类仅有一个实例</strong>，并提供一个访问它的<strong>全局访问点</strong></p><p>主要解决：避免一个全局使用的类，被频繁地创建与销毁</p><p>使用场景：控制实例数目，节省系统资源的时候</p><p><strong>应用实例：</strong></p><ul><li>游戏管理器：一般会把游戏当中的唯一的一个管理者设置为单例模式</li><li>怪物管理器等管理类</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//只要通过该方法调用，得到的就是唯一的对象</span></span><br><span class="line">    SingletonBase.GetInstance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SingletonBase</span>&#123;</span><br><span class="line">    <span class="comment">//声明私有的静态成员变量，该成员变量只能在类中调用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonBase instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//公共静态成员方法，在方法里面调用静态对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonBase <span class="title">GetInstance</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//为了保证单例模式的对象的唯一性，当该对象存在时，不会产生新对象</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonBase();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在游戏开发中，可以使用伪单例模式，创建一个公共基类用于保存数据，让玩家身上的属性不会因为切换场景而清</p><p>而真单例模式是不继承MonoBehaviour的</p></blockquote><p>伪单例模式常见的写法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SingletonBase</span>&lt;<span class="title">T</span>&gt; : <span class="title">MonoBehaviour</span> <span class="keyword">where</span> <span class="title">T</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T instance;    </span><br><span class="line"><span class="comment">//万一新场景中有一个对象挂载了当前脚本，也不会破环单例的唯一性   </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;    </span><br><span class="line">     <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">           instance = <span class="keyword">this</span> <span class="keyword">as</span> T;</span><br><span class="line">           &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(instrance != <span class="keyword">this</span>)&#123;</span><br><span class="line">               Destroy(gameObject);</span><br><span class="line">           &#125;</span><br><span class="line">        DontDestroyOnLoad(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单例模式基类</strong></p><blockquote><p>因为在一个游戏中，可能有许多的单例模式</p><p>而它们的区别很多时候就只有类名不同</p><p>所以我们就可以给这些单例模式设置一个基类</p><p>这样但我们要使用时，只需要继承基类即可</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型需要创建对象时，需要无参构造函数的约束</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1、单例模式基类不需要继承MonoBehaviour，我们将它设置为泛型类</span></span><br><span class="line"><span class="comment">2、按照单例模式的写法，补充基类中的内容，只不过要将具体的类，用泛型T代替</span></span><br><span class="line"><span class="comment">3、通过where关键字，让泛型有一定的限制。该单例模式中，这个T是一个类对象，具有无参构造函数，需要用new()来限制</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">public class BaseManager&lt;T&gt; where T:new()&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">GetInstance</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> T();           </span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">好处：有了单例模式基类后，遇见单例模式就不需要写重复的代码。直接继承基类就可以了</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//游戏管理类继承单例模式基类,在它的类中就不需要写重复的单例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SingletonBase</span> : <span class="title">BaseManager</span>&lt;<span class="title">GameManage</span>&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> Test&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        SingletonBase.GetInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承MonoBehaviour的单例模式基类"><a href="#继承MonoBehaviour的单例模式基类" class="headerlink" title="继承MonoBehaviour的单例模式基类"></a>继承MonoBehaviour的单例模式基类</h2><p>继承了Mono的脚本，不能够用new 关键字实例化对象</p><p>只能拖动到对象上，或者 通过AddComponent 去添加脚本</p><p>然后U3D内部帮助我们实例化它</p><p><strong>继承Mono的单例模式基类</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SingletonAutoMono</span>&lt;<span class="title">T</span>&gt; : <span class="title">MonoBehaviour</span> <span class="keyword">where</span> <span class="title">T</span> : <span class="title">MonoBehaviour</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">GetInstance</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( instance == <span class="literal">null</span> )&#123;</span><br><span class="line">            GameObject obj = <span class="keyword">new</span> GameObject();</span><br><span class="line">            <span class="comment">//设置对象名字为脚本名</span></span><br><span class="line">            obj.name = <span class="keyword">typeof</span>(T).ToString();</span><br><span class="line">            <span class="comment">//切场景时，放置游戏对象被销毁而引发单例模式不能使用的问题</span></span><br><span class="line">           DontDestroyOnLoad(obj);</span><br><span class="line">            </span><br><span class="line">            Instance = obj.AddComponent&lt;T&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象池模块"><a href="#对象池模块" class="headerlink" title="对象池模块"></a>对象池模块</h2><p>一些需要频繁创建的对象，且用完就删的对象，可以放入缓存池中。这样可以减少GC频率带来的卡顿</p><img src="/blog/Unity%E5%9F%BA%E7%A1%80%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/image-20220409230236924.png" class="" title="image-20220409230236924"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓存池同样继承BaseManager</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PoolMgr</span> : <span class="title">BaseManager</span>&lt;<span class="title">PoolMar</span>&gt;&#123;</span><br><span class="line">    <span class="comment">//实例化一个缓存池容器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dictionary</span>&lt;<span class="title">string</span>,<span class="title">List</span>&lt;<span class="title">GameObject</span>&gt;&gt; poolDic</span> = <span class="keyword">new</span> Diction&lt;<span class="built_in">string</span>,List&lt;GameObject&gt;&gt;();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将缓存池容器内部的对象取出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GameObject <span class="title">GatObj</span>(<span class="params">String name</span>)</span>&#123;</span><br><span class="line">        GameObject obj = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//如果这个键存在，也就是队列存在，并且该队列不为空</span></span><br><span class="line">        <span class="keyword">if</span>(poolDic.ContainsKey(name) &amp;&amp; poolDic[name].Count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            obj = poolDic[name][<span class="number">0</span>];<span class="comment">//将队列中第一个元素赋值给对象</span></span><br><span class="line">            poolDic[name].RemoveAt(<span class="number">0</span>);<span class="comment">//赋值后就移除该元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//刚开始时，缓存池中并没有对象,所以在此先实例化对象</span></span><br><span class="line">            obj = GameObject.Instantiate(<span class="function">Resources <span class="title">Load</span>&lt;<span class="title">GameObject</span>&gt;(<span class="params">name</span>))</span>;</span><br><span class="line">            <span class="comment">//把对象名字改的和缓存池名字一样</span></span><br><span class="line">            obj.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//激活游戏对象</span></span><br><span class="line">        obj.SetActive(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将使用完的对象放入缓存池中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PushObj</span>(<span class="params">String name,GameObject obj</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//失活游戏对象</span></span><br><span class="line">        obj.SetActive(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//缓存池中有队列</span></span><br><span class="line">        <span class="keyword">if</span>(poolDic.ContainsKey(name))&#123;</span><br><span class="line">            <span class="comment">//将场景外部对象放入缓存池中</span></span><br><span class="line">            poolDic[name].Add(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//缓存池中没有队列</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//添加队列</span></span><br><span class="line">            poolDic.Add(name,<span class="keyword">new</span> List&lt;GameObject&gt;() &#123;obj&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取缓存池中的对象 脚本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Input.GetMouseButtonDown(<span class="number">0</span>))&#123;</span><br><span class="line">        PoolMar.GetInstance().GetObj(<span class="string">&quot;预设体的路径&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每当对象激活时，将对象存入缓存池中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//延迟2s后调用Push函数</span></span><br><span class="line">    Invoke(<span class="string">&quot;Push&quot;</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    PoolMar.GetInstance().PushObj(<span class="keyword">this</span>.gameObject.name,<span class="keyword">this</span>.gameObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="事件中心模块"><a href="#事件中心模块" class="headerlink" title="事件中心模块"></a>事件中心模块</h2><p>当敌人死亡时，一般会有掉落奖励、或者分数记录、获得过关等事件。</p><ol><li>比如有一个玩家类</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> score = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddScore</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        score++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>一个敌人类</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Dead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dead</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;怪物死亡,人物分数加1&quot;</span>);</span><br><span class="line">        <span class="comment">//获取Player游戏对象上的Player脚本上的加法方法</span></span><br><span class="line">        GameObject.Find(<span class="string">&quot;Player&quot;</span>).GetComponent&lt;Player&gt;().AddScore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>如果常规来看的话，我们需要在敌人类中用<code>GameObject.Find</code>等方法去找到其它类，再调用该类中的方法。这样的话各个类之间的耦合就非常高，不利于后期的修改和维护</li></ol><blockquote><p>所以，我们在事件与事件之间添加一个事件中心模块，让它来分发各个类中的事件</p><p>当事件触发时，我们不会直接调用与其相关联的事件，而是通过事件中心来间接的进行监听，来达到降低耦合的目的</p><p>这也是观察者模式的思想</p></blockquote><ol><li>新建一个<strong>EventCenter</strong>脚本</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整个项目中只需要一个事件中心，所以可以将其设置为单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventCenter</span> : <span class="title">SingletonBase</span>&lt;<span class="title">EventCenter</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建一个字典容器,key表示事件的名字(比如：怪物死亡,玩家死亡等)</span></span><br><span class="line">    <span class="comment">//value表示监听该事件的委托函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Dictionary</span>&lt;<span class="title">string</span>, <span class="title">UnityAction</span>&gt; eventDic</span> = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, UnityAction&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加监听事件的委托函数，参数1是事件名，参数2是处理事件的委托</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddEventListener</span>(<span class="params"><span class="built_in">string</span> name, UnityAction action</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第一种情况，事件中心刚开始时 不存在事件监听</span></span><br><span class="line">        <span class="comment">//刚开始时肯定是不存在事件监听的，所以我们需要手动添加事件监听</span></span><br><span class="line">        <span class="keyword">if</span> (!eventDic.ContainsKey(name))     </span><br><span class="line">        &#123;</span><br><span class="line">            eventDic.Add(name, action); <span class="comment">//为事件中心的容器中添加事件以及委托函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二种情况，事件中心存在对应的监听</span></span><br><span class="line">        <span class="comment">//那么我们就将后续的委托函数加在后面</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            eventDic[name] += action;   <span class="comment">//依次添加委托函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//触发事件函数,传入事件名即可调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EventTrigger</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//如果该触发事件存在</span></span><br><span class="line">        <span class="keyword">if</span> (eventDic.ContainsKey(name))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//那么就调用该事件的所有委托函数</span></span><br><span class="line">            eventDic[(name)].Invoke();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果触发事件不存在，说明该事件触发时不需要做任何处理，所以不需要写逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除事件监听的委托函数</span></span><br><span class="line">    <span class="comment">//当我们的对象死亡被禁用或销毁后，我们就不需要对其进行监听</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveEventListener</span>(<span class="params"><span class="built_in">string</span> name, UnityAction action</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventDic.ContainsKey(name))</span><br><span class="line">        &#123;</span><br><span class="line">            eventDic[name] -= action;   <span class="comment">//移除对事件的委托函数调用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清除事件监听所有的委托函数</span></span><br><span class="line">    <span class="comment">//由于事件中心模块继承了单例类，所以切场景时并不会被清除，但场景中的对象却会清除</span></span><br><span class="line">    <span class="comment">//所以事件中心模块在进入到下一个场景中时，可能还保留着对上一个场景中已经被清除的对象的事件监听</span></span><br><span class="line">    <span class="comment">//这不是我们希望看到的，所以我们在过场景时，手动清空事件中心模块对所有事件的监听</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ClearEvent</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        eventDic.Clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>当我们有了事件中心模块后，就不需要再从敌人类中获取玩家类的脚本中的方法了</p><p>而是直接在敌人类中调用事件中心模块的触发事件函数</p><p>然后在玩家类中对触发事件函数进行监听</p></blockquote><ol><li>此时的Enemy类 和 Player类</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Dead();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dead</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;怪物死亡,人物分数加1&quot;</span>);</span><br><span class="line">        <span class="comment"><span class="doctag">///</span>/获取Player游戏对象上的Player脚本上的加法方法</span></span><br><span class="line">        <span class="comment">//GameObject.Find(&quot;Player&quot;).GetComponent&lt;Player&gt;().AddScore();</span></span><br><span class="line">        EventCenter.Instance().EventTrigger(<span class="string">&quot;EnemyDead&quot;</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> score = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//监听EnemyDead敌人死亡这个触发事件,当事件触发时，执行AddScore委托函数</span></span><br><span class="line">        EventCenter.Instance().AddEventListener(<span class="string">&quot;EnemyDead&quot;</span>, AddScore);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当玩家销毁时，移除对敌人死亡的监听</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//即移除敌人死亡事件的AddScore监听函数，不然不符合逻辑</span></span><br><span class="line">        EventCenter.Instance().RemoveEventListener(<span class="string">&quot;EnemyDead&quot;</span>, AddScore);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddScore</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;玩家加分&quot;</span>);</span><br><span class="line">        score++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>6.让事件中心模块更加通用</p><blockquote><p>在上述的步骤中，已经将事件中心模块的内容完成了，但是有一个小问题，就是它不够通用</p><p>假如我们有两种敌人</p><p>敌人1死亡后我们希望玩家可以加分，敌人2死亡后玩家可以加血</p><p>这种情况下，同样是敌人死亡事件(EnemyDead)，我们之前的事件中心模块就无法区分</p><p>所有我们可以在委托函数中加入一个泛型参数来指定需要监听事件对象的类型，这里我们选择传入Object参数</p></blockquote><p>所以EventCenter脚本改写如下</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整个项目中只需要一个事件中心，所以可以将其设置为单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventCenter</span> : <span class="title">SingletonBase</span>&lt;<span class="title">EventCenter</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建一个字典容器,key表示事件的名字(比如：怪物死亡,玩家死亡等)</span></span><br><span class="line">    <span class="comment">//value表示监听该事件的委托函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Dictionary</span>&lt;<span class="title">string</span>, <span class="title">UnityAction</span>&lt;<span class="title">object</span>&gt;&gt; eventDic</span> = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, UnityAction&lt;<span class="built_in">object</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加监听事件的委托函数，参数1是事件名，参数2是处理事件的委托</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddEventListener</span>(<span class="params"><span class="built_in">string</span> name, UnityAction&lt;<span class="built_in">object</span>&gt; action</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第一种情况，事件中心刚开始时 不存在事件监听</span></span><br><span class="line">        <span class="comment">//刚开始时肯定是不存在事件监听的，所以我们需要手动添加事件监听</span></span><br><span class="line">        <span class="keyword">if</span> (!eventDic.ContainsKey(name))     </span><br><span class="line">        &#123;</span><br><span class="line">            eventDic.Add(name, action); <span class="comment">//为事件中心的容器中添加事件以及委托函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二种情况，事件中心存在对应的监听</span></span><br><span class="line">        <span class="comment">//那么我们就将后续的委托函数加在后面</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            eventDic[name] += action;   <span class="comment">//依次添加委托函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//触发事件函数,传入事件名即可调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EventTrigger</span>(<span class="params"><span class="built_in">string</span> name,<span class="built_in">object</span> info</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//如果该触发事件存在</span></span><br><span class="line">        <span class="keyword">if</span> (eventDic.ContainsKey(name))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//那么就调用该事件的所有委托函数</span></span><br><span class="line">            eventDic[(name)].Invoke(info);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果触发事件不存在，说明该事件触发时不需要做任何处理，所以不需要写逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除事件监听的委托函数</span></span><br><span class="line">    <span class="comment">//当我们的对象死亡被禁用或销毁后，我们就不需要对其进行监听</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveEventListener</span>(<span class="params"><span class="built_in">string</span> name, UnityAction&lt;<span class="built_in">object</span>&gt; action</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventDic.ContainsKey(name))</span><br><span class="line">        &#123;</span><br><span class="line">            eventDic[name] -= action;   <span class="comment">//移除对事件的委托函数调用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清除事件监听所有的委托函数</span></span><br><span class="line">    <span class="comment">//由于事件中心模块继承了单例类，所以切场景时并不会被清除，但场景中的对象却会清除</span></span><br><span class="line">    <span class="comment">//所以事件中心模块在进入到下一个场景中时，可能还保留着对上一个场景中已经被清除的对象的事件监听</span></span><br><span class="line">    <span class="comment">//这不是我们希望看到的，所以我们在过场景时，手动清空事件中心模块对所有事件的监听</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ClearEvent</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        eventDic.Clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>相应的Enemy脚本和Player脚本也要修改</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Dead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dead</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;怪物死亡,人物分数加1&quot;</span>);</span><br><span class="line">        <span class="comment"><span class="doctag">///</span>/获取Player游戏对象上的Player脚本上的加法方法</span></span><br><span class="line">        <span class="comment">//GameObject.Find(&quot;Player&quot;).GetComponent&lt;Player&gt;().AddScore();</span></span><br><span class="line"></span><br><span class="line">        EventCenter.Instance().EventTrigger(<span class="string">&quot;EnemyDead&quot;</span>, <span class="keyword">this</span>);   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> score = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//监听EnemyDead敌人死亡这个触发事件,当事件触发时，执行AddScore委托函数</span></span><br><span class="line">        EventCenter.Instance().AddEventListener(<span class="string">&quot;EnemyDead&quot;</span>, AddScore);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当玩家销毁时，移除对敌人死亡的监听</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//即移除敌人死亡事件的AddScore监听函数，不然不符合逻辑</span></span><br><span class="line">        EventCenter.Instance().RemoveEventListener(<span class="string">&quot;EnemyDead&quot;</span>, AddScore);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddScore</span>(<span class="params"><span class="built_in">object</span> info</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;玩家加分&quot;</span>);</span><br><span class="line">        score++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="公共Mono模块"><a href="#公共Mono模块" class="headerlink" title="公共Mono模块"></a>公共Mono模块</h2><p>作用：让<strong>没有继承Mono的类可以开启协程</strong>，<strong>可以使用Update函数</strong>，用于统一管理Update</p><blockquote><p>如果一个类没有继承MonoBehaviour，那么这个类就不能使用Unity中的方法</p><p>比如该类它继承了真单例模式基类，那么它就不能挂载到场景上</p><p>而因为没有继承MonoBehaviour，所以不能开启协程。同样不能使用Update函数</p></blockquote><h3 id="实现Update函数"><a href="#实现Update函数" class="headerlink" title="实现Update函数"></a>实现Update函数</h3><ul><li>有一个单例基类<strong>SingletonBase</strong></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">public class SingletonBase&lt;T&gt; where T : new()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> T instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">Instance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            instance = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>新建一个<strong>Test</strong>类</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> :  <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        print(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test2</span>&#123;</span><br><span class="line">    <span class="comment">//报错，不能使用Unity的生命周期函数Update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        print(<span class="string">&quot;&quot;</span>);<span class="comment">//报错，不能使用Unity的print方法</span></span><br><span class="line">        Debug.Log(<span class="string">&quot;222&quot;</span>);<span class="comment">//只能使用C#中的Debug方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>常规情况下，我们没有办法让Test2类开启协程，或者使用Update函数。这是由于它不继承MonoBehaviour，不能使用Unity自带的方法。</p><p>解决方法：</p><p>写一个<strong>MonoCenter</strong>类，让它继承MonoBehaviour。通过外部对象将我们自己实现委托函数添加到事件中，最后在MonoCenter类的Update中开启事件</p><p>以此来实现不继承Mono的类使用Update的方法</p></blockquote><ul><li>新建一个MonoCenter类</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MonoCenter</span> :  <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">event</span> UnityAction updateEvent;  <span class="comment">//声明一个帧更新事件 </span></span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        DontDestroyOnLoad(gameObject);</span><br><span class="line">        <span class="comment">//这里是保证Mono管理器过场景不移除</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (updateEvent != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            updateEvent();<span class="comment">//开启事件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供给外部的，为帧更新事件添加委托函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddUpdateListener</span>(<span class="params">UnityAction fun</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        updateEvent += fun;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供给外部，为帧更新事件移除委托函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveUpdateListener</span>(<span class="params">UnityAction fun</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        updateEvent -= fun;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>新建一个MonoManager脚本，它继承与单例基类</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MonoManager</span> : <span class="title">SingletonBase</span>&lt;<span class="title">MonoManager</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> MonoCenter monoCenter;   <span class="comment">//声明一个MonoCenter对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//MonoManager继承了单例模式基类</span></span><br><span class="line">    <span class="comment">//当他没有实例对象时，单例模式基类会调用默认的构造函数帮它实例化一个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MonoManager</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//所以我们可以在MonoManager构造函数中新增一些方法，让MonoManager类实例化的时候</span></span><br><span class="line">        <span class="comment">//创建一个游戏对象，为它添加MonoCenter脚本</span></span><br><span class="line">        <span class="comment">//而且该游戏对象只会在MonoManager第一次实例化的时候才会创建</span></span><br><span class="line">        <span class="comment">//保证了唯一性</span></span><br><span class="line">        GameObject obj = <span class="keyword">new</span> GameObject(<span class="string">&quot;MonoCenter&quot;</span>);</span><br><span class="line">        monoCenter = obj.AddComponent&lt;MonoCenter&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对MonoCenter中的监听事件函数进行封装</span></span><br><span class="line">    <span class="comment">//因为我们是通过继承单例的MonoManager来管理的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddUpdateListener</span>(<span class="params">UnityAction fun</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        monoCenter.AddUpdateListener(fun);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveUpdateListener</span>(<span class="params">UnityAction fun</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        monoCenter.AddUpdateListener(fun);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>重新在Test类中进行测试</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//调用自己封装好的Update</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//可以实现Update的效果</span></span><br><span class="line">        Debug.Log(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Test2 t = <span class="keyword">new</span> Test2();</span><br><span class="line">        MonoManager.Instance().AddUpdateListener(t.Update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现开启协程"><a href="#实现开启协程" class="headerlink" title="实现开启协程"></a>实现开启协程</h3><ol><li>在之前的MonoManager类中添加开启协程的方法</li></ol><blockquote><p>因为monoCenter对象它继承了MonoBehaviour，它能够开启协程</p><p>所以我们在MonoManager类中 对monoCenter对象的开启协程方法进行封装</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MonoManager</span> : <span class="title">SingletonBase</span>&lt;<span class="title">MonoManager</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> MonoCenter monoCenter;   <span class="comment">//声明一个MonoCenter对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//MonoManager继承了单例模式基类</span></span><br><span class="line">    <span class="comment">//当他没有实例对象时，单例模式基类会调用默认的构造函数帮它实例化一个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MonoManager</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//所以我们可以在MonoManager构造函数中新增一些方法，让MonoManager类实例化的时候</span></span><br><span class="line">        <span class="comment">//创建一个游戏对象，为它添加MonoCenter脚本</span></span><br><span class="line">        <span class="comment">//而且该游戏对象只会在MonoManager第一次实例化的时候才会创建</span></span><br><span class="line">        <span class="comment">//保证了唯一性</span></span><br><span class="line">        GameObject obj = <span class="keyword">new</span> GameObject(<span class="string">&quot;MonoCenter&quot;</span>);</span><br><span class="line">        monoCenter = obj.AddComponent&lt;MonoCenter&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对MonoCenter中的监听事件函数进行封装</span></span><br><span class="line">    <span class="comment">//因为我们是通过继承单例的MonoManager来管理的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddUpdateListener</span>(<span class="params">UnityAction fun</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        monoCenter.AddUpdateListener(fun);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveUpdateListener</span>(<span class="params">UnityAction fun</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        monoCenter.AddUpdateListener(fun);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**----------------------------------------------------------------**/</span></span><br><span class="line">    <span class="comment">//封装monoCenter对象开启协程的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coroutine <span class="title">StartCoroutine</span>(<span class="params">IEnumerator routine</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> monoCenter.StartCoroutine(routine);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//协程重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coroutine <span class="title">StartCoroutine</span>(<span class="params"><span class="built_in">string</span> methodName</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> monoCenter.StartCoroutine(methodName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>打开之前的<strong>Test</strong>脚本，调用我们封装好的协程</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**---------------------------------------------------**/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">Test2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//在构造函数中开启协程</span></span><br><span class="line">        MonoManager.Instance().StartCoroutine(Test123());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">Test123</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        Debug.Log(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**---------------------------------------------------**/</span>    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Test2 t = <span class="keyword">new</span> Test2();</span><br><span class="line">        MonoManager.Instance().AddUpdateListener(t.Update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="场景切换模块"><a href="#场景切换模块" class="headerlink" title="场景切换模块"></a>场景切换模块</h2><p>作用：可以提供场景切换的公共接口</p><p>假设我们有A、B两个场景。当我们从A场景进入到B场景时，实际上B场景可能还是空的。</p><p>一般我们会通过<strong>配置文件</strong>去动态加载新场景中的物体，通过玩家信息数据动态的加载玩家。</p><p>而不是一开始就将每个场景中的物体、人物等搭建好</p><blockquote><p>这里我们会用到 <strong>场景异步加载、协程、委托</strong>来实现这个模块</p></blockquote><ol><li>新建一个ScenesManager脚本，让它继承单例模式基类</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.SceneManagement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ScenesManager</span> : <span class="title">SingletonBase</span>&lt;<span class="title">ScenesManager</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供给外部 同步加载场景的方法</span></span><br><span class="line">    <span class="comment">//参数1：场景名，参数2：加载完成后的委托函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadScene</span>(<span class="params"><span class="built_in">string</span> name,UnityAction fun</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//调用Unity自带的切换同步场景方法,不要忘记引用命名空间</span></span><br><span class="line">        SceneManager.LoadScene(name);</span><br><span class="line">        <span class="comment">//使用同步加载切换场景，一定是要等场景加载成功后，才会执行后面的代码</span></span><br><span class="line"></span><br><span class="line">        fun();<span class="comment">//场景加载结束后，才执行fun委托函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供给外部 异步加载场景的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadSceneAsyn</span>(<span class="params"><span class="built_in">string</span> name, UnityAction fun</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//ScenesManager没继承Mono,不能开启协程</span></span><br><span class="line">        <span class="comment">//所以可以通过之前写的MonoManager类，来调用其中封装的开启协程方法</span></span><br><span class="line">       MonoManager.Instance().StartCoroutine(LoadSceneAsynCoroutine(name, fun));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只要涉及到异步，我们都用协程配合使用</span></span><br><span class="line">    <span class="function">IEnumerator <span class="title">LoadSceneAsynCoroutine</span>(<span class="params"><span class="built_in">string</span> name, UnityAction fun</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//异步切换场景方法的返回值类型比较难记，可以通过F12进入查看</span></span><br><span class="line">        AsyncOperation ao = SceneManager.LoadSceneAsync(name); </span><br><span class="line">        <span class="keyword">while</span> (!ao.isDone)  <span class="comment">//当异步加载还没结束时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//通过之前的事件中心模块,向外发送进度，外部对象想用时直接对其监听即可</span></span><br><span class="line">            EventManager.Instance().EventTrigger(<span class="string">&quot;进度条更新&quot;</span>, ao.progress);</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> ao.progress;<span class="comment">//得到场景加载时的一个进度，可以用于显示进度条</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>我们在使用异步场景加载时，更多时候是希望将当前加载的进度反馈给外界</p><p>注意：</p><p>在切换场景时，不要忘记在File/Building Setting中关联场景</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity核心</title>
      <link href="blog/Unity%E6%A0%B8%E5%BF%83/"/>
      <url>blog/Unity%E6%A0%B8%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="图片导入设置"><a href="#图片导入设置" class="headerlink" title="图片导入设置"></a>图片导入设置</h2><h3 id="图片导入概述"><a href="#图片导入概述" class="headerlink" title="图片导入概述"></a>图片导入概述</h3><p>Unity中使用最多的图片格式是：<strong>JPG、PNG、TGA</strong> 三种</p><p>图片设置的6大部分</p><img src="/blog/Unity%E6%A0%B8%E5%BF%83/2D%E5%9B%BE%E7%89%87%E7%9B%B8%E5%85%B3%E9%9D%A2%E6%9D%BF.png" class="" title="2D图片相关面板"><ol><li>纹理类型</li><li>纹理形状</li><li>高级设置</li><li>平铺拉伸</li><li>平台窗口</li><li>预览窗口</li></ol><h3 id="纹理类型设置"><a href="#纹理类型设置" class="headerlink" title="纹理类型设置"></a>纹理类型设置</h3><img src="/blog/Unity%E6%A0%B8%E5%BF%83/image-20220404225010243.png" class="" title="image-20220404225010243"><p>设置纹理类型主要是为了让<strong>纹理图片有不同的主要用途</strong></p><ul><li><p>default：默认贴图纹理，大部分导入的模型贴图都是该类型</p><ul><li>sRGB：默认勾选，作用是让我们看到的颜色更自然</li><li><strong>Alpha Source</strong>：指定如何生成纹理的Alpha通道<ul><li>None：无论输入纹理是否有Alpha通道，导入的纹理都没有Alpha通道</li><li><strong>Input Texture Alpha</strong>：输入纹理中的Alpha。适用于带Alpha通道的图片</li></ul></li><li>Alpha Is Transparency：启用可以避免边缘上的过滤瑕疵</li></ul></li><li><p>Normal map：法线贴图纹理</p></li><li><p>Editor GUI：编辑GUI</p></li><li><p>Sprite：2D游戏和UI相关内容</p></li></ul><hr><h2 id="Sprite"><a href="#Sprite" class="headerlink" title="Sprite"></a>Sprite</h2><h3 id="SpriteEditor"><a href="#SpriteEditor" class="headerlink" title="SpriteEditor"></a>SpriteEditor</h3><p>SpriteEditor 是精灵图片编辑器，主要用于编辑2D游戏开发时 使用的Sprite精灵图片</p><p>作用：</p><p>主要用于编辑图集中<strong>提取元素</strong>、设置<strong>精灵边框</strong>、设置<strong>九宫格</strong>、设置<strong>轴心</strong>等功能</p><blockquote><p>要将图片的类型设置为Sprite 才能使用</p></blockquote><p>注意：</p><p>如果当前工程为3D工程的话，需要按照2D Sprite包才能使用SpriteEditor</p><p><strong>SpriteEditor参数</strong> </p><img src="/blog/Unity%E6%A0%B8%E5%BF%83/image-20220405143126640.png" class="" title="image-20220405143126640"><img src="/blog/Unity%E6%A0%B8%E5%BF%83/image-20220405143114301.png" class="" title="image-20220405143114301"><h4 id="Muleiple-图集元素分割"><a href="#Muleiple-图集元素分割" class="headerlink" title="Muleiple 图集元素分割"></a><strong>Muleiple</strong> 图集元素分割</h4><p>当图片资源为<strong>图集</strong>时，需要将模式设置为<strong>Multiple</strong>，就可以使用Sprite Editor对图集元素进行分割</p><p>详细参数移步文档</p><ul><li>进行图集元素切割时，一般使用<strong>Automatic</strong>(自动切割),再配合<strong>Trim</strong>手动调整，普遍性更高</li><li><strong>Grid By Cell Size</strong>(按单元格大小分割),该模式适用于符合单元格规范的图集</li><li></li></ul><h3 id="Sprite-Renderer"><a href="#Sprite-Renderer" class="headerlink" title="Sprite Renderer"></a><strong>Sprite Renderer</strong></h3><p><strong>Sprite Renderer</strong>是精灵渲染器组件，2D游戏中的<strong>所有资源都是通过Sprite Renderer让我们看到</strong>(UI除外)</p><p><strong>2D对象的创建</strong></p><ul><li>直接拖入Sprite图片<ol><li>可以将类型为<strong>Sprite</strong>的图片直接拖入场景中，就能完成创建</li><li>该图片的本质 其实就是空物体<strong>挂载了Sprite Renderer组件</strong></li><li>而Sprite Renderer组件上的<strong>Sprite参数关联了</strong>拖入场景的<strong>图片</strong>，所以就能看到</li></ol></li></ul><ul><li>通过Hierarchy窗口 <strong>右键</strong>创建<strong>2D Object</strong> 中的<strong>Sprite</strong><ol><li>此时就会出现一个挂载了<strong>Sprite Renderer</strong>组件的<strong>空对象</strong></li><li>将需要创建的图片，直接关联到该组件的Sprite中，即可完成创建</li></ol></li></ul><p>组件参数：详细参数移步文档</p><p><strong>代码设置</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态创建对象，为其添加精灵渲染器组件</span></span><br><span class="line">GameObject obj = <span class="keyword">new</span> GameObject();</span><br><span class="line">SpriteRenderer sr = obj.AddComponent&lt;SpriteRenderer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//为渲染器动态加载添加图片</span></span><br><span class="line">sr.sprite = Resources.Load&lt;Sprite&gt;(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态加载图集</span></span><br><span class="line">Sprite[] sprs = Resources.LoadAll&lt;Sprite&gt;(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将图集中的第一张图关联到渲染器中</span></span><br><span class="line">sr.sprite = sprs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//颜色更改</span></span><br><span class="line">sr.color;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转</span></span><br><span class="line">sr.flipX;</span><br></pre></td></tr></table></figure><p>示例：</p><p>1、写一个工具类，更好的加载Multiple类型的图集资源</p><h3 id="Sprite-Creator"><a href="#Sprite-Creator" class="headerlink" title="Sprite Creator"></a>Sprite Creator</h3><p>利用Sprite Editor的多边形工具创建出各种多边形</p><p>主要用于，在等待美术资源前的一个替代品</p><p><strong>使用Sprite Creator</strong></p><p>在Project窗口 右键Create 选择其中的<strong>Sprites</strong></p><hr><h2 id="2D物理系统"><a href="#2D物理系统" class="headerlink" title="2D物理系统"></a>2D物理系统</h2><h3 id="2D刚体"><a href="#2D刚体" class="headerlink" title="2D刚体"></a>2D刚体</h3><p>参数面板相关：</p><p>Metarial：物理材质，一般不在刚体上设置，它会默认使用碰撞器的物理材质</p><p>Simulated：默认启动，能够模拟物理效果</p><p>Use Auto Mass：是否使用自动质量，默认不启动</p><p>Linear Dray：影响位移的阻力</p><p>Angular Dray：影响旋转移动的阻力</p><p>Gravity Scale：受重力影响的程度</p><p>Sleeping Mode：对象处于静止状态时进入睡眠模式</p><p>​        1、Never Sleep：从不休眠，会一直进行检测</p><p>​        2、Start Awake：最初处于唤醒状态，静止时休眠，适用于 移动物体</p><p>​        3、Start Asleep：最初处于睡眠状态、被碰撞时唤醒。适用于 静止物体</p><p>如何选择不同类型的刚体</p><p>Dynamic 动态刚体：受力的作用，要动要碰的对象</p><p>Kinematic 运动学刚体：通过刚体API移动的对象，不受力的作用，会进行碰撞检测</p><p>Static 静态刚体：不动不受力作用的静态物体，会进行碰撞检测</p><p><strong>刚体API</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rigidbody2D rigid = <span class="keyword">this</span>.GetComponent&lt;Rigibody2D&gt;();</span><br><span class="line">right.AddForce(<span class="keyword">new</span> Vector2(<span class="number">0.100</span>)); <span class="comment">//添加力</span></span><br></pre></td></tr></table></figure><h3 id="物理材质"><a href="#物理材质" class="headerlink" title="物理材质"></a>物理材质</h3><p>物理材质是用于决定 在物体产生碰撞时的摩擦和弹性表现</p><p>通过物理材质，可以做出类型 斜坡不划落，小球反弹等效果</p><p>创建物理材质：</p><p>通过右键选择Create，找到Physics Material 2D，进行创建</p><p>物理材质的使用：</p><p>将创建好的物理材质，拖动到碰撞器的Material 参数中</p><h3 id="恒定力"><a href="#恒定力" class="headerlink" title="恒定力"></a>恒定力</h3><p>恒定力是一个特殊的脚本，它可以个2D刚体一个持续添加一个力</p><p>适用随着时间推移而加速的对象，比如火箭发射等效果</p><p>恒定力脚本会线性的为对象添加<strong>力和扭矩力</strong></p><h3 id="效应器"><a href="#效应器" class="headerlink" title="效应器"></a>效应器</h3><p>2D效应器一般配合2D碰撞器一起使用</p><p>可以让游戏对象在相互接触时产生一些特殊的物理作用力</p><p>比如<strong>传送带、互斥、吸引、漂浮、单向碰撞</strong>等效果</p><p><strong>区域效应器</strong>：Area Effector2D</p><p>控制力的方向，可以实现传送带和向上弹簧的效果</p><img src="/blog/Unity%E6%A0%B8%E5%BF%83/image-20220406161338789.png" class="" title="image-20220406161338789"><p><strong>浮力效应器</strong>：Buoyancy Effector2D</p><p>模拟流体行为，浮动和阻力相关设置，让该区域玩家看起来像在水里移动</p><img src="/blog/Unity%E6%A0%B8%E5%BF%83/image-20220406161400689.png" class="" title="image-20220406161400689"><p><strong>点效应器</strong>：Point Effector 2D</p><p>模拟磁铁的排斥或吸引</p><p>将该效应器放到磁铁上，然后只对<strong>铁</strong>层级的物品有效，就能完成磁铁效果</p><img src="/blog/Unity%E6%A0%B8%E5%BF%83/image-20220406162127627.png" class="" title="image-20220406162127627"><p><strong>平台效应器</strong>：Platform Effector 2D</p><p>2D游戏中的平台 或可往上跳跃的墙壁</p><img src="/blog/Unity%E6%A0%B8%E5%BF%83/image-20220406162741068.png" class="" title="image-20220406162741068"><p>表面效应器：Surface Effector 2D</p><p>表面效应器不需要勾选Is Trigger,主要用于模拟传送带</p><p>若要实现物体在传送到上打滚的功能，则勾选Use Contact Force</p><img src="/blog/Unity%E6%A0%B8%E5%BF%83/image-20220406163353466.png" class="" title="image-20220406163353466"><hr><h2 id="SpriteShape"><a href="#SpriteShape" class="headerlink" title="SpriteShape"></a>SpriteShape</h2><p>SpriteShape是精灵形状的意思。</p><p>主要用于节约美术资源为前提，<strong>制作</strong>2D游戏场景<strong>地形</strong> 或者 <strong>背景</strong></p><hr><h2 id="Tilemap"><a href="#Tilemap" class="headerlink" title="Tilemap"></a>Tilemap</h2><p>Tilemap一般被称为 <strong>瓦片地图</strong>或者<strong>平铺地图</strong></p><p>主要用于快速编辑2D游戏中的场景</p><p>工作原理是 用小图排列组合成一张大地图</p><h3 id="Tilemap的最小单位—瓦片"><a href="#Tilemap的最小单位—瓦片" class="headerlink" title="Tilemap的最小单位—瓦片"></a>Tilemap的最小单位—<strong>瓦片</strong></h3><p><strong>创建瓦片的方法</strong></p><ol><li>Window-2D-Tile Palette瓦片调色板窗口创建</li><li>点击左边<strong>Create New Palette</strong>，然后选择存储路径</li><li>将需要的资源拖入到Palette窗口中，并选择需要保存的路径。就能成功创建瓦片</li></ol><p><strong>瓦片面板参数</strong></p><img src="/blog/Unity%E6%A0%B8%E5%BF%83/image-20220406204048128.png" class="" title="image-20220406204048128"><h3 id="瓦片调色板窗口"><a href="#瓦片调色板窗口" class="headerlink" title="瓦片调色板窗口"></a>瓦片调色板窗口</h3><p><strong>创建调色板窗口相关</strong></p><img src="/blog/Unity%E6%A0%B8%E5%BF%83/image-20220406204944178.png" class="" title="image-20220406204944178"><ul><li>Rectangle：矩形瓦片适合2D 横版游戏</li><li>Hexagon：六边形瓦片适合SLG策略游戏</li><li>Isometric：等距瓦片，可以进行上下移动</li><li>Isometric Z as Y：与前者类似，只不过多了一个Z轴，转化局部的Y轴，模拟伪Z轴</li></ul><p><strong>窗口操作技巧</strong></p><img src="/blog/Unity%E6%A0%B8%E5%BF%83/image-20220406205817939.png" class="" title="image-20220406205817939"><p><strong>编辑瓦片地图</strong></p><ol><li>创建好瓦片调色板窗口</li><li>将需要用到的所用地形素材全部拖入到调色板中</li><li>在Hierarchy面板中创建2D Object中的<strong>Tilemap</strong>，选择合适的瓦片网格布局</li><li>首先在调色板窗口点击<strong>Edit</strong>，启用编辑窗口</li><li>然后用<strong>吸管工具</strong> 吸取想要创建的地图，就可以直接在Scene窗口进行绘制</li></ol><p><strong>Isometric Z as Y 瓦片地图注意事项</strong></p><ul><li>这种等距瓦片具有Z轴的概念<ol><li>这就导致了瓦片图片和菱形地面具有一个高度差，两者不能贴合，这是图片的<strong>轴心点</strong>照成的</li><li>将图片的轴心点移动到 <strong>图片居中</strong>位置，就能解决高度差问题</li></ol></li></ul><ul><li>在3D游戏中，默认是由Z轴，来决定对象的深度，但2D游戏并没有Z轴，所以适用等距瓦片时要更改下默认的设置<ol><li>在Unity编辑器的<strong>Edit</strong>窗口，选择<strong>Project Setting</strong>，再选择<strong>Graphics</strong>。最后将<strong>Transparency Sort Mode</strong>(排序模式)改为Custom Axis(自定义轴)进行排序</li><li>然后将下方<strong>Transparency Sort Axis</strong> 的参数改为<strong>(0,1,-0.26)</strong></li><li>设置完参数后，将<strong>Tiemap Renderer</strong>脚本中的<strong>Mode</strong>(渲染模式)改为<strong>Individual</strong></li></ol></li></ul><ul><li>也可以不通过更改轴心点的方式，解决高度差的问题<ol><li>通过取消勾选下方的Lock Z Position</li><li>然后吸取图片后，就能通过加号和减号来控制高度</li></ol></li></ul><h3 id="瓦片地图关键脚本和碰撞器"><a href="#瓦片地图关键脚本和碰撞器" class="headerlink" title="瓦片地图关键脚本和碰撞器"></a>瓦片地图关键脚本和碰撞器</h3><img src="/blog/Unity%E6%A0%B8%E5%BF%83/image-20220406221746677.png" class="" title="image-20220406221746677"><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>使用等距瓦片创建地图，并实现人物在地图上的移动</p><p><strong>注意事项</strong>：</p><p>人物导入之前</p><ul><li><p>需要将人物的轴心点改到图片人物的脚底位置</p></li><li><p>然后将Sprite Renderer 中的<strong>Sprite sort Point</strong>(排序点)修改为<strong>Pivot</strong>，就能让人物底部出现在地面上</p></li></ul><p>地图资源导入前</p><ul><li>需要将瓦片地图的轴心点移动到地图表面的中央，使其“下沉”,用于制作地面<ol><li>将轴心点移动到瓦片地图下方的中央，可以使其“上抬”,用于制作墙体</li></ol></li></ul><p>等距瓦片的地图排序问题</p><ul><li>排序层相同时，会通过轴心点的Y轴进行渲染图片，轴心点低的渲染在前方，高的渲染在后方(排序方式一定要修改为<strong>Pivot</strong>)</li><li>若排序层不同，则优选排序层的大小进行渲染，排序层大的渲染在前方，小的渲染在后方</li></ul><p>等距瓦片地图碰撞相关问题</p><ul><li>若地图地面添加碰撞器，则人物则不能在表面移动。</li><li>取消人物的重力，就能解决单个碰撞器下落的问题</li><li>等距瓦片的碰撞类型选择<strong>Grid</strong></li></ul><hr><h2 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h2><p>打开Window-&gt;Animation-&gt; Animation（或者Ctrl+6） 就能打开动画窗口</p><img src="/blog/Unity%E6%A0%B8%E5%BF%83/image-20220407111739539.png" class="" title="image-20220407111739539"><h3 id="创建编辑Animation"><a href="#创建编辑Animation" class="headerlink" title="创建编辑Animation"></a>创建编辑Animation</h3><p>创建动画</p><ul><li>在场景中<strong>选中</strong>想要创建动画的<strong>对象</strong></li><li>然后动画窗口就会出现一个Create</li><li>点击创建后就能选择动画文件所保存的位置</li></ul><blockquote><p>当我们成功创建完一个动画后，Unity会做以下操作</p><p>1、对象上会多一个Animator组件</p><p>2、保存的位置中，会生成一个三角形的动画文件，以及方形的状态机文件</p><p>3、新生成的动画文件会被添加到状态机文件中</p><p>4、Animator组件中的Controller(状态机)参数 会自动关联对象</p></blockquote><h3 id="编辑动画"><a href="#编辑动画" class="headerlink" title="编辑动画"></a>编辑动画</h3><p><strong>注意</strong>：编辑动画时，要注意一定要<strong>选中对象</strong></p><ul><li><strong>创建新动画</strong></li></ul><p><img src="Unity核心/image-20220623100108237.png" alt="image-20220623100108237" style="zoom:125%;" /></p><blockquote><p>点击向下的箭头，可以创建新的动画。之后可以在这里进行动画切换</p><p>当我们新建动画时，Unity会做如下操作</p><p>1、在保存的位置创建一个动画文件</p><p>2、将新建的动画添加到之前的状态机中</p></blockquote><ul><li>添加动画中需要变化的脚本(Add Property)</li></ul><img src="/blog/Unity%E6%A0%B8%E5%BF%83/image-20220623100603079.png" class="" title="image-20220623100603079"><hr><h2 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h2><p>当满足某个条件时，就切换一个状态，且状态是有限的</p><p><strong>动作</strong>系统和<strong>AI</strong>系统，都需要用到有限状态机</p><h3 id="动画状态机"><a href="#动画状态机" class="headerlink" title="动画状态机"></a>动画状态机</h3><p>创建动画状态机</p><ol><li>为场景中的物体创建动画时，会自动创建动画状态机(Animator Contorller)</li><li>也可以在Project窗口中右键创建Animator Contorller</li></ol><p>动画状态机面板</p><img src="/blog/Unity%E6%A0%B8%E5%BF%83/image-20220407170333210.png" class="" title="image-20220407170333210"><p>Layers：动画层级页签，不同层级可以添加多个动画，权重(Weight)高的层级会覆盖低层级</p><blockquote><p>可以通过点击 “+”号添加层级，不同层中可以有多个动画</p><p>不同层的动画可以同时播放</p></blockquote><p>Parametes：参数页签，为动画状态机添加<strong>控制状态</strong>切换的参数</p><blockquote><p>通过点击”+”号，可以添加 状态切换时的条件</p></blockquote><ul><li>Float：当大于，或者小于该数时，可以满足条件</li><li>int：当大于、小于、等于、或不等于该数时，可以满足条件</li><li>bool：判断T OR F ，满足条件</li><li>trigger：没有条件判断，点击后会<strong>自动切换回来</strong>，适用于来换切换状态的情况</li></ul><img src="/blog/Unity%E6%A0%B8%E5%BF%83/image-20220407170801456.png" class="" title="image-20220407170801456"><h3 id="添加动画切换条件"><a href="#添加动画切换条件" class="headerlink" title="添加动画切换条件"></a>添加动画切换条件</h3><p>在Parameters参数页签中点击“＋”号，可以添加四种条件页签</p><blockquote><p>1、在一个状态中点击右键，选择Make Transition，即可连接到另一个状态</p><p>2、然后点击左侧面板的”+”号，为状态添加条件页签</p><p>3、再点击Inspector面板中的”+” 号，添加切换条件</p><p>注意：一般要取消勾选Inspector面板中的Has Exit Time参数。这样就可以取消动画时的退出时间，达到流畅切换动画的效果</p></blockquote><h3 id="代码控制状态机的切换"><a href="#代码控制状态机的切换" class="headerlink" title="代码控制状态机的切换"></a>代码控制状态机的切换</h3><p>Animator面板参数如下</p><p><img src="Unity核心/image-20220624075436569-16563743729501.png" alt="image-20220624075436569" style="zoom:150%;" /></p><ul><li><p>Controller：对应的动画控制器</p><blockquote><p>默认在对象创建动画时，会自动关联</p></blockquote></li></ul><p><strong>Animator中的API</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Animator myAnim;</span><br><span class="line">myAnim = <span class="keyword">this</span>.GetComponent&lt;Animator&gt;();</span><br><span class="line"></span><br><span class="line">myAnim.SetFloat(<span class="string">&quot;条件名&quot;</span>,<span class="number">2f</span>);</span><br><span class="line">myAnim.SetInteger(<span class="string">&quot;条件名&quot;</span>,<span class="number">2</span>);</span><br><span class="line">myAnim.SetBool(<span class="string">&quot;条件m&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">myAnim.SetTrigger(<span class="string">&quot;条件名&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="2D动画"><a href="#2D动画" class="headerlink" title="2D动画"></a>2D动画</h2><h3 id="序列帧动画"><a href="#序列帧动画" class="headerlink" title="序列帧动画"></a>序列帧动画</h3><p>原理是在一个循环中按一定时间间隔不停的切换显示图片</p><h4 id="通过代码原理创建帧序列动画"><a href="#通过代码原理创建帧序列动画" class="headerlink" title="通过代码原理创建帧序列动画"></a>通过代码原理创建帧序列动画</h4><p>思路：通过连续的更改sprite中关联的图片，达到帧序列动画的效果</p><blockquote><p>方法：</p><p>1、创建一个2Dsprite </p><p>2、创建一个sprite数组，根据数组中填入的大小，用来关联所有图片</p><p>3、声明一个spriteRenderer 渲染图片，time记录时间，nowIndex记录数字索引</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewBehaviourScript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//声明一个数组</span></span><br><span class="line">    <span class="keyword">public</span> Sprite[ ]  spr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明sprite渲染器</span></span><br><span class="line">    <span class="keyword">private</span> SpriteRenderer sr;</span><br><span class="line">    <span class="comment">//用来记时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> time = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//当前显示索引，即当前的图片</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> nowindex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//获取组件</span></span><br><span class="line">        sr = <span class="keyword">this</span>.GetComponent&lt;SpriteRenderer&gt;();</span><br><span class="line">        <span class="comment">//数组当前显示的图片</span></span><br><span class="line">        sr.sprite = spr[nowindex];  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        time += Time.deltaTime;</span><br><span class="line">        <span class="keyword">if</span>(time &gt; <span class="number">0.03f</span>) <span class="comment">//每0,.03s 切换图片</span></span><br><span class="line">        &#123;</span><br><span class="line">            nowindex++; <span class="comment">//索引增加，切换图片</span></span><br><span class="line">            <span class="keyword">if</span>(nowindex &gt;= spr.Length)  <span class="comment">//如果当前索引大于数组长度</span></span><br><span class="line">            &#123;</span><br><span class="line">                nowindex = <span class="number">0</span>;   <span class="comment">//重新开始播放</span></span><br><span class="line">            &#125;</span><br><span class="line">            sr.sprite = spr[nowindex]; <span class="comment">//切换图片、</span></span><br><span class="line">            time = <span class="number">0</span>;   <span class="comment">//时间清零</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Animation窗口制作帧序列动画"><a href="#Animation窗口制作帧序列动画" class="headerlink" title="Animation窗口制作帧序列动画"></a>Animation窗口制作帧序列动画</h4><p>方法1：</p><ol><li><p>创建一个空物体</p></li><li><p>然后在Animation窗口中创建一个动画</p><blockquote><p>创建完毕之后，包含一个三角形的动画文件、方形的状态机文件、以及对象上关联的Animator脚本文件</p></blockquote></li><li><p>选中三角形的动画文件，更改其动画帧率</p><blockquote><p>注意：可以通过修改<strong>动画帧率</strong>来控制动画的播放速度</p><p>选中动画文件，在Inspector窗口中更改为Debug模式,其中就可以修改动画帧率</p><p>注意：更改动画帧率之前，需要删除动画窗口中的关键帧</p></blockquote></li><li><p>最后选中空物体，然后<strong>直接将某一个动作的帧序列拖入窗口中</strong></p></li></ol><p>方法2：</p><p><strong>直接将某个一个动作的图片直接拖入到Hierarchy窗口中</strong></p><blockquote><p>该方法一般只用于制作第一个动画</p></blockquote><p>注意：若出现无法将帧序列拖入到动画窗口中的情况，看看有没有选中物体</p><h4 id="Animator切换动画"><a href="#Animator切换动画" class="headerlink" title="Animator切换动画"></a>Animator切换动画</h4><ol><li>在Animator状态机中连接两个需要切换的状态</li></ol><p><img src="Unity核心/image-20220624085740489-16560574192191.png" alt="image-20220624085740489" style="zoom:200%;" /></p><ol><li>为两个状态添加<strong>条件页签</strong></li></ol><p><img src="Unity核心/image-20220624085841631.png" alt="image-20220624085841631" style="zoom:150%;" /></p><ol><li>再选中切换连线，取消<strong>Has Exit Time</strong>参数，并添加<strong>切换条件</strong></li></ol><p><img src="Unity核心/image-20220624090009970-16560574216722.png" alt="image-20220624090009970" style="zoom:150%;" /></p><ol><li>最后在脚本中，用代码控制动画切换</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Animator animator;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Input.GetKey(KeyCode.A) || Input.GetKey(KeyCode.D))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            animator.SetBool(<span class="string">&quot;IsRun&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            animator.SetBool(<span class="string">&quot;IsRun&quot;</span>,<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>示例：</p><p>为人物添加待机、行走、跳跃等动画</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerMove</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> runSpeed = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> upForce = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D myRigidbody;</span><br><span class="line">    <span class="keyword">private</span> Animator myAnim;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        myRigidbody = <span class="keyword">this</span>.GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        <span class="comment">//为对象依附动画状态机组件</span></span><br><span class="line">        myAnim = <span class="keyword">this</span>.GetComponent&lt;Animator&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Run();</span><br><span class="line">        <span class="comment">//按住时，会播放动画</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKey(KeyCode.A) || Input.GetKey(KeyCode.D))</span><br><span class="line">        &#123;</span><br><span class="line">            myAnim.SetBool(<span class="string">&quot;RunBool&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            myAnim.SetBool(<span class="string">&quot;RunBool&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//通过AD键控制水平方向</span></span><br><span class="line">        <span class="built_in">float</span> direction = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (direction &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当按下a时，将自身坐标改为-180°</span></span><br><span class="line">            <span class="keyword">this</span>.transform.rotation = Quaternion.AngleAxis(<span class="number">-180</span>, Vector2.up);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(direction &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当按下d时，将自身坐标改为0°</span></span><br><span class="line">            <span class="keyword">this</span>.transform.rotation = Quaternion.AngleAxis(<span class="number">0</span>, Vector2.up);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用给与人物速度去控制移动。由于重力的存在，所以不能无视人物Y轴的速度，不然人物在Y轴做自由落体运动</span></span><br><span class="line">        <span class="keyword">if</span>(direction != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            myRigidbody.velocity = <span class="keyword">new</span> Vector2(runSpeed * direction, myRigidbody.velocity.y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按空格时给一个向上的力，使其跳跃</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            myRigidbody.AddForce(Vector2.up * upForce);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果Y轴上有速度，就播放跳跃动画</span></span><br><span class="line">        <span class="keyword">if</span> (myRigidbody.velocity.y != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            myAnim.SetBool(<span class="string">&quot;JumpBool&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            myAnim.SetBool(<span class="string">&quot;JumpBool&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2D骨骼动画"><a href="#2D骨骼动画" class="headerlink" title="2D骨骼动画"></a>2D骨骼动画</h3><p>将一张图片分割为n个部位，为每个部位绑定骨骼，就能控制骨骼旋转移动</p><p>达到最少的2D美术资源做出流畅的2D动画效果</p><p>主要制作方式</p><ol><li>利用Unity2018新功能 <strong>2D Animation</strong> 工具制作</li><li>利用跨平台骨骼动画制作工具 <strong>Spine</strong> 制作</li></ol><p>Skinning Editor 主要参数</p><img src="/blog/Unity%E6%A0%B8%E5%BF%83/image-20220408150232830.png" class=""><p><strong>创建骨骼相关</strong></p><p>创建骨骼有三种方式</p><img src="/blog/Unity%E6%A0%B8%E5%BF%83/image-20220408150314704.png" class="" title="image-20220408150314704"><p><strong>蒙皮相关</strong></p><p>使用蒙皮时，先自动，再手动</p><img src="/blog/Unity%E6%A0%B8%E5%BF%83/image-20220408151452607.png" class=""><p><strong>骨骼动画的使用</strong></p><ul><li>将绑定好骨骼的图片导入场景<ol><li>为其添加<strong>Sprite Skin</strong> 脚本</li><li>点击<strong>Sprite Skin</strong> 脚本上的<strong>Create Bones</strong>为其添加骨骼</li></ol></li></ul><p><strong>图集图片骨骼编辑</strong></p><ol><li>将图集的Sprite Mode 设置为<strong>Multiple</strong></li><li>将图集切片</li><li>为切片图集绑定骨骼和蒙皮</li><li>在场景中添加切片图片的根对象</li><li>将图片拼凑起来，并注意身体各部位的父子关系</li><li>在图片的Additional Settings 中修改图片的层级</li></ol><h3 id="反向动力学IK"><a href="#反向动力学IK" class="headerlink" title="反向动力学IK"></a>反向动力学IK</h3><p>和骨骼动画恰好相反，子节点带动父节点</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-3d数学基础</title>
      <link href="blog/Unity-3d%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
      <url>blog/Unity-3d%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="1、3D数学基础"><a href="#1、3D数学基础" class="headerlink" title="1、3D数学基础"></a>1、3D数学基础</h1><h2 id="1-1-Mathf"><a href="#1-1-Mathf" class="headerlink" title="1.1 Mathf"></a>1.1 Mathf</h2><p>知识点一：Mathf和Math</p><ul><li>Math是<strong>C#</strong>中封装好的，用于数学计算的工具<strong>类</strong>，位于<strong>System</strong>命名空间中</li><li>Mathf是<strong>Unity</strong>中封装好的，用于数学计算的工具<strong>结构体</strong>，位于<strong>UnityEngine</strong>命名空间中</li></ul><p>知识点二：两者的区别</p><ul><li>Mathf 是Unity专门封装的，不仅包含了Math中的方法，还多了适用于游戏开发的方法</li><li>所以在Unity中一般用Mathf 进行游戏开发</li></ul><p>知识点三：Mathf中的常用方法，一般只计算一次</p><ul><li>PI</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(Mathf.PI);</span><br></pre></td></tr></table></figure><ul><li>取绝对值-Abs</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(Mathf.Abs(<span class="number">-1</span>));</span><br></pre></td></tr></table></figure><ul><li>向上取整-CeilToInt</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> f = <span class="number">1.3f</span>;</span><br><span class="line">print(Mathf.CeilToInt(f));<span class="comment">//得到2</span></span><br></pre></td></tr></table></figure><ul><li>向下取整-FloorToInt</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(Mathf.FloorToInt(f));<span class="comment">//得到1，强转也是向下取整</span></span><br></pre></td></tr></table></figure><ul><li>钳制函数-Clamp</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Clamp(x,y,z) y，z分别为最小和最大值，若x值过了该区间，则会取临界的值</span></span><br><span class="line">print(Mathf.Clamp(<span class="number">9</span>,<span class="number">10</span>,<span class="number">20</span>));<span class="comment">//结果为10</span></span><br></pre></td></tr></table></figure><ul><li>最大值和最小值</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(Mathf.Max(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line">print(Mathf.Min(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</span><br></pre></td></tr></table></figure><ul><li>一个数的n次幂-Pow</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;一个数的n次方&quot;</span>+Mathf.Pow(<span class="number">2</span>,<span class="number">3</span>));<span class="comment">//2的3次方，结果为8</span></span><br></pre></td></tr></table></figure><ul><li>四舍五入-RoundToInt</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;四舍五入&quot;</span>+Mathf.RoundToInt(<span class="number">1.4f</span>));<span class="comment">//结果为1</span></span><br><span class="line">print(<span class="string">&quot;四舍五入&quot;</span>+Mathf.RoundToInt(<span class="number">1.5f</span>));<span class="comment">//结果为2</span></span><br></pre></td></tr></table></figure><ul><li>返回一个数的平方根-Sqrt</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(Mathf.Sqrt(<span class="number">16</span>));<span class="comment">//结果为4</span></span><br></pre></td></tr></table></figure><ul><li>判断一个数是否为2的n次方-IsPowerOfTwo</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(Mathf.IsPowerOfTwo(<span class="number">1</span>));<span class="comment">//返回结果为false</span></span><br></pre></td></tr></table></figure><ul><li>判断正负数</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(Mathf.Sign(<span class="number">10</span>));<span class="comment">//返回结果为1</span></span><br><span class="line">print(Mathf.Sign(<span class="number">-10</span>));<span class="comment">//返回结果为-1</span></span><br></pre></td></tr></table></figure><p>知识点四：Mathf中的常用方法，一般不停计算</p><p><strong>插值运算</strong>(Lerp)</p><ul><li>Lerp函数公式：</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//t 为插值系数，取值范围为0~1</span></span><br><span class="line">result=Mathf.Lerp(start,end,t);</span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数的计算方式如下</span></span><br><span class="line">result=start+(end-start)*t</span><br></pre></td></tr></table></figure><ul><li>插值运算用法一：</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每帧改变start的值，速度变化先快后慢，最后无线趋近于end，类似于对数函数</span></span><br><span class="line">start=Mathf.Lerp(start,<span class="number">10</span>,Time.deltaTime);</span><br></pre></td></tr></table></figure><ul><li>插值运算用法二：</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每帧改变t的值，速度变化为匀速，当t&gt;1时，得到结果，类似于一次函数</span></span><br><span class="line">time+=Time.deltaTime;</span><br><span class="line">result=Mathf.Lerp(start,<span class="number">10</span>,time);</span><br></pre></td></tr></table></figure><p>总结：</p><p>插值运算，可以用于跟随系统</p><h3 id="示例-物体跟随"><a href="#示例-物体跟随" class="headerlink" title="示例:物体跟随"></a>示例:物体跟随</h3><p>使用插值运算实现方块跟随</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Vector3 pos;        <span class="comment">//记录a开始位置</span></span><br><span class="line">    <span class="keyword">private</span> Vector3 bNowPos;    <span class="comment">//b当前的位置</span></span><br><span class="line">    <span class="keyword">private</span> Vector3 startPos;       </span><br><span class="line">    <span class="keyword">public</span> Transform B;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> time;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">       <span class="comment">// 1、先快后慢</span></span><br><span class="line">        pos = <span class="keyword">this</span>.transform.position;</span><br><span class="line">        pos.x = Mathf.Lerp(pos.x, B.position.x, Time.deltaTime);</span><br><span class="line">        pos.y = Mathf.Lerp(pos.y, B.position.y, Time.deltaTime);</span><br><span class="line">        pos.z = Mathf.Lerp(pos.z, B.position.z, Time.deltaTime);</span><br><span class="line">        <span class="keyword">this</span>.transform.position = pos;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">/--------------------------------------------------------------------------/</span><br><span class="line">      </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、匀速</span></span><br><span class="line">        <span class="keyword">if</span> (bNowPos != B.transform.position)</span><br><span class="line">        &#123;</span><br><span class="line">            time = <span class="number">0</span>;</span><br><span class="line">            bNowPos = B.transform.position;</span><br><span class="line">            startPos=<span class="keyword">this</span>.transform.position;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        time+=Time.deltaTime;</span><br><span class="line">        pos.x = Mathf.Lerp(startPos.x, bNowPos.x, time);</span><br><span class="line">        pos.y = Mathf.Lerp(startPos.y, bNowPos.y, time);</span><br><span class="line">        pos.z = Mathf.Lerp(startPos.z, bNowPos.z, time);</span><br><span class="line">        <span class="keyword">this</span>.transform.position = pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-三角函数"><a href="#1-2-三角函数" class="headerlink" title="1.2 三角函数"></a>1.2 三角函数</h2><p><strong>角度和弧度</strong></p><img src="/blog/Unity-3d%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220317165328554-16475072135311.png" class="" title="image-20220317165328554"><p>知识点一：弧度、角度相互转化</p><ul><li>弧度转角度：Mathf.Rad2Deg</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> rad = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">float</span> anger = rad* Mathf.Rad2Deg;</span><br></pre></td></tr></table></figure><ul><li>角度转弧度：Mathf.Deg2Rad</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">anger = <span class="number">1</span>;</span><br><span class="line">rad = anger * Mathf.Deg2Rad;</span><br></pre></td></tr></table></figure><p><strong>三角函数</strong></p><p>Mathf 中的三角函数的相关函数，在传参时，需要传入弧度值。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(Mathf.Sin(<span class="number">30</span>*Mathf.Deg2Rad));</span><br><span class="line">print(Mathf.Cos(<span class="number">60</span>*Mathf.Deg2Rad));</span><br></pre></td></tr></table></figure><p><strong>反三角函数</strong></p><p>通过反三角函数，可以将得到的值，反推到正选或余弦值对应的<strong>弧度</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rad = Mathf.Asin(<span class="number">0.5f</span>);</span><br><span class="line">print(rad*Mathf.Rad2Deg);</span><br><span class="line"></span><br><span class="line">rad=Mathf.Acos(<span class="number">0.5f</span>);</span><br><span class="line">print(rad*Mathf.Rad2Deg);</span><br></pre></td></tr></table></figure><p>注意：</p><p>Unity提供的数学计算 使用的是 <strong>弧度制</strong></p><h3 id="示例：实现物体按曲线移动"><a href="#示例：实现物体按曲线移动" class="headerlink" title="示例：实现物体按曲线移动"></a>示例：实现物体按曲线移动</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//面朝向移动速度</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> moveSpeed = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//左右曲线移动变化速度</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> changeSpeed = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//左右曲线移动距离控制</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> changeSize = <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> time = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//面朝向移动</span></span><br><span class="line">    <span class="keyword">this</span>.transform.Translate(Vector3.forward*moveSpeed*Time.deltaTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左右曲线移动</span></span><br><span class="line">    time +=Time.deltaTime;  <span class="comment">//  时间充当正弦函数的x轴</span></span><br><span class="line">    <span class="keyword">this</span>.transform.Translate(Vector3.right * changeSize * Time.deltaTime * Mathf.Sin(time));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-坐标系"><a href="#1-3-坐标系" class="headerlink" title="1.3 坐标系"></a>1.3 坐标系</h2><h4 id="世界坐标系"><a href="#世界坐标系" class="headerlink" title="世界坐标系"></a>世界坐标系</h4><p>原点：世界的中心点</p><p>轴向：世界坐标系的<strong>三个轴向是固定</strong>的</p><img src="/blog/Unity-3d%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220320155107705-16477626711551.png" class="" title="image-20220320155107705"><p><strong>相关API</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.transform.position;<span class="comment">//世界坐标位置</span></span><br><span class="line"><span class="keyword">this</span>.transform.rotation;<span class="comment">//四元数</span></span><br><span class="line"><span class="keyword">this</span>.transform.eulerAngles;<span class="comment">//欧拉角</span></span><br><span class="line"><span class="keyword">this</span>.transform.lossyScale;<span class="comment">//缩放</span></span><br></pre></td></tr></table></figure><h4 id="物体坐标系"><a href="#物体坐标系" class="headerlink" title="物体坐标系"></a>物体坐标系</h4><p>原点：物体的中心点(建模时决定)</p><p>轴向：</p><p>物体<strong>右方</strong>为<strong>x</strong>轴正方向</p><p>物体<strong>上方</strong>为<strong>y</strong>轴正方向</p><p>物体<strong>前方</strong>为<strong>z</strong>轴正方向</p><img src="/blog/Unity-3d%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220320155344179.png" class="" title="image-20220320155344179"><p><strong>相关API</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.transform.localPosition;<span class="comment">//世界坐标位置</span></span><br><span class="line"><span class="keyword">this</span>.transform.localRotation;<span class="comment">//四元数</span></span><br><span class="line"><span class="keyword">this</span>.transform.localEulerAngles;<span class="comment">//欧拉角</span></span><br><span class="line"><span class="keyword">this</span>.transform.localScale;<span class="comment">//缩放</span></span><br></pre></td></tr></table></figure><h4 id="屏幕坐标系"><a href="#屏幕坐标系" class="headerlink" title="屏幕坐标系"></a>屏幕坐标系</h4><p>原点：屏幕左下角</p><p>轴向：</p><p>右方为x轴正方向</p><p>上方为y轴正方向</p><p><strong>最大宽高</strong>：</p><p>Screen.width</p><p>Screen.height</p><img src="/blog/Unity-3d%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220320155536492.png" class="" title="image-20220320155536492"><p><strong>相关API</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input.mousePosition;<span class="comment">//得到屏幕鼠标输入位置</span></span><br><span class="line">Screen.width;<span class="comment">//屏幕最大宽度</span></span><br><span class="line">Screen.height;<span class="comment">//屏幕最大高度</span></span><br></pre></td></tr></table></figure><h4 id="视口坐标系"><a href="#视口坐标系" class="headerlink" title="视口坐标系"></a>视口坐标系</h4><p>原点：屏幕左下角</p><p>轴向：</p><p>右方为x轴正方向</p><p>上方为y轴正方向</p><p><strong>特点</strong>：和屏幕坐标类似，将坐标单位化</p><p>左下角(0,0)</p><p>右下角(1,1)</p><hr><h1 id="2、向量"><a href="#2、向量" class="headerlink" title="2、向量"></a>2、向量</h1><h2 id="2-1-向量"><a href="#2-1-向量" class="headerlink" title="2.1 向量"></a>2.1 向量</h2><h4 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h4><p>Vector3 有两种几何意义</p><ol><li>位置，代表一个点</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="keyword">this</span>.transform.position);</span><br></pre></td></tr></table></figure><ol><li>方向，代表一个方向</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="keyword">this</span>.transform.forward);</span><br></pre></td></tr></table></figure><h4 id="两点-决定一个向量"><a href="#两点-决定一个向量" class="headerlink" title="两点 决定一个向量"></a>两点 决定一个向量</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此时A和B的几何意义 是两个点</span></span><br><span class="line">Vector3 A = <span class="keyword">new</span> Vector3(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">Vector3 B = <span class="keyword">new</span> Vector3(<span class="number">5</span>,<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时AB的几何意义是 两个向量</span></span><br><span class="line">Vector3 AB=B-A;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="零向量和负向量"><a href="#零向量和负向量" class="headerlink" title="零向量和负向量"></a>零向量和负向量</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(Vector3.zero);<span class="comment">//零向量</span></span><br><span class="line"></span><br><span class="line">print(-Vector3.forward);<span class="comment">//负向量</span></span><br></pre></td></tr></table></figure><h4 id="向量的模长"><a href="#向量的模长" class="headerlink" title="向量的模长"></a>向量的模长</h4><p>API：<strong>magnitude</strong>，获取向量模长的成员属性</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vector3 c = <span class="keyword">new</span> Vector3(<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line">print(C.magnitude);</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以使用Distance()方法</span></span><br><span class="line">Vector3.Distance(A,B);</span><br></pre></td></tr></table></figure><h4 id="单位向量"><a href="#单位向量" class="headerlink" title="单位向量"></a>单位向量</h4><p>模长为1的向量为单位向量</p><p>公式：</p><p>A向量(x,y,z)</p><p><strong>单位向量=(x/模长,y/模长,z/模长)</strong></p><p><strong>API</strong>：<strong>normalized</strong>,获取单位向量的成员属性</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(AB.normalized);</span><br></pre></td></tr></table></figure><h2 id="2-2-向量的四则运算"><a href="#2-2-向量的四则运算" class="headerlink" title="2.2 向量的四则运算"></a>2.2 向量的四则运算</h2><p>位置与向量进行运算，就是将向量进行<strong>平移</strong></p><img src="/blog/Unity-3d%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220320212844155.png" class="" title="image-20220320212844155"><p>总结：</p><ol><li>向量加减法，主要用于<strong>位置平移</strong>和向量计算。</li><li>向量乘除法，主要用于<strong>模长放大缩小</strong></li></ol><h5 id="示例：摄像机跟随"><a href="#示例：摄像机跟随" class="headerlink" title="示例：摄像机跟随"></a>示例：<strong>摄像机跟随</strong></h5><p>摄像机一直在物体的后方4米，向上7米的位置</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//摄像机跟随</span></span><br><span class="line">    <span class="comment">//1.物体位置：A(x1,y1,z1);</span></span><br><span class="line">    <span class="comment">//2.摄像机位置：B(x2,y2,z2);</span></span><br><span class="line">    <span class="comment">//3.BA：(x1-x2=4,y1-y2=0,z1-z2=-7)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LateUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//物体位置信息</span></span><br><span class="line">        Vector3 A = <span class="keyword">this</span>.transform.position;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向量BA</span></span><br><span class="line">        Vector3 BA = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">-7</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//相机位置</span></span><br><span class="line">        Vector3 B = A - BA; </span><br><span class="line">        </span><br><span class="line">        Camera.main.transform.position = B;</span><br><span class="line">        <span class="comment">//相机看向物体</span></span><br><span class="line">        Camera.main.transform.LookAt(A);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-向量点乘"><a href="#2-3-向量点乘" class="headerlink" title="2.3 向量点乘"></a>2.3 向量点乘</h2><img src="/blog/Unity-3d%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220321160334033.png" class="" title="image-20220321160334033"><h4 id="点乘的几何意义"><a href="#点乘的几何意义" class="headerlink" title="点乘的几何意义"></a>点乘的几何意义</h4><p>点乘可以得到一个向量 在自己向量上<strong>投影的长度</strong></p><img src="/blog/Unity-3d%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220321161458735.png" class="" title="image-20220321161458735"><ul><li>点乘结果 <strong>&gt;</strong> 0，两个向量的夹角为<strong>锐角</strong></li><li>点乘结果 <strong>=</strong> 0，两个向量的夹角为<strong>直角</strong></li><li>点乘结果 <strong>&lt;</strong> 0，两个向量的夹角为<strong>钝角</strong></li></ul><p> 可以利用这个规律<strong>判断敌人的大致方位</strong></p><p><strong>点乘API</strong>：</p><p>Vector3.Dot(向量1,向量2);</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Public transform target;</span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> dotResult = Vector3.Dot(<span class="keyword">this</span>.transform.forward,target.position-<span class="keyword">this</span>.transform.position);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dotResult &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    print(<span class="string">&quot;它在前方&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    print(<span class="string">&quot;它在后方&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="点乘推导公式算出夹角-面试题"><a href="#点乘推导公式算出夹角-面试题" class="headerlink" title="点乘推导公式算出夹角(面试题)"></a>点乘推导公式算出夹角(面试题)</h4><img src="/blog/Unity-3d%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220321164251030.png" class="" title="image-20220321164251030"><p>当两个向量为单位向量时，<strong>余弦值就等于两个单位向量的点乘结果</strong></p><ol><li><strong>用单位向量算出点乘结果</strong></li><li><strong>用反三角函数得出角度</strong></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.用单位向量算出点乘结果</span></span><br><span class="line"><span class="built_in">float</span> doyResult = Vector3.Dot(<span class="keyword">this</span>.transform.forward,(target.position-<span class="keyword">this</span>.transform.position).normalized);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.用反三角函数得出弧度，在使用Rad2Deg得到角度</span></span><br><span class="line">print(<span class="string">&quot;角度&quot;</span>+ Mathf.Acos(dotResult) * Mathf.Rad2Deg);</span><br></pre></td></tr></table></figure><p>夹角API：</p><p> Vector3.Angle(向量1,向量2);</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector3.Angle(<span class="keyword">this</span>.transform.forward,target.position-<span class="keyword">this</span>.transform.position);</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>向量点乘的意义：</p><ol><li><strong>判断对象的方位</strong></li><li><strong>计算两个向量之间的夹角</strong></li></ol><h4 id="示例：判断物体前后和角度"><a href="#示例：判断物体前后和角度" class="headerlink" title="示例：判断物体前后和角度"></a>示例：判断物体前后和角度</h4><img src="/blog/Unity-3d%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220321164953457.png" class="" title="image-20220321164953457"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1.利用Dot求出两个单位向量的点乘，就是其余弦值</span></span><br><span class="line"><span class="comment">2.将余弦值转换为角度</span></span><br><span class="line"><span class="comment">3.求出两个物体之间的模长</span></span><br><span class="line"><span class="comment">4.条件判断</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform target;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">     <span class="comment">//得到两个单位向量的点乘，也就是其余弦值</span></span><br><span class="line">     <span class="built_in">float</span>  dotResult = Vector3.Dot(<span class="keyword">this</span>.transform.forward, (target.transform.position - <span class="keyword">this</span>.transform.position).normalized);</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">     <span class="comment">//将得到的余弦值转为弧度数，再转为角度数</span></span><br><span class="line">     <span class="built_in">float</span> angle = Mathf.Acos(dotResult) * Mathf.Rad2Deg;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">//得到两个物体之间的距离</span></span><br><span class="line">     <span class="built_in">float</span> length = Vector3.Distance(<span class="keyword">this</span>.transform.position,(target.transform.position - <span class="keyword">this</span>.transform.position));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (angle &gt;= <span class="number">0</span> &amp;&amp; angle &lt;= <span class="number">22.5</span> &amp;&amp; length &lt; <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;发现入侵者,距离前方&quot;</span>+length+<span class="string">&quot;米的&quot;</span>+angle+<span class="string">&quot;度位置&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-4-向量叉乘"><a href="#2-4-向量叉乘" class="headerlink" title="2.4 向量叉乘"></a>2.4 向量叉乘</h2><h4 id="叉乘的计算公式"><a href="#叉乘的计算公式" class="headerlink" title="叉乘的计算公式"></a>叉乘的计算公式</h4><p>向量叉乘得出的结果是一个<strong>向量</strong></p><img src="/blog/Unity-3d%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220321214050859.png" class="" title="image-20220321214050859"><blockquote><p>原向量的X坐标 不会参与 新向量的X坐标计算</p><p>原向量的Y,Z坐标 也依旧不会参与 对应新坐标的Y,Z坐标计算</p></blockquote><p><strong>叉乘API</strong>：</p><p>Vector3<strong>.Cross</strong>(向量1,向量2)；</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vector C = Vector3.Cross(A.position,B.position)；</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(C.y&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    print(<span class="string">&quot;B在A的右边&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    print(<span class="string">&quot;B在A的左边&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="叉乘的几何意义"><a href="#叉乘的几何意义" class="headerlink" title="叉乘的几何意义"></a>叉乘的几何意义</h4><p><strong>A × B</strong> 得到的向量是A和B的<strong>法向量</strong></p><p><strong>A</strong> × <strong>B</strong> = -(<strong>B</strong> × <strong>A</strong>)</p><p><strong>结论</strong>:</p><p>可以用<strong>右手定则</strong>来判断叉乘的位置</p><ul><li>向量<strong>叉乘大于</strong>0，也就是y大于0，说明<strong>B</strong>在<strong>A</strong>的<strong>右侧</strong></li><li>向量<strong>叉乘小于</strong>0，也就是y小于0，说明<strong>B</strong>在<strong>A</strong>的<strong>左侧</strong></li></ul><h4 id="示例：判断物体左右"><a href="#示例：判断物体左右" class="headerlink" title="示例：判断物体左右"></a>示例：判断物体左右</h4><p>判断一个物体B在另一个物体A的左前，左后，右前，右后的哪个方向</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前后用向量的点乘判断</span></span><br><span class="line"><span class="comment">//左右用向量的叉乘判断</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> dotResult;</span><br><span class="line"><span class="keyword">private</span> Vector3 crossResult;</span><br><span class="line"></span><br><span class="line">dotResult = Vector3.Dot(A.forward,B.position-A.position);</span><br><span class="line">corssResult = Vector3.Cross(A.forward,B.position - A.position);</span><br><span class="line"><span class="comment">//向量点乘大于0，B向量在A向量的前方</span></span><br><span class="line"><span class="keyword">if</span>(dotResult &gt;= <span class="number">0</span>)&#123;   </span><br><span class="line">    <span class="comment">//向量叉乘大于0，向量B在向量A的右方</span></span><br><span class="line">    <span class="keyword">if</span>(corssResult.y&gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        print(<span class="string">&quot;B在右前方&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        print(<span class="string">&quot;B在左前方&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//向量叉乘大于0，向量B在向量A的右方</span></span><br><span class="line">    <span class="keyword">if</span>(dotResult.y&gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        print(<span class="string">&quot;B在右后方&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        print(<span class="string">&quot;B在右前方&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-5-向量线性插值"><a href="#2-5-向量线性插值" class="headerlink" title="2.5 向量线性插值"></a>2.5 向量线性插值</h2><p><strong>线性插值</strong></p><p><strong>API</strong>：Vector3.<strong>Lerp(start,end,t)</strong>;</p><p>对两个点进行插值计算，使对象不断趋近于另一个对象</p><p>t的取值范围是0~1</p><p><strong>计算公式</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = start + (end - start)*t;</span><br></pre></td></tr></table></figure><h4 id="线性插值的应用"><a href="#线性插值的应用" class="headerlink" title="线性插值的应用"></a>线性插值的应用</h4><ol><li>每帧改变 <strong>start</strong> 的值(<strong>先快后慢</strong>)，变量是<strong>start</strong> </li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Transform A;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、先快后慢，每帧改变start位置 两者无限接近，趋近于重合</span></span><br><span class="line">A.position = Vector3.Lerp(A.position,<span class="keyword">this</span>.transform.position,Time.deltaTime);</span><br></pre></td></tr></table></figure><ol><li>每帧改变 <strong>t</strong> 的值(<strong>匀速</strong>)，变量是 <strong>t</strong></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Transform B;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> Vector3 startPos;       <span class="comment">//初始坐标</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> time;             <span class="comment">//累计时间</span></span><br><span class="line"><span class="keyword">private</span> Vector3 nowTarget; <span class="comment">//记录物体初始位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、匀速  每帧改变时间t 当t&gt;=1 时 两者重合 并且在目标改变位置后会依然重合</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//当目标位置产生变化时，重置time，放置改变目标位置后对象依然重合的问题</span></span><br><span class="line"><span class="keyword">if</span>(nowTarget != <span class="keyword">this</span>.transform.position)</span><br><span class="line">&#123;</span><br><span class="line"> nowTarget = <span class="keyword">this</span>.transform.position;<span class="comment">//记录物体初始位置</span></span><br><span class="line"> time = <span class="number">0</span>;<span class="comment">//重置时间time</span></span><br><span class="line"> startPos = B.position;  <span class="comment">//记录物体B的初始坐标</span></span><br><span class="line">&#125;</span><br><span class="line">  time += Time.deltaTime;</span><br><span class="line">  B.position = Vector3.Lerp(startPos,nowTarget,time);</span><br></pre></td></tr></table></figure><h4 id="球形插值"><a href="#球形插值" class="headerlink" title="球形插值"></a>球形插值</h4><p><strong>API</strong>：Vector3.<strong>Slerp(start,end,t)</strong>;</p><p>t的取值范围为0~1</p><img src="/blog/Unity-3d%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220322212303138.png" class="" title="image-20220322212303138"><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul><li>线性插值：用于<strong>跟随移动，摄像机跟随</strong></li><li>球形插值：用于<strong>曲线运动，模拟太阳运动弧线</strong></li></ul><h4 id="示例：摄像机插值跟随"><a href="#示例：摄像机插值跟随" class="headerlink" title="示例：摄像机插值跟随"></a>示例：摄像机插值跟随</h4><img src="/blog/Unity-3d%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220322212816598.png" class="" title="image-20220322212816598"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、摄像机跟随物体先快后慢移动</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform A;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、插值公式：result = start + (end - start)*t;</span></span><br><span class="line">    <span class="comment">//2、先快后慢 ，result 和 start 都是相机的位置</span></span><br><span class="line">    <span class="comment">//3、end 是相机终点坐标，end = A物体坐标-(0,-7,4);</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LateUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//摄像机相关 在LateUpdate中执行</span></span><br><span class="line">        Vector3 CA = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">-7</span>, <span class="number">4</span>);</span><br><span class="line">        Vector3 end = A.position - CA;</span><br><span class="line">        <span class="keyword">this</span>.transform.position = Vector3.Lerp(<span class="keyword">this</span>.transform.position, end, Time.deltaTime);       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2、摄像机跟随物体匀速移动</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform A;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> time;</span><br><span class="line">    <span class="keyword">private</span> Vector3 nowTarget;</span><br><span class="line">    <span class="keyword">private</span> Vector3 startPos;</span><br><span class="line">    <span class="comment">//1、result = start + (end - start)*t;</span></span><br><span class="line">    <span class="comment">//2、先快后慢 ，result 和 start 都是相机的位置</span></span><br><span class="line">    <span class="comment">//3、end 是相机终点坐标，end = A物体坐标-(0,-7,4);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LateUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//摄像机相关 在LateUpdate中执行</span></span><br><span class="line"></span><br><span class="line">        Vector3 CA = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">-7</span>, <span class="number">4</span>);</span><br><span class="line">        Vector3 end = A.position - CA;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nowTarget != end)   </span><br><span class="line">        &#123;</span><br><span class="line">            nowTarget = end;    <span class="comment">//end</span></span><br><span class="line">            time = <span class="number">0</span>;</span><br><span class="line">            startPos=<span class="keyword">this</span>.transform.position;   <span class="comment">//start</span></span><br><span class="line">        &#125;</span><br><span class="line">        time+=Time.deltaTime;        <span class="comment">//t</span></span><br><span class="line">        <span class="keyword">this</span>.transform.position=Vector3.Lerp(startPos, nowTarget, time);</span><br><span class="line">        <span class="comment">//摄像机看向物体A</span></span><br><span class="line">        <span class="keyword">this</span>.transform.LookAt(A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3、四元数"><a href="#3、四元数" class="headerlink" title="3、四元数"></a>3、四元数</h1><h2 id="3-1-为什么使用四元数"><a href="#3-1-为什么使用四元数" class="headerlink" title="3.1 为什么使用四元数"></a>3.1 为什么使用四元数</h2><h4 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h4><p><strong>概念</strong>：有三个角度(x,y,z)组成，在<strong>特定坐标系</strong>下用于描述物体的<strong>旋转量</strong></p><p>欧拉角旋转约定</p><img src="/blog/Unity-3d%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220322221640184.png" class="" title="image-20220322221640184"><img src="/blog/Unity-3d%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220322221722417.png" class="" title="image-20220322221722417"><h4 id="万向节死锁"><a href="#万向节死锁" class="headerlink" title="万向节死锁"></a>万向节死锁</h4><p><strong>欧拉角的优缺点</strong></p><p>优点：</p><ul><li>直观，存储空间小</li><li>可以从<strong>一个方向到另一个方向旋转大于180°的角度</strong></li></ul><p><strong>缺点</strong>：</p><ol><li><p><strong>同一旋转的表示不唯一</strong></p><ul><li>就是在Inspector面板中，不同的<strong>物体旋转(x+360°</strong>)所得的<strong>效果相同</strong></li></ul></li><li><p><strong>万向节死锁</strong></p><ul><li>当某个特定轴达到某个特殊值时，<strong>绕一个轴旋转</strong> 可能会<strong>覆盖住另一个轴的旋转</strong>，从而<strong>失去一维的自由度</strong></li><li><strong>Unity中X轴达到90度时，会产生万向节死锁</strong></li></ul></li></ol><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>因为四元数旋转不存在万向节死锁问题</p><p>所以往往用四元数来表示三维空间中的旋转信息</p><hr><h2 id="3-2-什么是四元数"><a href="#3-2-什么是四元数" class="headerlink" title="3.2 什么是四元数"></a>3.2 什么是四元数</h2><h4 id="四元数的构成"><a href="#四元数的构成" class="headerlink" title="四元数的构成"></a>四元数的构成</h4><p><strong>概念</strong>：四元数是由<strong>实数</strong>加上<strong>三个虚数</strong>单位组成，主要用于在<strong>三维空间中表示旋转</strong></p><ul><li>四元数包含了一个<strong>标量</strong>和一个<strong>3D向量</strong><ul><li>[w,v] ，<strong>w为标量</strong> ， <strong>v为3D向量</strong></li><li>可以展开为[<strong>w,(x,y,z)</strong>]</li></ul></li><li>对于一个四元数，就是表示<strong>3D空间中的一个旋转量</strong></li></ul><p><strong>四元数基本公式</strong></p><img src="/blog/Unity-3d%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220323230603593.png" class="" title="image-20220323230603593"><h4 id="Unity中的四元数"><a href="#Unity中的四元数" class="headerlink" title="Unity中的四元数"></a>Unity中的四元数</h4><p>Quaternion：是Unity中表示四元数的<strong>结构体</strong></p><img src="/blog/Unity-3d%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220323230922073.png" class="" title="image-20220323230922073"><p>轴角对公式初始化</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Quaternion q = <span class="keyword">new</span> Quaternion(Mathf.Sin(<span class="number">30</span> * Mathf.Deg2Rad)*<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,Mathf.Cos(<span class="number">30</span>*Mathf.Deg2Rad));</span><br></pre></td></tr></table></figure><p>轴角对<strong>方法</strong>初始化</p><p>四元数初始化<strong>API</strong>：Quaternion.<strong>AngleAxis</strong>(角度,轴)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Quaternino q = Quaternion.AngleAxis(<span class="number">60</span>,Vector3.right);</span><br></pre></td></tr></table></figure><h4 id="四元数和欧拉角相互转换"><a href="#四元数和欧拉角相互转换" class="headerlink" title="四元数和欧拉角相互转换"></a><strong>四元数和欧拉角相互转换</strong></h4><img src="/blog/Unity-3d%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220323232158920.png" class="" title="image-20220323232158920"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 欧拉角转四元数</span></span><br><span class="line">Quaternion q = Quaternion.Euler(<span class="number">60</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//四元数转欧拉角</span></span><br><span class="line">print(q.eulerAngles);</span><br></pre></td></tr></table></figure><h4 id="四元数的优点"><a href="#四元数的优点" class="headerlink" title="四元数的优点"></a>四元数的优点</h4><ol><li>四元数的取值范围是<strong>180° ~ -180°</strong>，所以有同一位置，出现不同角度的情况</li><li>通过<strong>四元数去进行旋转</strong>，<strong>不会有万向节死锁的情况</strong></li></ol><hr><h2 id="3-3-四元数的主要方法"><a href="#3-3-四元数的主要方法" class="headerlink" title="3.3 四元数的主要方法"></a>3.3 四元数的主要方法</h2><h4 id="单位四元数"><a href="#单位四元数" class="headerlink" title="单位四元数"></a>单位四元数</h4><ul><li><strong>单位四元数没有旋转量</strong>，当角度为<strong>0</strong>或者<strong>360</strong>时，对于给定轴就会得到单位四元数</li><li>[1,(0,0,0)] 和 [-1,(0,0,0)] 都是单位四元数。表示没有旋转量</li></ul><p>API</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Transform obj;</span><br><span class="line">obj.rotation = Quaternion.identity;</span><br></pre></td></tr></table></figure><p>作用：</p><p>创建对象时，用于初始化对象赋值</p><h4 id="四元数插值运算"><a href="#四元数插值运算" class="headerlink" title="四元数插值运算"></a>四元数插值运算</h4><p>四元数中同样有如同Vector3的插值运算，<strong>Lerp</strong>和<strong>Slerp</strong></p><ul><li>Lerp的效果相比Slerp更快，但如果旋转范围较大则效果更差</li><li>建议使用<strong>Slerp</strong>进行插值运算</li></ul><p><strong>API</strong>：<strong>Quaternion.Slerp(start,end,time)</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先快后慢</span></span><br><span class="line"><span class="keyword">this</span>.transform.rotation = Quaternion.Slerp(<span class="keyword">this</span>.transform.rotation, B.rotation,Time.deltaTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//匀速</span></span><br><span class="line"><span class="keyword">if</span>(end != B.rotation)</span><br><span class="line">&#123;</span><br><span class="line">  end = B.rotation;</span><br><span class="line">  time = <span class="number">0</span>;    <span class="comment">//重置time</span></span><br><span class="line">&#125;</span><br><span class="line">   time += Time.deltaTime;</span><br><span class="line">   <span class="keyword">this</span>.transform.rotation = Quaternion.Slerp(<span class="keyword">this</span>.transform.rotation, end, time);</span><br></pre></td></tr></table></figure><h4 id="向量指向转四元数"><a href="#向量指向转四元数" class="headerlink" title="向量指向转四元数"></a>向量指向转四元数</h4><p><strong>LookRoataion</strong>方法可以将传入的<strong>面朝向量</strong> 转换为<strong>对应的四元数角度信息</strong></p><p>API：<strong>Quaternino.LookRoataion</strong>(面朝向量)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Transform B;</span><br><span class="line"><span class="keyword">private</span> Vector3 AB;</span><br><span class="line"></span><br><span class="line">AB = B.transform.position - <span class="keyword">this</span>.transform.position;</span><br><span class="line"><span class="keyword">this</span>.transform.rotation = Quaternion.LookRotation(AB);</span><br></pre></td></tr></table></figure><img src="/blog/Unity-3d%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220325155046565.png" class="" title="image-20220325155046565"><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><ol><li>单位四元数：<strong>用于对象角度初始化</strong></li><li>插值运算：<strong>用于平滑旋转</strong></li><li>向量指向转四元数：<strong>用于让对象朝向某方向</strong></li></ol><h2 id="3-4-四元数计算"><a href="#3-4-四元数计算" class="headerlink" title="3.4 四元数计算"></a>3.4 四元数计算</h2><h4 id="四元数相乘"><a href="#四元数相乘" class="headerlink" title="四元数相乘"></a><strong>四元数相乘</strong></h4><p>q3 = q1 * q2 </p><ul><li>两个四元数相乘，得到一个<strong>新的四元数</strong>，代表两个<strong>旋转量的叠加</strong>，相当于旋转</li><li>旋转的是<strong>本地坐标系</strong></li><li><strong>使用四元数相乘改变物体旋转量</strong></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于让物体旋转20°</span></span><br><span class="line">Quaternion q = Quaternion.AngleAxis(<span class="number">20</span>,Vector3.up);</span><br><span class="line"><span class="keyword">this</span>.transform.rotation *= q;</span><br></pre></td></tr></table></figure><h4 id="四元数乘向量"><a href="#四元数乘向量" class="headerlink" title="四元数乘向量"></a>四元数乘向量</h4><p>v2 = q1 <em> v1(四元数在前，向量在后<em>*顺序不能改变</em></em>)</p><ul><li>向量乘一个四元数，相当于<strong>让该向量旋转 四元数的旋转量</strong></li></ul><h2 id="3-5-综合示例"><a href="#3-5-综合示例" class="headerlink" title="3.5 综合示例"></a>3.5 综合示例</h2><img src="/blog/Unity-3d%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220326194210968.png" class="" title="image-20220326194210968"><h4 id="示例1：发射子弹"><a href="#示例1：发射子弹" class="headerlink" title="示例1：发射子弹"></a>示例1：发射子弹</h4><ol><li>编写<strong>枚举类</strong>，将四种子弹存入其中</li><li>声明<strong>子弹对象</strong>，并将创建好的预设体挂载上去</li><li>为子弹预设体编写<strong>子弹位移逻辑</strong>和<strong>销毁逻辑</strong></li><li>编写<strong>Input</strong>类来切换子弹的模式以及开火</li><li>编写开火函数，利用 switch case 编写四种子弹的创建状态</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> E_FireType</span><br><span class="line">&#123;</span><br><span class="line">    one,</span><br><span class="line">    tow,</span><br><span class="line">    Three,</span><br><span class="line">    Round</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ArtPlane</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> E_FireType nowType; <span class="comment">//实例化枚举对象</span></span><br><span class="line">    <span class="keyword">public</span> GameObject bullet;   <span class="comment">//实例化子弹对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> roundNum = <span class="number">4</span>;    <span class="comment">//子弹数量</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha1))</span><br><span class="line">        &#123;</span><br><span class="line">            nowType = E_FireType.one;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha2))</span><br><span class="line">        &#123;</span><br><span class="line">            nowType = E_FireType.tow;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha3))</span><br><span class="line">        &#123;</span><br><span class="line">            nowType = E_FireType.Three;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha4))</span><br><span class="line">        &#123;</span><br><span class="line">            nowType=E_FireType.Round;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            Fire( );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Fire</span>(<span class="params"> </span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">switch</span> ( nowType)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> E_FireType.one: </span><br><span class="line">                 <span class="comment">//在物体原点位置 创建预设体，以及位置和方向</span></span><br><span class="line">                Instantiate(bullet, <span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.rotation);   </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> E_FireType.tow:</span><br><span class="line">                 <span class="comment">//通过两个坐标的运算，在物体的左右各自创建预设体</span></span><br><span class="line">               Instantiate(bullet ,<span class="keyword">this</span>.transform.position - <span class="keyword">this</span>.transform.right * <span class="number">0.5f</span>, <span class="keyword">this</span>.transform.rotation);    </span><br><span class="line">               Instantiate(bullet ,<span class="keyword">this</span>.transform.position + <span class="keyword">this</span>.transform.right * <span class="number">0.5f</span>, <span class="keyword">this</span>.transform.rotation);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> E_FireType.Three:</span><br><span class="line"></span><br><span class="line"> <span class="comment">//原四元数乘以新四元数，相当于加上新四元数的旋转量</span></span><br><span class="line">                Instantiate(bullet,<span class="keyword">this</span>.transform.position,<span class="keyword">this</span>.transform.rotation)；                            Instantiate(bullet,<span class="keyword">this</span>.transform.position,<span class="keyword">this</span>.transform.rotation * Quaternion.AngleAxis(<span class="number">-20</span>,Vector3.up));<span class="comment">//向左旋转20°</span></span><br><span class="line">                Instantiate(bullet,<span class="keyword">this</span>.transform.position,<span class="keyword">this</span>.transform.rotation * Quaternion.AngleAxis(<span class="number">20</span>,Vector3.up));<span class="comment">//向右旋转20d</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> E_FireType.Round:</span><br><span class="line">                <span class="built_in">float</span> angle = <span class="number">360</span> / roundNum;</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; roundNum; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    Instantiate(bullet, <span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.rotation * Quaternion.AngleAxis( i*angle, Vector3.up));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bullet</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> moveSpeed = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Destroy(<span class="keyword">this</span>.gameObject, <span class="number">5</span>);    <span class="comment">//5秒后销毁子弹</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.transform.Translate(Vector3.forward * Time.deltaTime * moveSpeed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="示例2：摄像机高度以及倾斜角"><a href="#示例2：摄像机高度以及倾斜角" class="headerlink" title="示例2：摄像机高度以及倾斜角"></a>示例2：摄像机高度以及倾斜角</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CameraMove</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform target;    <span class="comment">//目标对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> headOffsetH = <span class="number">1</span>;   <span class="comment">//相对头顶的偏移位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> angle = <span class="number">45</span>;    <span class="comment">//倾斜角度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> dis = <span class="number">5</span>;   <span class="comment">//摄像机离观测点的默认距离</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> maxDis = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> minDis = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    Vector3 nowPos; <span class="comment">//摄像机的当前位置</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//通过鼠标滚轮控制摄像机高度</span></span><br><span class="line">        dis += Input.GetAxis(<span class="string">&quot;Mouse ScrollWheel&quot;</span>);</span><br><span class="line">        dis = Mathf.Clamp(dis, minDis, maxDis);</span><br><span class="line">        <span class="comment">//将物体坐标向头顶平移</span></span><br><span class="line">        nowPos = target.position + target.up * headOffsetH;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将物体坐标向背后平移</span></span><br><span class="line">        nowPos = nowPos + Quaternion.AngleAxis(angle, target.right) * -target.forward * dis;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.transform.position = nowPos;</span><br><span class="line">        <span class="keyword">this</span>.transform.LookAt(target.position + target.up);</span><br><span class="line"></span><br><span class="line">        Debug.DrawLine(<span class="keyword">this</span>.transform.position, target.position + target.up);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="4、MonoBehavior中的重要内容"><a href="#4、MonoBehavior中的重要内容" class="headerlink" title="4、MonoBehavior中的重要内容"></a>4、MonoBehavior中的重要内容</h1><h2 id="4-1-延时函数"><a href="#4-1-延时函数" class="headerlink" title="4.1 延时函数"></a>4.1 延时函数</h2><h4 id="什么是延时函数"><a href="#什么是延时函数" class="headerlink" title="什么是延时函数"></a>什么是延时函数</h4><ul><li><p>就是会延时执行的函数，我们可以自己设定<strong>延时要执行的函数</strong>和具体<strong>延时的时间</strong></p></li><li><p>是MonoBehaviour基类中已经实现好了的方法</p></li></ul><h4 id="延迟函数的使用"><a href="#延迟函数的使用" class="headerlink" title="延迟函数的使用"></a>延迟函数的使用</h4><p><strong>延迟函数API</strong>：<strong>Invoke</strong></p><p>注意事项<br>1、延时函数第一个参数填写的是<strong>字符串</strong>，第二个参数单位是秒</p><p>2、延时函数<strong>默认只能是无参的函数</strong>。需要经过一层函数的封装，才能调用有参的函数</p><p>3、延时函数<strong>默认</strong>只能调用<strong>自己对象的函数</strong>，同样是要经过一层函数的封装，才能调用其它对象</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Invoke(函数名，延迟时间);</span></span><br><span class="line"></span><br><span class="line">Invoke(<span class="string">&quot;test&quot;</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    print(<span class="string">&quot;延迟函数被调用&quot;</span>);</span><br><span class="line">    test01(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test01</span>(<span class="params"><span class="built_in">int</span> i</span>)</span>&#123;</span><br><span class="line">    print(<span class="string">&quot;经过封装，调用有参函数&quot;</span>+i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>延迟重复执行函数API</strong>：<strong>InvokeRepeating</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">参数一：函数名字符串</span></span><br><span class="line"><span class="comment">参数二：第一次执行的延迟时间</span></span><br><span class="line"><span class="comment">参数三：之后每次执行的间隔时间</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line">InvokeRepeating(<span class="string">&quot;test&quot;</span>,<span class="number">5</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><strong>取消延迟函数API</strong></p><ul><li>取消脚本上的<strong>所有</strong>延迟函数</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CancelInvoke();</span><br></pre></td></tr></table></figure><ul><li>指定函数名取消</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CancelInvoke(<span class="string">&quot;test&quot;</span>);</span><br></pre></td></tr></table></figure><p>延迟函数受对象失活、销毁的影响</p><ul><li>脚本依附对象或脚本本身<strong>失活</strong>，并<strong>不会影响延迟函数</strong></li><li>脚本依附对象<strong>销毁</strong>或者脚本<strong>移除</strong>，延迟函数<strong>无法执行</strong></li></ul><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><ul><li>将<strong>延迟函数</strong> <strong>OnEnable</strong>( )或 <strong>Start</strong>( )中，对象激活时开启，比如计时等功能</li><li>将<strong>取消</strong>延迟函数写在<strong>OnDisable</strong>( )中，对象失活时取消</li></ul><h4 id="示例：利用延时函数实现计时器"><a href="#示例：利用延时函数实现计时器" class="headerlink" title="示例：利用延时函数实现计时器"></a>示例：利用延时函数实现计时器</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> time = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        InvokeRepeating(<span class="string">&quot;test&quot;</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        print(time + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line">        time++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-协同程序"><a href="#4-2-协同程序" class="headerlink" title="4.2 协同程序"></a>4.2 协同程序</h2><h4 id="Unity中的多线程"><a href="#Unity中的多线程" class="headerlink" title="Unity中的多线程"></a>Unity中的多线程</h4><ul><li><p>使用多线程需要引入<code>using System.Threading</code>命名空间</p></li><li><p>Unity中关于<strong>对象的操作</strong>，只能在<strong>主线程</strong>中执行，<strong>新线程是无法访问</strong>的</p></li><li>Unity中开启的多线程，要手动关闭，否则会一直执行</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="comment">//申明一个变量作为公共内部容器</span></span><br><span class="line">    Queue&lt;Vector3&gt; queue = <span class="keyword">new</span> Queue&lt;Vector3&gt;();    <span class="comment">//声明一个队列</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        t = <span class="keyword">new</span> Thread(test);<span class="comment">//声明线程</span></span><br><span class="line">        t.Start();<span class="comment">//开启线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//若队列中存在结果</span></span><br><span class="line">        <span class="keyword">if</span>(queue.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//在主线程中取出结果</span></span><br><span class="line">            <span class="keyword">this</span>.transform.position = queue.Dequeue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//线程休眠毫秒</span></span><br><span class="line">            Thread.Sleep(<span class="number">1000</span>); </span><br><span class="line">           </span><br><span class="line">            <span class="comment">//往公共队列中存放结果</span></span><br><span class="line">            queue.Enqueue(Vector3.zero);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//手动关闭线程</span></span><br><span class="line">        t.Abort();  </span><br><span class="line">        t = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Unity中多线程的作用</strong></p><p>利用多线程来处理可能会造成主线程卡顿的问题</p><p>副线程中一般放入复杂的<strong>算法运算</strong>或者<strong>网络相关的内容</strong>，之后再将结果<strong>放到公共的内存</strong>中<strong>等待主线程的调用</strong></p><h4 id="协同程序是什么"><a href="#协同程序是什么" class="headerlink" title="协同程序是什么"></a>协同程序是什么</h4><p>协程是将代码分时执行，不卡主线程。就是把可能让主线程卡顿的耗时逻辑<strong>分时分布</strong>执行</p><p><strong>主要使用场景</strong></p><ul><li>异步加载文件</li><li>异步下载文件</li><li>场景异步加载</li><li>批量创建时防止卡顿</li></ul><h4 id="协程和线程的区别"><a href="#协程和线程的区别" class="headerlink" title="协程和线程的区别"></a>协程和线程的区别</h4><ul><li>每个线程都是一个独立的管道，和<strong>主线程并行</strong>执行</li><li>协程是处于原线程之上开启的，进行<strong>逻辑分时分布</strong>执行</li></ul><blockquote><p>当执行协程函数时，会将代码分时分布的执行，未执行的代码会被挂起，直到协程执行完毕</p></blockquote><h4 id="协程的使用"><a href="#协程的使用" class="headerlink" title="协程的使用"></a>协程的使用</h4><p>继承MonoBehavior的类 都可以开启协程函数</p><ol><li>申明协程函数<ul><li>函数<strong>返回值</strong>为 <strong>IEnumerator</strong>类型及其子类</li><li>通过 <strong>yield return</strong> 后返回内容，决定多久后 将协程挂起</li></ul></li></ol><ol><li>开启协程函数,一般在执行一次的生命周期函数中使用<ul><li>只能通过API调用：<strong>StartCoroutine( )</strong></li></ul></li></ol><ol><li>关闭协程<ul><li>关闭所有协程API：<strong>StopAllCoroutines()</strong></li><li>关闭指定协程API：StopCoroutine()</li></ul></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//开启协程</span></span><br><span class="line">        Coroutine c1 = StartCoroutine(MyCoroutine());</span><br><span class="line">        Coroutine c2 = StartCoroutine(MyCoroutine());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭所有协程</span></span><br><span class="line">        <span class="comment">//  StopAllCoroutines();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭指定协程</span></span><br><span class="line">        StopCoroutine(c1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//协程函数返回值 必须是 IEnumerator或继承它的子类</span></span><br><span class="line">    <span class="function">IEnumerator <span class="title">MyCoroutine</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//协程函数中 必须使用 yield return 进行返回</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">5</span>; <span class="comment">//下五帧后执行</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">5f</span></span>)</span>;    <span class="comment">//等待5s后执行后续内容</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForFixedUpdate</span>(<span class="params"></span>)</span>;  <span class="comment">//在FixedUpdate和碰撞检测相关函数之后执行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//主要截图时 会使用</span></span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForEndOfFrame</span>(<span class="params"></span>)</span>;   <span class="comment">//等待摄像机和GUI渲染完成后执行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以在协程中写死循环去处理一些复杂的逻辑</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">5f</span></span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="yield-return-不同返回值的含义"><a href="#yield-return-不同返回值的含义" class="headerlink" title="yield return 不同返回值的含义"></a>yield return 不同返回值的含义</h4><img src="/blog/Unity-3d%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220331205236392.png" class="" title="image-20220331205236392"><h4 id="协程受对象和组件失活销毁的影响"><a href="#协程受对象和组件失活销毁的影响" class="headerlink" title="协程受对象和组件失活销毁的影响"></a>协程受对象和组件失活销毁的影响</h4><p>协程开启后</p><ul><li>组件和物体销毁，协程不执行</li><li>物体失活协程不执行，<strong>组件失活协程执行</strong></li></ul><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><ul><li>Unity<strong>支持多线程</strong>，只是新线程<strong>无法访问主线程中Unity相关内容</strong><ul><li>一般用于复杂的<strong>逻辑运算</strong>或<strong>网络消息的接收</strong></li><li>多线程一定要记得关闭</li></ul></li><li>协程<strong>不是线程</strong>，它是将线程中的逻辑进行分时执行，避免卡顿</li><li>协程只有当组件单独失活时 不受影响，其它情况协程会停止</li></ul><h4 id="示例：计时器和许多的方块"><a href="#示例：计时器和许多的方块" class="headerlink" title="示例：计时器和许多的方块"></a>示例：计时器和许多的方块</h4><h5 id="示例一：使用协程实现计时器"><a href="#示例一：使用协程实现计时器" class="headerlink" title="示例一：使用协程实现计时器"></a>示例一：使用协程实现计时器</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//一般不会让协程开启函数一直执行</span></span><br><span class="line">        StartCoroutine(MyCoroutine());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IEnumerator <span class="title">MyCoroutine</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//计时器初始时间</span></span><br><span class="line">        <span class="built_in">int</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            print(time + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line">            time++;</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1</span></span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="示例二：创建十万个随机方块，不会明显的感觉到卡顿"><a href="#示例二：创建十万个随机方块，不会明显的感觉到卡顿" class="headerlink" title="示例二：创建十万个随机方块，不会明显的感觉到卡顿"></a>示例二：创建十万个随机方块，不会明显的感觉到卡顿</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> Random = UnityEngine.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        StartCoroutine(MyCoroutine());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyUp(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当按下空格键时，开启创建方块的协程函数</span></span><br><span class="line">            StartCoroutine(CreateCube(<span class="number">100000</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">CreateCube</span>(<span class="params"><span class="built_in">int</span> num</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube);</span><br><span class="line">            cube.transform.position = <span class="keyword">new</span> Vector3(Random.Range(<span class="number">-100</span>,<span class="number">100</span>), Random.Range(<span class="number">-100</span>,<span class="number">100</span>),Random.Range(<span class="number">-100</span>,<span class="number">100</span>));</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">1000</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//每创建1000个方块，就将协程函数挂起</span></span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">MyCoroutine</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//计时器初始时间</span></span><br><span class="line">        <span class="built_in">int</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            print(time + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line">            time++;</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1</span></span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="4-3-协程的本质"><a href="#4-3-协程的本质" class="headerlink" title="4.3 协程的本质"></a>4.3 协程的本质</h2><h4 id="协程函数的本质"><a href="#协程函数的本质" class="headerlink" title="协程函数的本质"></a>协程函数的本质</h4><p>协程可以分为 <strong>协程函数本体</strong>，以及<strong>协程调度器</strong></p><ul><li>协程本体是一个能够<strong>中间暂停 返回的函数</strong></li><li>协程调度器是<strong>Unity内部实现</strong>的，会在对应的时机帮我们继续执行协程函数</li></ul><h4 id="协程本体是C-迭代器的方法"><a href="#协程本体是C-迭代器的方法" class="headerlink" title="协程本体是C#迭代器的方法"></a>协程本体是C#迭代器的方法</h4><p><strong>IEnumerator源码</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">System.Collections</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">object</span> Current &#123; <span class="keyword">get</span>; &#125;<span class="comment">//得到yield return 返回内容</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)<span class="comment">//通过MoveNext函数访问迭代器中的内容，直到遇见yield return</span></span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过IEnumerator<strong>内部方法</strong>调用协程函数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//一般不会让协程开启函数一直执行</span></span><br><span class="line">        StartCoroutine(MyCoroutine());<span class="comment">//Unity API调用</span></span><br><span class="line">        IEnumerator ie = MyCoroutine();</span><br><span class="line">        MyCoroutine().MoveNext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IEnumerator <span class="title">MyCoroutine</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//计时器初始时间</span></span><br><span class="line">        <span class="built_in">int</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            print(time + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line">            time++;</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1</span></span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例：不使用Unity自带的协程协调器开启协程"><a href="#示例：不使用Unity自带的协程协调器开启协程" class="headerlink" title="示例：不使用Unity自带的协程协调器开启协程"></a>示例：不使用Unity自带的协程协调器开启协程</h4><hr><h1 id="5、Resources资源动态加载"><a href="#5、Resources资源动态加载" class="headerlink" title="5、Resources资源动态加载"></a>5、Resources资源动态加载</h1><h2 id="5-1-Unity中特殊文件夹"><a href="#5-1-Unity中特殊文件夹" class="headerlink" title="5.1 Unity中特殊文件夹"></a>5.1 Unity中特殊文件夹</h2><h4 id="工程路径获取"><a href="#工程路径获取" class="headerlink" title="工程路径获取"></a>工程路径获取</h4><ul><li>该方式 获取的路径 一般只在<strong>编辑模式</strong>下使用</li><li>游戏发布后该路径就不存在</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(Application.dataPath);</span><br></pre></td></tr></table></figure><h4 id="Resources-资源文件夹"><a href="#Resources-资源文件夹" class="headerlink" title="Resources 资源文件夹"></a>Resources 资源文件夹</h4><p>该文件夹需要自己创建</p><p>作用：</p><ol><li>需要<strong>通过Resources相关API 动态加载的资源</strong>需要放在其中 </li><li>该文件夹下<strong>所有文件</strong>都会被<strong>打包</strong>出去</li><li>并且打包时Unity会对其压缩加密</li><li>该文件夹打包后只读 只能通过Resources相关API加载</li></ol><h4 id="StreamingAssets-流动资源文件夹"><a href="#StreamingAssets-流动资源文件夹" class="headerlink" title="StreamingAssets 流动资源文件夹"></a>StreamingAssets 流动资源文件夹</h4><p>同样需要自己创建</p><p><strong>路径获取：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(Application.streamingAssetsPath);</span><br></pre></td></tr></table></figure><p>作用：</p><ol><li>打包出去后并不会加密</li><li>移动平台只读，PC平台可读可写</li><li>可以放入一些需要<strong>自定义动态加载的初始文件</strong></li></ol><h4 id="persistentDataPath-持久数据文件夹"><a href="#persistentDataPath-持久数据文件夹" class="headerlink" title="persistentDataPath 持久数据文件夹"></a>persistentDataPath 持久数据文件夹</h4><p>不需要手动创建</p><p>路径获取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(Application.persistentDataPath);</span><br></pre></td></tr></table></figure><p>作用：固定的数据文件夹</p><ol><li><strong>所有平台可读可写</strong></li><li>一般用于放置<strong>动态下载</strong> 或 <strong>动态创建</strong>的文件，游戏中<strong>创建以及获取的文件</strong>都在其中</li></ol><h4 id="Plugins-插件文件夹"><a href="#Plugins-插件文件夹" class="headerlink" title="Plugins 插件文件夹"></a>Plugins 插件文件夹</h4><p>需要手动创建</p><p>作用：</p><ul><li>不同平台的插件相关文件放入其中</li><li>比如IOS 和 Android平台</li></ul><h4 id="Editor-编辑器文件夹"><a href="#Editor-编辑器文件夹" class="headerlink" title="Editor 编辑器文件夹"></a>Editor 编辑器文件夹</h4><p>需要手动创建</p><p>作用：</p><ul><li>开发Unity编辑器时，编辑器相关脚本放在该文件夹中</li><li>该文件夹内容<strong>不会被打包出去</strong></li></ul><h4 id="Standard-Assets-默认资源文件夹"><a href="#Standard-Assets-默认资源文件夹" class="headerlink" title="Standard Assets 默认资源文件夹"></a>Standard Assets 默认资源文件夹</h4><p>需要手动创建</p><p>作用：</p><ul><li>一般Unity自带资源都会放在这个文件夹下</li><li>代码和资源优先被编译</li></ul><h2 id="5-2-Resources-资源同步加载"><a href="#5-2-Resources-资源同步加载" class="headerlink" title="5.2 Resources 资源同步加载"></a>5.2 Resources 资源同步加载</h2><h4 id="Resources-资源动态加载的作用"><a href="#Resources-资源动态加载的作用" class="headerlink" title="Resources 资源动态加载的作用"></a>Resources 资源动态加载的作用</h4><ol><li>通过代码 <strong>动态加载Resources 文件夹下指定路径资源</strong> </li><li>避免繁琐的拖延操作</li></ol><h4 id="常用资源类型"><a href="#常用资源类型" class="headerlink" title="常用资源类型"></a>常用资源类型</h4><ol><li>预设体对象：GameObject</li><li>音频文件：AudioClip</li><li>文本文件：TextAsset</li><li>图片文件：Texture</li></ol><p>注意：</p><p><strong>预设体对象加载需要实例化</strong>，其它资源加载一般直接使用</p><h4 id="资源同步加载-普通方法"><a href="#资源同步加载-普通方法" class="headerlink" title="资源同步加载 普通方法"></a>资源同步加载 普通方法</h4><p>在一个工程当中，Resources文件夹 可以有多个</p><ol><li>想要将预设体对象创建在场景上，必须要进行实例化</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将 加载预设体的资源文件存入obj中(本质上就是 加载配置文件到 内存中)</span></span><br><span class="line">    UnityEngine.Object obj = Resources.Load(<span class="string">&quot;Cube&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果想要在场景上 创建预设体 一定是在加载配置文件后 实例化，否则预设体将不会出现在场景上</span></span><br><span class="line">    Instantiate(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>音效资源</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AudioSource audioS;<span class="comment">//声明一个AudioSource类型的场景对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将音频资源加载到obj中</span></span><br><span class="line">Object obj = Resources.Load(<span class="string">&quot;Music/BKMusic&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用数据，将obj中的数据赋值给正确的脚本上</span></span><br><span class="line">audioS.clip = obj3 <span class="keyword">as</span> AudioClip;</span><br><span class="line">audioS.play();</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>文本资源</li></ol><p>文本资源支持的格式：<strong>txt，xml，bytes，json</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TextAsset ta = Resources.Load(<span class="string">&quot;Txt/Test&quot;</span>) <span class="keyword">as</span> TextAsset;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文本内容</span></span><br><span class="line">print(ta.text);</span><br><span class="line"></span><br><span class="line"><span class="comment">//字节数据组</span></span><br><span class="line">print(ta.bytes);</span><br></pre></td></tr></table></figure><ol><li>图片资源</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载图片资源</span></span><br><span class="line">Texture tex = Resources.Load(<span class="string">&quot;Tex/TestJPG&quot;</span>) <span class="keyword">as</span> Texture;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用图片资源绘制</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    GUI.DrawTexture(<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>),tex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>当资源同名时，将无法准确的加载预期的内容</p><ol><li>使用重载加载指定类型的资源</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//明确指出需要加载资源的类型</span></span><br><span class="line">Texture tex = Resources.Load(<span class="string">&quot;Tex/TestJPG&quot;</span>,<span class="keyword">typeof</span>(Texture)) <span class="keyword">as</span> Texture;</span><br></pre></td></tr></table></figure></li></ol><h4 id="资源同步加载-泛型方法"><a href="#资源同步加载-泛型方法" class="headerlink" title="资源同步加载 泛型方法"></a>资源同步加载 泛型方法</h4><p>常用泛型方法加载资源</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载音频</span></span><br><span class="line">AudioClip ap = Resources.Load&lt;AudioClip&gt;(<span class="string">&quot;Music/BKMusic&quot;</span>);</span><br><span class="line"><span class="comment">//使用音频</span></span><br><span class="line">audioS.clip = ap;</span><br><span class="line">audios.play();</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载文本</span></span><br><span class="line">TextAsset ta = Resources.Load&lt;TextAsset&gt;(<span class="string">&quot;Txt/Test&quot;</span>);</span><br><span class="line">print(ta.text);</span><br></pre></td></tr></table></figure><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><ul><li>Resources 动态加载资源方法拓展性更强</li><li>预设体加载出来一定要实例化</li></ul><hr><h2 id="5-3-Resources-异步加载"><a href="#5-3-Resources-异步加载" class="headerlink" title="5.3 Resources 异步加载"></a>5.3 Resources 异步加载</h2><h4 id="Resouces-异步加载是什么"><a href="#Resouces-异步加载是什么" class="headerlink" title="Resouces 异步加载是什么"></a>Resouces 异步加载是什么</h4><p>同步加载缺点 当主线程加载过大的资源时，可能会造成程序卡顿</p><p>而异步加载是 在<strong>内部新开一个线程进行资源加载</strong> 不会造成主线程卡顿</p><h4 id="Resouces-异步加载方法"><a href="#Resouces-异步加载方法" class="headerlink" title="Resouces 异步加载方法"></a>Resouces 异步加载方法</h4><p><strong>异步加载不能立刻得到加载的资源</strong> 至少要等一帧</p><ul><li>通过异步加载中的<strong>完成事件监听</strong> 使用加载的资源</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Unity在内部开启一个线程 进行资源加载</span></span><br><span class="line">ResourceRequest rq = Resources.LoadAsync&lt;Texture&gt;(<span class="string">&quot;Tex/TextJPG&quot;</span>);</span><br><span class="line"><span class="comment">//对资源加载进行 事件监听</span></span><br><span class="line">rq.completed += LoadOver;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当资源加载完毕后 在回调函数中执行逻辑代码</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LoadOver</span>(<span class="params">AsyncOperation rq</span>)</span>&#123;</span><br><span class="line">    print(<span class="string">&quot;加载结束&quot;</span>);</span><br><span class="line">    Texture tex = (rq <span class="keyword">as</span> ResourceRequest).asset <span class="keyword">as</span> Texture;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//图片资源加载完毕后才进行绘制</span></span><br><span class="line">    <span class="keyword">if</span>(tex != <span class="literal">null</span>)&#123;</span><br><span class="line">        GUI.DrwaTexture(<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>),tex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过<strong>协程</strong> 使用加载的资源</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">Load</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">ResourceRequest rq = Resources.LoadAsync&lt;Texture&gt;(<span class="string">&quot;Tex/TextJPG&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Unity知道 该返回值意味着正在执行异步加载资源</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> rq;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!rq.isDone)&#123;<span class="comment">//资源是否加载结束</span></span><br><span class="line">        print(rq.priority)；<span class="comment">//打印当前进度，当资源小的情况，效果不准确</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>；    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Unity会自己判断是否加载完毕 加载完毕过后 才会继续执行后面的代码、</span></span><br><span class="line">    Texture tex = rq.asset <span class="keyword">as</span> Texture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><ul><li>完成事件监听异步加载<ol><li>好处：写法简单</li><li>坏处：只能在<strong>资源加载结束后</strong> 进行处理</li></ol></li></ul><ul><li>协程异步加载<ol><li>可以在协程中处理复杂逻辑，比较同时加载多个资源，比如更新进度条</li><li>“并行加载‘</li></ol></li></ul><hr><h2 id="5-4-Resources-资源卸载"><a href="#5-4-Resources-资源卸载" class="headerlink" title="5.4 Resources 资源卸载"></a>5.4 Resources 资源卸载</h2><h4 id="Resources-重复加载资源不会浪费内存"><a href="#Resources-重复加载资源不会浪费内存" class="headerlink" title="Resources 重复加载资源不会浪费内存"></a>Resources 重复加载资源不会浪费内存</h4><ul><li>其实Resources 加载一次资源过后，该资源就一直存放在内存中作为缓存</li><li>第二次加载时发现缓存中存在该资源，会直接使用</li><li>所以 重复加载<strong>不会浪费内存</strong>，但每次加载需要查找和去除，会浪<strong>费性能</strong></li></ul><h4 id="如何手动释放掉缓存中的资源"><a href="#如何手动释放掉缓存中的资源" class="headerlink" title="如何手动释放掉缓存中的资源"></a>如何手动释放掉缓存中的资源</h4><ul><li><p>卸载指定资源API：Resources.UnloadAsset 方法</p><ol><li>该方法<strong>不能释放</strong> <strong>已经实例化后的对象</strong> 以及<strong>GameObject对象</strong></li><li>只能释放 不需要实例化的内容 比如 图片、音效等</li></ol></li></ul><ul><li><p>卸载未使用的资源API：Resources.UnloadUnusedAssets 方法</p><ul><li><p><strong>一般在过场景时和GC一起使用</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Resources.UnloadUnusedAssetes();</span><br><span class="line">GC.Collect();</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h1 id="6、场景异步加载"><a href="#6、场景异步加载" class="headerlink" title="6、场景异步加载"></a>6、场景异步加载</h1><h4 id="场景同步切换"><a href="#场景同步切换" class="headerlink" title="场景同步切换"></a>场景同步切换</h4><ol><li>将创建好的场景拖入<strong>Build Settings</strong> 中</li><li>然后在脚本中使用API切换：SceneManager.LoadScene(场景名字符串)</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//场景同步切换</span></span><br><span class="line">SceneManager.LoadScene(<span class="string">&quot;SceneTest&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>场景同步切换的缺点</strong></p><ul><li>在切换场景时，Unity会<strong>删除当前场景上的所有对象</strong>，并去<strong>加载下一个场景的相关内容</strong></li><li>如果当前场景对象过多，或下一场景对象过多，则整个过程会非常耗时</li></ul><h4 id="场景异步切换"><a href="#场景异步切换" class="headerlink" title="场景异步切换"></a>场景异步切换</h4><p>场景异步加载和资源异步加载 几乎一致 有两种方式</p><ol><li>通过事件回调函数 异步加载</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//场景同步切换</span></span><br><span class="line">    <span class="comment">//SceneManager.LoadScene(&quot;SceneTest&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、通过事件回调函数，异步加载</span></span><br><span class="line">    AsyncOperation ao = SceneManager.LoadSceneAsync(<span class="string">&quot;SceneTest&quot;</span>);</span><br><span class="line">    ao.completed += loadOver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当场景异步加载结束后，就会自动调用该事件函数，其中可以写一些逻辑代码</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadOver</span>(<span class="params">AsyncOperation ao</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print(<span class="string">&quot;加载结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>通过协程函数 异步加载<ul><li>在切换场景时，会删除当前场景的所有对象和脚本，这就导致了协程函数不可用</li><li>通过<strong>DontDestroyOnLoad</strong> 方法，可以让该对象过场景时，不被移除</li></ul></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//让对象过场景时不被移除</span></span><br><span class="line">    DontDestroyOnLoad(<span class="keyword">this</span>.gameObject);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过协程调度器开启协程函数   </span></span><br><span class="line">    StartCoroutine(loadScene(<span class="string">&quot;SceneTest&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerator <span class="title">loadScene</span>(<span class="params">String name</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//协程异步加载场景</span></span><br><span class="line">    AsyncOperation ao = SceneManager.LoadSceneAsync(name);</span><br><span class="line">print(<span class="string">&quot;异步加载过程中，协程可以执行&quot;</span>);</span><br><span class="line">   </span><br><span class="line"><span class="comment">//Unity内部的 协程协调器 发现是异步加载类型的返回对象 就会等待异步加载结束，才执行后续内容</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">//  yield return ao;</span></span><br><span class="line">    print(<span class="string">&quot;异步加载过程后，脚本和对象被删除，协程不可执行&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//协程异步加载场景的好处，可以在场景加载之前，为其添加进度条</span></span><br><span class="line">    <span class="comment">//第一种方法，利用 场景异步加载 的进度去更新 但并不是特别准确，一般不会直接使用</span></span><br><span class="line">    <span class="keyword">while</span>(!ao.isDone)</span><br><span class="line">    &#123;</span><br><span class="line">    print(ao.progress);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//离开循环后 场景就加载完毕，所以可以直接将进度条订满，然后隐藏进度条，制作假象</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二种方法 根据游戏规则 自定义 进度条变化的条件</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> ao;</span><br><span class="line">    <span class="comment">//场景加载结束后 更新20％进度</span></span><br><span class="line">    <span class="comment">//接着去加载场景中的 其它信息</span></span><br><span class="line">    <span class="comment">//比如</span></span><br><span class="line">    <span class="comment">//动态加载怪物</span></span><br><span class="line">    <span class="comment">//这时进度条 再更新20%</span></span><br><span class="line">    <span class="comment">//最近场景模型加载完毕后，直接将进度条d</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7、Line-Renderer"><a href="#7、Line-Renderer" class="headerlink" title="7、Line Renderer"></a>7、Line Renderer</h1><h4 id="Line-Renderer是什么"><a href="#Line-Renderer是什么" class="headerlink" title="Line Renderer是什么"></a>Line Renderer是什么</h4><p>Line Renderer是Unity提供的一个用于<strong>画线的组件</strong></p><p>使用它我们可以<strong>在场景中绘制线段</strong></p><p>一般可以用于：</p><ul><li>绘制攻击范围</li><li>武器红外线</li><li>辅助功能</li><li>其它画线功能</li></ul><h4 id="Line-Renderer-参数面板相关"><a href="#Line-Renderer-参数面板相关" class="headerlink" title="Line Renderer 参数面板相关"></a>Line Renderer 参数面板相关</h4><ul><li><strong>Loop</strong>：<strong>终点与起始点是否自动相连</strong></li><li><strong>Positions</strong>：为线段<strong>添加点</strong>，以及<strong>设置点的坐标</strong>，这些点会自动相连<ul><li>size：<strong>点的个数</strong></li><li>index：<strong>每个点的坐标</strong></li><li>width：点连成线的<strong>宽度</strong></li></ul></li><li><strong>Color</strong>：颜色变化</li><li><strong>Corner Vertices</strong>：该属性值越大，角顶点就越圆滑</li><li><strong>End Cap Vertices</strong>：该属性值越大，终端顶点越圆滑</li><li><strong>Use World Space</strong>：<strong>默认使用世界坐标系</strong>，使用后线段不会因为面板上的坐标而移动</li><li>Generate Lighting Data：默认不受光影响，当使用受到光照影响的材质球时，它不会显示</li><li><strong>Materials</strong>：为线段设置材质球，默认无材质球</li></ul><h4 id="Line-Renderer-代码相关"><a href="#Line-Renderer-代码相关" class="headerlink" title="Line Renderer 代码相关"></a>Line Renderer 代码相关</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Material m;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//动态添加一个线段</span></span><br><span class="line">        GameObject line = <span class="keyword">new</span> GameObject();</span><br><span class="line">        line.name = <span class="string">&quot;line&quot;</span>;</span><br><span class="line">        LineRenderer lr = line.AddComponent&lt;LineRenderer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//首位相连</span></span><br><span class="line">        lr.loop = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始结束宽</span></span><br><span class="line">        lr.startWidth = <span class="number">0.02f</span>;</span><br><span class="line">        lr.endWidth = <span class="number">0.02f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始结束颜色</span></span><br><span class="line">        lr.startColor = Color.white;</span><br><span class="line">        lr.endColor = Color.red;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置材质</span></span><br><span class="line">        m = Resources.Load&lt;Material&gt;(<span class="string">&quot;M&quot;</span>);<span class="comment">//动态加载材质</span></span><br><span class="line">        lr.material = m;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置点，一定要先设置点的个数</span></span><br><span class="line">        lr.positionCount = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接着就设置 每个点对应的位置</span></span><br><span class="line">        lr.SetPositions(<span class="keyword">new</span> Vector3[] &#123; <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>), <span class="keyword">new</span> Vector3(<span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>) &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定索引，设置该点的位置</span></span><br><span class="line">        lr.SetPosition(<span class="number">3</span>,<span class="keyword">new</span> Vector3(<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否使用世界坐标系</span></span><br><span class="line">        lr.useWorldSpace = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让线段受光影响 会接受光数据 进行着色器计算</span></span><br><span class="line">        lr.generateLightingData = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例：通过中心点和半径画圆、以及长按鼠标画出鼠标移动轨迹"><a href="#示例：通过中心点和半径画圆、以及长按鼠标画出鼠标移动轨迹" class="headerlink" title="示例：通过中心点和半径画圆、以及长按鼠标画出鼠标移动轨迹"></a>示例：通过中心点和半径画圆、以及长按鼠标画出鼠标移动轨迹</h4><ol><li>写一个方法，传入一个中心点和一个半径，用LineRender画一个原</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Material m;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        DrawLineRenderer(Vector3.zero, <span class="number">5.0f</span>, <span class="number">90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DrawLineRenderer</span>(<span class="params">Vector3 centerPos, <span class="built_in">float</span> r, <span class="built_in">int</span> pointNum</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        GameObject obj = <span class="keyword">new</span> GameObject();</span><br><span class="line">        obj.name = <span class="string">&quot;R&quot;</span>;</span><br><span class="line">        LineRenderer line = obj.AddComponent&lt;LineRenderer&gt;();</span><br><span class="line">        <span class="comment">//首位相连</span></span><br><span class="line">        line.loop = <span class="literal">true</span>;   </span><br><span class="line"></span><br><span class="line">        <span class="comment">//总共设置多少个点</span></span><br><span class="line">        line.positionCount = pointNum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每个点之间 间隔的度数</span></span><br><span class="line">        <span class="built_in">float</span> angle = <span class="number">360f</span> / pointNum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; pointNum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//原点加上半径 等于一条新的向量，四元数 乘 半径 就可以得到旋转四元数旋转量的新向量</span></span><br><span class="line">            line.SetPosition(i, centerPos + Quaternion.AngleAxis(angle * i, Vector3.up) * Vector3.forward * r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在Game窗口长按鼠标，用LineRenderer 画出鼠标移动的轨迹</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.SceneManagement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LineRenderer line;</span><br><span class="line">    <span class="keyword">private</span> Vector3 nowPos;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//GameObject obj = new GameObject();</span></span><br><span class="line">        <span class="comment">//line = obj.AddComponent&lt;LineRenderer&gt;();</span></span><br><span class="line">        <span class="comment">//line.loop = false;</span></span><br><span class="line">        <span class="comment">//line.startWidth = 0.1f;</span></span><br><span class="line">        <span class="comment">//line.endWidth = 0.1f;</span></span><br><span class="line">        <span class="comment">//line.positionCount = 0;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//每次点击鼠标时，都会产生新的线段对象</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            GameObject obj = <span class="keyword">new</span> GameObject();</span><br><span class="line">            line = obj.AddComponent&lt;LineRenderer&gt;();</span><br><span class="line">            line.loop = <span class="literal">false</span>;</span><br><span class="line">            line.startWidth = <span class="number">0.1f</span>;</span><br><span class="line">            line.endWidth = <span class="number">0.1f</span>;</span><br><span class="line">            line.positionCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( Input.GetMouseButton(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//每次点击鼠标时，新增一个点</span></span><br><span class="line">            line.positionCount += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取鼠标的位置</span></span><br><span class="line">            nowPos = Input.mousePosition;</span><br><span class="line">            nowPos.z = <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//Camera.main.ScreenToWorldPoint(nowPos) 鼠标转世界坐标</span></span><br><span class="line">            line.SetPosition(line.positionCount - <span class="number">1</span>,Camera.main.ScreenToWorldPoint(nowPos));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="8、物理系统"><a href="#8、物理系统" class="headerlink" title="8、物理系统"></a>8、物理系统</h1><h2 id="8-1-范围检测"><a href="#8-1-范围检测" class="headerlink" title="8.1 范围检测"></a>8.1 范围检测</h2><h4 id="什么是范围检测"><a href="#什么是范围检测" class="headerlink" title="什么是范围检测"></a>什么是范围检测</h4><p> 游戏中<strong>瞬时的攻击范围</strong>判断  一般会用范围检测</p><blockquote><p>例如：玩家前方5m处释放一个地刺魔法，在此范围内的对象将受到伤害</p><p>以及，玩家攻击时，前方1米圆形范围内对象都受到伤害等等</p><p>类似这种没有实体的，只需要检测在指定某一范围是否让敌人受到伤害时，就使用范围判断</p></blockquote><h4 id="如何进行范围检测"><a href="#如何进行范围检测" class="headerlink" title="如何进行范围检测"></a>如何进行范围检测</h4><p>想要被范围检测到的对象，必须<strong>具备碰撞器</strong></p><p>范围检测相关API：当执行到该句代码时 进行一次<strong>瞬时</strong>的范围检测，并<strong>不会真正产生一个碰撞器</strong>，只是碰撞判断计算而已</p><blockquote><p>简单来说，就是当我们调用该API时，它会瞬间检测该范围内是否有其它碰撞器</p></blockquote><p>范围检测API</p><p><strong>盒状范围检测</strong>：<strong>Physics.OverlapBox( )</strong></p><ul><li><p><strong>返回值</strong>：该范围内的<strong>所有触发器组件</strong>，可以用数组接收</p></li><li><p>参数一：立方体中心点，盒状范围的原点</p></li><li>参数二：立方体三边大小，从中心点开始，向两边分布构建立方体</li><li>参数三：立方体角度，盒状范围旋转角度</li><li>参数四：检测指定层级(不填则默认检测所有层)，<strong>LayerMask.NameToLayer(“层级名”)</strong></li><li>参数五：是否忽略触发器。默认<strong>UseGlobal-使用全局检测，Collide-检测触发器，Ignore-忽略触发器</strong></li></ul><img src="/blog/Unity-3d%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220401225906599.png" class="" title="image-20220401225906599"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Collider[] colliders = Physics.OverlapBox(Vector3.zero, Vector3.one, Quaternion.AngleAxis(<span class="number">45</span>, Vector3.up),</span><br><span class="line">    <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;UI&quot;</span>) |</span><br><span class="line">    <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Defauit&quot;</span>), QueryTriggerInteraction.UseGlobal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环获取范围检测内的碰撞器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; colliders.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        print(colliders[i].gameObject.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个API：<strong>Physics.OverlapBoxNonAlloc</strong>( )</p><ul><li>返回值是 int类型数据：碰撞到的碰撞器数量</li><li>参数：将创建好的碰撞器数组传入</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( Physics.OverlapBoxNonAlloc(Vector3.zero, Vector3.one,colliders) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; colliders.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">        print(colliders[i].gameObject.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>球形范围检测</strong>：<strong>Physics.OverlapSphere</strong>()</p><ul><li><p>返回值：在该范围内的触发器</p></li><li><p>参数一：中心点</p></li><li>参数二：球半径</li><li>参数三：检测指定层级，不填则检测所有层</li><li>参数四：是否忽略触发器，默认<strong>UseGlobal-使用全局检测，Collide-检测触发器，Ignore-忽略触发器</strong></li></ul><p>另一个API：<strong>Physics.OverlapSphereNonAlloc</strong>()</p><ul><li>返回值：碰撞到的碰撞器数量</li><li>参数：传入一个数组进行存储</li></ul><p><strong>胶囊范围检测</strong>：<strong>Physics.OverlapCapsule()</strong></p><ul><li>参数一：半圆一 中心点</li><li>参数二：半圆二 中心点</li><li>参数三：半圆半径</li><li>参数四：检测指定层级</li><li>参数五：是否忽略触发器</li></ul><p>另一个API：<strong>Physics.OverlapCapsuleNonAlloc()</strong></p><h4 id="示例：用WSAD控制立方体的前后移动和旋转，并进行范围检测"><a href="#示例：用WSAD控制立方体的前后移动和旋转，并进行范围检测" class="headerlink" title="示例：用WSAD控制立方体的前后移动和旋转，并进行范围检测"></a>示例：用WSAD控制立方体的前后移动和旋转，并进行范围检测</h4><img src="/blog/Unity-3d%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220402101845774.png" class="" title="image-20220402101845774"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.SceneManagement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移动速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> moveSpeed;</span><br><span class="line">    <span class="comment">//旋转速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> roundSpeed;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//水平方向</span></span><br><span class="line">        Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        <span class="comment">//竖直方向</span></span><br><span class="line">        Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//位移</span></span><br><span class="line">        <span class="keyword">this</span>.transform.Translate(Vector3.forward * Time.deltaTime * moveSpeed * Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//旋转</span></span><br><span class="line">        <span class="keyword">this</span>.transform.Rotate(Vector3.up, Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>) * roundSpeed * Time.deltaTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.J))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//盒状范围检测实际长度是输入长度的一倍</span></span><br><span class="line">           Collider[ ] colliders = Physics.OverlapBox( (<span class="keyword">this</span>.transform.position + <span class="keyword">this</span>.transform.forward), Vector3.one,</span><br><span class="line">               <span class="keyword">this</span>.transform.rotation, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; colliders.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                print(<span class="string">&quot;物体受伤&quot;</span> + colliders[i].gameObject.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="8-2-射线检测"><a href="#8-2-射线检测" class="headerlink" title="8.2 射线检测"></a>8.2 射线检测</h2><h4 id="什么是射线检测"><a href="#什么是射线检测" class="headerlink" title="什么是射线检测"></a>什么是射线检测</h4><p>在指定点 发射一个指定方向的射线，判断该射线与哪些碰撞器相交</p><ul><li>如FPS射击游戏(无弹道，不产生实际的子弹对象进行移动)</li></ul><h4 id="射线对象"><a href="#射线对象" class="headerlink" title="射线对象"></a>射线对象</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数是起点坐标</span></span><br><span class="line"><span class="comment">//第二个参数是方法向量，并不是重点坐标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//申明射线对象 </span></span><br><span class="line">Ray r = <span class="keyword">new</span> Ray(Vector3.right,Vector3.forward);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、摄像机发射出的射线</span></span><br><span class="line"><span class="comment">//得到一条从屏幕位置作为起点，摄像机视口方向为 方向的射线</span></span><br><span class="line">Ray r2 = Camera.main.ScreeenPointToRay(Input.mousePosition);</span><br></pre></td></tr></table></figure><ul><li>单独的一条射线并没实际意义，需要结合物理系统进行射线碰撞判断才有用</li></ul><h4 id="碰撞检测函数"><a href="#碰撞检测函数" class="headerlink" title="碰撞检测函数"></a>碰撞检测函数</h4><p>射线检测也是<strong>瞬时</strong>的，仅在执行代码时进行一次射线检测</p><ul><li>射线是否碰撞到对象：<strong>Physics.Raycast()</strong><ul><li>函数返回值为<strong>bool</strong>，如碰撞到对象，则返回true</li><li>参数一：传入创建好的射线对象</li><li>参数二：射线的最大检测距离，超过距离不检测</li><li>参数三：检测指定层级</li><li>参数四：是否忽略触发器</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        Ray r = <span class="keyword">new</span> Ray(Vector3.zero,Vector3.forward);</span><br><span class="line">        <span class="keyword">if</span>( Physics.Raycast(r, <span class="number">100</span>, <span class="number">1</span>&lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>), QueryTriggerInteraction.UseGlobal) )</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;检测碰撞到了对象&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以传入射线的起点 和方向向量</span></span><br><span class="line">        <span class="keyword">if</span>( Physics.Raycast(Vector3.zer0, Vector.forward, <span class="number">100</span>, <span class="number">1</span>&lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>), QueryTriggerInteraction.UseGlobal) )</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;检测碰撞到了对象&quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>获取相交的单个物体信息<ul><li>物体信息类 <strong>RaycastHit</strong>，该参数用来记录相交物体的信息，类型为<strong>结构体</strong></li><li>参数一：传入创建好的射线对象</li><li>参数二：传入声明好的<strong>RaycastHit 对象</strong></li><li>参数三：射线的最大检测距离，超过距离不检测</li><li>参数四：检测指定层级</li><li>参数五：是否忽略触发器</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取相交的单个物体信息</span></span><br><span class="line"><span class="comment">//物体信息类 RaycastHit</span></span><br><span class="line">RaycastHit hit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( Physics.Raycast(r, <span class="keyword">out</span> hit, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>), QueryTriggerInteraction.UseGlobal) )</span><br><span class="line">&#123;</span><br><span class="line">print(<span class="string">&quot;得到碰撞体的信息&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//碰撞器信息</span></span><br><span class="line">    print(<span class="string">&quot;碰撞到物体的名字&quot;</span>+hit.collider.gameObject.name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//碰撞到的点</span></span><br><span class="line">    print(hit.point);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//法线信息，使得制作的特效和贴图更加符合真实</span></span><br><span class="line">    print(hit.normal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到碰撞到对象的位置</span></span><br><span class="line">    print(hit.transform.position);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到碰撞到对象 离自己的距离</span></span><br><span class="line">    print(hit.distance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取相交的多个物体：<strong>Physics.RaycastAll( )</strong>,返回值是一个<strong>数组</strong>，将碰撞到的多个物体<strong>倒序</strong>存入数组中<ul><li>参数一：传入创建好的射线对象</li><li>参数二：射线的最大检测距离，超过距离不检测</li><li>参数三：检测指定层级</li><li>参数四：是否忽略触发器</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RaycastHit[] hits = Physics.RaycastAll(r, <span class="number">100</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>), QueryTriggerInteraction.UseGlobal);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; hits.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">print(<span class="string">&quot;碰到的所有物体，名字分别是&quot;</span> + hits[i].collider.gameObject.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>由于距离、层级两个参数都是 int类型</p><p>所以当我们将两者的顺序弄反时，编译器并不会报错</p><p>要记住，<strong>层级参数一定是在距离参数之后出现的</strong></p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找（下）：如何快速定位IP对应的省份地址？</title>
      <link href="blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE02/"/>
      <url>blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE02/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="四种常见的二分查找变形问题"><a href="#四种常见的二分查找变形问题" class="headerlink" title="四种常见的二分查找变形问题"></a>四种常见的二分查找变形问题</h2><h3 id="1、查找第一个值等于定值的元素"><a href="#1、查找第一个值等于定值的元素" class="headerlink" title="1、查找第一个值等于定值的元素"></a>1、查找第一个值等于定值的元素</h3><p>有序数据集合中存在<strong>重复</strong>的数据，我们希望找到<strong>第一个</strong>值等于给定值的数据</p><p>假如下面这样一个有序数组，其中，a[5]，a[6]，a[7] 的值都等于 8，是重复的数据。我们希望查找第一个等于 8 的数据，也就是下标是 5 的元素</p><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE02/%E5%8F%98%E5%BD%A21.jpg" class=""><p>如果我们用之前的二分查找代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] == value)&#123;</span><br><span class="line">            <span class="keyword">return</span> a[mid];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[mid] &lt; value)&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>根据代码，我们会先拿8跟a[4]比较，8 比 6 大，于是在下标 5 到 9 之间继续查找。下标 5 和 9 的中间位置是下标 7，a[7] 正好等于 8，所以代码就返回了。</p><p>但这样明显不是我们要找的第一个元素，所以我们要对代码进行变形</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &lt; value)&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[mid] &gt; value)&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(mid == <span class="number">0</span> || a[mid - <span class="number">1</span>] != value)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里我们要确认一个a[mid]是不是第一个值等于定值的元素</p><p>如果 mid 等于 0，那这个元素已经是数组的第一个元素，那它肯定是我们要找的</p><p>如果 mid 不等于 0，但 a[mid] 的前一个元素 a[mid-1] 不等于 value，那也说明 a[mid] 是我们要找的</p><p>如果 a[mid] 前面的一个元素 a[mid-1] 也等于 value，那就说明a[mid]肯定不是第一个定值，那我们就更新high = mid - 1</p></blockquote><h3 id="2、查找最后一个等于定值的元素"><a href="#2、查找最后一个等于定值的元素" class="headerlink" title="2、查找最后一个等于定值的元素"></a>2、查找最后一个等于定值的元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &lt; value)&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[mid] &gt; value)&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[mid] == n - <span class="number">1</span> || a[mid + <span class="number">1</span>] != value)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>变形2和变形1类似，如果 a[mid] 这个元素已经是数组中的最后一个元素了，那它肯定是我们要找的</p><p>如果 a[mid] 的后一个元素 a[mid+1] 不等于 value，那也说明 a[mid] 也是我们要找的</p><p>发现 a[mid] 后面的一个元素 a[mid+1] 也等于 value，那说明当前的这个 a[mid] 并不是最后一个值等于给定值的元素。我们就更新 low=mid+1，因为要找的元素肯定出现在 [mid+1, high] 之间</p></blockquote><h3 id="3、查找第一个大于等于定值的元素"><a href="#3、查找第一个大于等于定值的元素" class="headerlink" title="3、查找第一个大于等于定值的元素"></a>3、查找第一个大于等于定值的元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &gt;= value)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mid == <span class="number">0</span> || a[mid - <span class="number">1</span>] &lt; value)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>；</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于 a[mid] 大于等于给定值 value 的情况，我们要先看下这个 a[mid] 是不是我们要找的第一个值大于等于给定值的元素。</p><p>如果 a[mid] 前面已经没有元素，或者前面一个元素小于要查找的值 value，那 a[mid] 就是我们要找的元素</p></blockquote><h3 id="4、查找最后一个小于等于定值的元素"><a href="#4、查找最后一个小于等于定值的元素" class="headerlink" title="4、查找最后一个小于等于定值的元素"></a>4、查找最后一个小于等于定值的元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &lt;= value)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mid == n - <span class="number">1</span> || a[mid + <span class="number">1</span>] &gt; value)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>；</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            high = high - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何快速定位出一个-IP-地址的归属地？"><a href="#如何快速定位出一个-IP-地址的归属地？" class="headerlink" title="如何快速定位出一个 IP 地址的归属地？"></a>如何快速定位出一个 IP 地址的归属地？</h2><ul><li>将IP地址转换为32位的整型数</li><li>然后将起始地址 按照对应的整型数从小到大排序</li><li>当我们要查询某个 IP 归属地时，我们可以先通过二分查找，找到最后一个起始 IP 小于等于这个 IP 的 IP 区间，然后，检查这个 IP 是否在这个 IP 区间内，如果在，我们就取出对应的归属地显示；如果不在，就返回未查找到。</li></ul><h2 id="内容总结"><a href="#内容总结" class="headerlink" title="内容总结"></a>内容总结</h2><p>凡是用二分查找能解决的，绝大部分我们更倾向于用散列表或者二叉查找树。</p><p>二分查找<strong>更适合</strong>用在“<strong>近似</strong>”查找问题，在这类问题上，二分查找的优势更加明显</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二分查找（上）：如何用最省内存的方式实现快速查找功能？</title>
      <link href="blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE01/"/>
      <url>blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE01/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="如何理解二分查找"><a href="#如何理解二分查找" class="headerlink" title="如何理解二分查找"></a>如何理解二分查找</h2><p>二分查找，又叫折半查找，它的思想是每次查找<strong>有序序列</strong>中的<strong>中间值</strong>，然后再判断该值与目标值的大小。如果大于目标值，则说明目标值在左半区间，反之，则在右半区间。不断重复上述操作，直到查找完成为止</p><p>假设我要在0~99的数字之间，查找23，则如下图所示</p><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.jpg" class=""><p>总结：二分查找是针对<strong>有序</strong>的数据集合，每次都能通过<strong>中间值与目标值对比</strong>，将待查<strong>区间的范围缩小一半</strong>，<strong>直到找到目标值</strong>，或<strong>区间被缩小为0</strong>时停止</p><p>它的<strong>时间复杂度是O(log n)</strong>，效率非常高</p><h2 id="二分查找的递归与非递归实现"><a href="#二分查找的递归与非递归实现" class="headerlink" title="二分查找的递归与非递归实现"></a>二分查找的递归与非递归实现</h2><p>示例1：有序数组中不存在重复元素，用二分查找给定的数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;<span class="comment">//左区间下标开始为0</span></span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;<span class="comment">//右区间下标开始为n-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;<span class="comment">//注意：不是 low &lt; high</span></span><br><span class="line">        <span class="comment">//注意：不是mid=(low+high)/2,因为如果low和high比较大的话，两者之和就有可能会溢出</span></span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] == value)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[mid] &lt; value)&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>二分查找还是有几个地方需要强调</p><p>1、循环退出条件：注意是 low&lt;=high，而不是 low&lt;high</p><p>2、mid的取值：mid=(low+high)/2 这种写法是有问题的。</p><p>因为如果 low 和 high 比较大的话，两者之和就有可能会溢出。改进的方法是将 mid 的计算方式写成 low+(high-low)/2。</p><p>3、low 和 high 的更新</p><p>low=mid+1，high=mid-1。注意这里的 +1 和 -1，如果直接写成 low=mid 或者 high=mid，就可能会发生死循环。</p><p>比如，当 high=3，low=3 时，如果 a[3] 不等于 value，就会导致一直循环不退出。</p></blockquote><p>示例2：用递归来实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找的递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bsearchInternally(a, <span class="number">0</span>, n - <span class="number">1</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">bsearchInternally</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (a[mid] == value) &#123;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">    <span class="keyword">return</span> bsearchInternally(a, mid+<span class="number">1</span>, high, value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bsearchInternally(a, low, mid<span class="number">-1</span>, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找的局限性"><a href="#二分查找的局限性" class="headerlink" title="二分查找的局限性"></a>二分查找的局限性</h2><ul><li>二分查找<strong>依赖数组</strong>，通过数组的下标随机访问才能让时间复杂度变得很低</li><li>二分查找针对的是<strong>有序数据</strong></li></ul><blockquote><p>如果数据没有序，那么<strong>排序的时间复杂度最低为O(n logn)</strong></p><p>所以，二分查找只能用在<strong>插入、删除操作不频繁</strong>，一<strong>次排序多次查找</strong>的场景中</p></blockquote><ul><li><strong>数据量太小</strong>不适合二分查找</li></ul><blockquote><p>如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了</p><p>比如我们在一个大小为 10 的数组中查找一个元素，不管用二分查找还是顺序遍历，查找速度都差不多</p><p>只有数据量比较大的时候，二分查找的优势才会比较明显。</p></blockquote><ul><li><strong>数据量太大</strong>也不适合二分查找</li></ul><blockquote><p>因为二分查找要依赖数组，而数组要求连续的内存空间，对内存要求比较苛刻</p><p>当数据量太大时，我们可能需要比它大得多的内存空间</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Games101-04控制转换</title>
      <link href="blog/Games101-04%E6%8E%A7%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
      <url>blog/Games101-04%E6%8E%A7%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="3D-变换"><a href="#3D-变换" class="headerlink" title="3D 变换"></a>3D 变换</h2><h3 id="特定旋转"><a href="#特定旋转" class="headerlink" title="特定旋转"></a>特定旋转</h3><p>当我们的物体在三维空间绕着x、y、z轴旋转时，只有对应轴的坐标会保持不变</p><blockquote><p>用矩阵的表示方式如下</p><p>绕着x轴旋转，所以x轴坐标不会变，则矩阵的第一行和第一列都是1 0 0 </p><p>然后其中2×2的矩阵，就是对y、z进行旋转</p><p>绕着y轴旋转也是痛苦，矩阵的第二行和第二轮都是 1 0 0</p><p>然后周围的2×2矩阵，是对x、z进行旋转</p><p>总之就是哪个轴坐标不变，对应的行列就是 1 0 0，然后剩下的2×2矩阵就是对其它轴的旋转</p><p>在这里我们定义的是x叉乘z得到y。所以在矩阵中x和z的sin相同，而它们与z的sin相反</p></blockquote><img src="/blog/Games101-04%E6%8E%A7%E5%88%B6%E8%BD%AC%E6%8D%A2/image-20220609220342559.png" class="" title="image-20220609220342559"><h3 id="复合旋转"><a href="#复合旋转" class="headerlink" title="复合旋转"></a>复合旋转</h3><p>我们可以将复杂的旋转，转换为通过特定旋转的组合形式</p><blockquote><p>也就是将复杂的旋转，转换为绕x、y、z轴的组合</p><p>这也是下述公式的含义</p></blockquote><img src="/blog/Games101-04%E6%8E%A7%E5%88%B6%E8%BD%AC%E6%8D%A2/image-20220609221209398.png" class="" title="image-20220609221209398"><p>在数学上，我们将上述公式中的α，β，γ，三个角称之为欧拉角</p><blockquote><p>可以通过飞机抬头、平移、侧移的方法形象的理解欧拉角</p><p>飞机的任何旋转，都能分解为上述的三个动作</p><p>如下图所示</p></blockquote><img src="/blog/Games101-04%E6%8E%A7%E5%88%B6%E8%BD%AC%E6%8D%A2/image-20220609221459801.png" class="" title="image-20220609221459801"><p><strong>公式</strong>：将任意的旋转通过分解为三个欧拉角的方式，写成一个矩阵</p><img src="/blog/Games101-04%E6%8E%A7%E5%88%B6%E8%BD%AC%E6%8D%A2/image-20220609222025801.png" class="" title="image-20220609222025801"><h2 id="观测变换"><a href="#观测变换" class="headerlink" title="观测变换"></a>观测变换</h2><p>观测变化包含<strong>视图变换</strong>和<strong>投影变换</strong>。其中投影变换又分为<strong>正交投影</strong>和<strong>透视投影</strong></p>]]></content>
      
      
      <categories>
          
          <category> 图形学基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序（上）：为什么插入排序比冒泡排序更受欢迎？</title>
      <link href="blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E6%8E%92%E5%BA%8F1/"/>
      <url>blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E6%8E%92%E5%BA%8F1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="如何分析一个排序算法"><a href="#如何分析一个排序算法" class="headerlink" title="如何分析一个排序算法"></a>如何分析一个排序算法</h2><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E6%8E%92%E5%BA%8F1/%E6%8E%92%E5%BA%8F.jpg" class=""><ul><li><strong>算法的执行效率</strong></li></ul><p>我们在分析算法的时间复杂度时，要分别给出<strong>最好、最坏、以及平均复杂度</strong>。</p><p>除此之外，还要说出最好和最坏时间复杂度适用于哪种原始排列数据</p><blockquote><p>因为所需要排序的数据，有的接近有序，有的接近无序。</p><p>我们需要知道排序算法在不哦那个数据下的性能表现</p></blockquote><ul><li><strong>算法的内存消耗</strong></li></ul><p><strong>原地排序</strong>算法，即空间复杂度为O(1)的排序算法。<strong>冒泡，插入，选择</strong>都是原地排序算法</p><ul><li><strong>排序算法的稳定性</strong></li></ul><p>针对排序算法，我们还有一个重要的度量指标，<strong>稳定性</strong>。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>基本思想：</p><ul><li>冒泡排序只会比较两个相邻的数据，看它们是否满足大小关系</li><li>如果不满足则将它们互换。一次冒泡排序就能确定至少一个元素的位置，重复n次，就能完成n个数的排序</li></ul><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E6%8E%92%E5%BA%8F1/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.jpg" class=""><p>可以看出，经过一次冒泡操作之后，6 这个元素已经存储在正确的位置上。要想完成所有数据的排序，我们只要进行 6 次这样的冒泡操作就行了。</p><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E6%8E%92%E5%BA%8F1/%E5%86%92%E6%B3%A1%E5%90%8E.jpg" class=""><p>实际上，刚讲的冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = nums.size();</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">flag = <span class="literal">false</span>;<span class="comment">//如果发生交换，说明还需要排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">swap(nums[j], nums[j + <span class="number">1</span>]);</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!flag) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span> &#125;;</span><br><span class="line">bubbleSort(nums);</span><br><span class="line">print(nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>冒泡排序是稳定算法、以及原地排序算法</li><li>冒牌排序的最好时间复杂度为O(n)，即只有一个元素需要排序的情况，最坏和平均复杂度为O(n^2)</li><li>原始数据越有序，冒牌排序越快</li></ul><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>思想：</p><ul><li>将数据分为两个区间，<strong>已排序区间</strong>和<strong>未排序区间</strong>。</li><li>初始的<strong>已排序区间只有数组第一个元素</strong></li><li>将<strong>未排序区间中的元素取出</strong>，在<strong>已排序区间找到合适的位置插入</strong>，保证已排序区间<strong>一直有序</strong></li><li>重复上面的过程，直到未排序区间中的元素为空</li></ul><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E6%8E%92%E5%BA%8F1/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.jpg" class=""><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; a[i - <span class="number">1</span>])&#123;<span class="comment">//判断第i个元素和第i-1个元素</span></span><br><span class="line">            <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> x = a[i];</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; x &lt; a[j])&#123;</span><br><span class="line">                a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j+<span class="number">1</span>] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>插入排序是<strong>原地排序</strong></li><li>插入排序是<strong>稳定算法</strong></li><li>插入排序<strong>从尾到头遍历有序的数据</strong>最好时间复杂度是O(n)，最坏和平均是O(n^2)</li></ul><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>思路：类似于插入排序，也分为已排序区和未排序区</p><ul><li>但是选择排序每次会<strong>从未排序区中找到最小元素</strong>，将其放到已排序区间的开头</li></ul><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E6%8E%92%E5%BA%8F1/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.jpg" class=""><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seletionSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minIndex;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[minIndex])&#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a[i],a[minIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li><p>选择排序是<strong>原地排序</strong></p></li><li><p>选择排序最好、最坏、平均复杂度都是O(n^2)</p></li><li>选择排序是非稳定算法</li></ul><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E6%8E%92%E5%BA%8F1/%E6%80%BB%E7%BB%93.jpg" class=""><h2 id="为什么插入排序比冒泡排序更受欢迎？"><a href="#为什么插入排序比冒泡排序更受欢迎？" class="headerlink" title="为什么插入排序比冒泡排序更受欢迎？"></a>为什么插入排序比冒泡排序更受欢迎？</h2><p>从代码实现上来看，冒泡排序的<strong>数据交换</strong>要比插入排序的<strong>数据移动</strong>要复杂，冒泡排序需要 <strong>3 个</strong>赋值操作，而插入排序只需要 <strong>1 个</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>秋招面经</title>
      <link href="blog/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/"/>
      <url>blog/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="秋招八股"><a href="#秋招八股" class="headerlink" title="秋招八股"></a>秋招八股</h1><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><h4 id="1、C-和-C-的区别"><a href="#1、C-和-C-的区别" class="headerlink" title="1、C 和 C++的区别"></a>1、C 和 C++的区别</h4><ol><li>C++是<strong>面向对象</strong>的的编程语言，C是面向过程的编程语言</li><li>C++中的内存分配运算符是<strong>new/delete</strong><ul><li>而C 中是<strong>malloc和free</strong></li></ul></li><li>C++中有<strong>函数重载</strong><ul><li>而C 中没有</li></ul></li><li>C++中新增了<strong>引用</strong>的概念<ul><li>而C 中只有值和指针</li></ul></li></ol><p>​    </p><h4 id="2、struct-和-class的区别"><a href="#2、struct-和-class的区别" class="headerlink" title="2、struct 和 class的区别"></a>2、struct 和 class的区别</h4><ol><li><p>struct 一般用于<strong>描述一个数据结构集合</strong></p><ul><li>而class是对一个对象数据的封装</li></ul></li><li><p>class 默认访问修饰符是<strong>私有</strong>的</p><ul><li>而struct 是<strong>公有</strong>的</li></ul></li><li>在继承方面 class默认是<strong>私有继承</strong><ul><li>而struct 默认是<strong>公有继承</strong></li></ul></li></ol><p>​    </p><h4 id="3、define宏定义-和-const-的区别"><a href="#3、define宏定义-和-const-的区别" class="headerlink" title="3、define宏定义 和 const 的区别"></a>3、define宏定义 和 const 的区别</h4><p>西山居</p><ol><li>首先 宏定义是在编译的<strong>预处理阶段</strong>起作用<ul><li>而const是在<strong>编译、运行</strong>时起作用</li></ul></li><li>其次 宏定义它<strong>只做替换</strong>，并<strong>不会进行检查</strong>，很容易报错<ul><li>而const<strong>有数据类型</strong>，编译器会对它<strong>进行类型检查</strong></li></ul></li><li>最后 宏定义的数据<strong>没有分配内存</strong>，只是<strong>插入替换</strong><ul><li>而const定义的变量只是值不能变，但是<strong>会分配内存</strong></li></ul></li></ol><p>​    </p><h4 id="4、define宏定义-和-line内联函数的区别"><a href="#4、define宏定义-和-line内联函数的区别" class="headerlink" title="4、define宏定义 和 line内联函数的区别"></a>4、define宏定义 和 line内联函数的区别</h4><p>西山居</p><ol><li>首先 宏定义在<strong>预处理阶段</strong>起作用，只做简单的字符串替换，它没有返回值<ul><li>而 内联函数在<strong>编译</strong>阶段起作用，<strong>有返回值</strong></li></ul></li><li>然后 内联函数在<strong>编译</strong>时直接将<strong>函数代码嵌入到目标代码中</strong>，省去了函数调用的开销，从而提高性能，并且可以重载</li><li>最后 编译器会对内联函数进行类型检查以及语法判断<ul><li>而宏定义不会</li></ul></li></ol><p>​        </p><h4 id="5、指针和引用的区别"><a href="#5、指针和引用的区别" class="headerlink" title="5、指针和引用的区别"></a>5、指针和引用的区别</h4><ol><li>指针是一个变量，里面存放的是地址<ul><li>而引用是变量的<strong>别名</strong>，它和原来的变量实际上是同一个东西</li></ul></li><li>指针可以有多级<ul><li>而引用只能有<strong>一级</strong></li></ul></li><li>指针在初始化依然可以改变指向<ul><li><strong>而引用初始化后就不能改变</strong></li></ul></li><li>对指针取地址，得到的是指针原本的地址<ul><li>而对引用取地址，得到的是<strong>变量的地址</strong></li></ul></li></ol><p>​    </p><h4 id="6、数组和指针的区别"><a href="#6、数组和指针的区别" class="headerlink" title="6、数组和指针的区别"></a>6、数组和指针的区别</h4><ol><li><p>首先 数组是存储多个相同数据类型的集合。数组名是<strong>首元素的地址</strong></p><ul><li>而指针是变量，用于存放其它变量在<strong>内存中的地址</strong>。指针名指向<strong>内存的首地址</strong></li></ul></li><li><p>其次 数组在内存中是连续存储的，通过数组下标进行访问，数组<strong>不是在静态区就是在栈上</strong></p><ul><li>而指针的存储的存储空间不能确定</li></ul></li><li><p>最后 用sizeof计算数组，得到的是<strong>整个数组的大小</strong>。</p><ul><li>而指针得到的是该<strong>指针变量</strong>的大小</li></ul></li></ol><h4 id="7、数组指针和指针数组的区别"><a href="#7、数组指针和指针数组的区别" class="headerlink" title="7、数组指针和指针数组的区别"></a>7、数组指针和指针数组的区别</h4><ul><li>数组指针：它是指向数组的<strong>指针</strong>，它的本质是指针，只不过指向数组中的某一个元素</li><li>指针数组：它是存放指针的<strong>数组</strong>，其本质是数组，只不过其中存放的元素是指针</li></ul><blockquote><p>数组指针写做 <code>int(*ptr) [4]</code></p><p>指针数组写做 <code>int* ptr[4]</code></p></blockquote><h4 id="7、深拷贝和浅拷贝的区别"><a href="#7、深拷贝和浅拷贝的区别" class="headerlink" title="7、深拷贝和浅拷贝的区别"></a>7、深拷贝和浅拷贝的区别</h4><p>原因：在拷贝构造的过程中，导致<strong>两个对象指向同一块内存区域</strong>，这样再释放内存的过程中就会导致内存资源重复释放</p><p>浅拷贝</p><ul><li>因为浅拷贝只是拷贝了一个指针，并没有新开辟一块内存区域</li><li>所以就导致了两个对象指向了同一块地址</li><li>最后会导致内存资源的重复释放</li></ul><p>深拷贝</p><ul><li>深拷贝是直接开辟了一个新的空间，新对象指向这个新的空间</li><li>这样 即使原对象被析构，也不会影响到新对象</li></ul><p>​    </p><h4 id="8、移动构造和拷贝构造的区别"><a href="#8、移动构造和拷贝构造的区别" class="headerlink" title="8、移动构造和拷贝构造的区别"></a>8、移动构造和拷贝构造的区别</h4><ol><li>首先 在拷贝构造函数中，如果<strong>涉及到指针</strong>，就需要用到<strong>深拷贝</strong><ul><li>而在<strong>移动构造</strong>函数中,则用的是<strong>浅拷贝</strong></li></ul></li><li>最后 拷贝构造函数的参数是一个<strong>左值</strong>引用<ul><li>而移动构造函数的参数是一个<strong>右值</strong>或<strong>将亡值</strong>的引用</li></ul></li></ol><h4 id="9、重载，重写，隐藏的区别"><a href="#9、重载，重写，隐藏的区别" class="headerlink" title="9、重载，重写，隐藏的区别"></a>9、重载，重写，隐藏的区别</h4><ol><li><p>首先，只有同一范围定义的同名函数才存在重载关系</p><p>重载特点是<strong>函数名相同</strong>，<strong>参数类型</strong>和数目不同</p><ol><li><p>然后，重写是指<strong>子类覆盖父类中的同名函数</strong>，要求<strong>子类函数必须是虚函数，</strong>且与<strong>父类的虚函数</strong>有相同的参数<strong>类型</strong>，参数<strong>个数</strong>，以及<strong>返回值类型</strong></p></li><li><p>所以，重写和重载的<strong>区别</strong></p><ul><li>重载是<strong>函数之间</strong>的关系，重写是<strong>子类和父类</strong>的关系</li><li>重载要求<strong>参数类型和数目不同</strong>，重载要求<strong>参数列表和返回值相同</strong>    </li></ul></li></ol></li><li><p>最后隐藏是指，<strong>子类中的函数屏蔽了父类中的同名函数。</strong>隐藏发生条件如下</p><ul><li><p>两者<strong>函数参数相同</strong>，但<strong>父类函数不是虚函数</strong>。与重写的区别在于<strong>父类是否为虚函数</strong></p></li><li><p>两者参数不同，不管父类是不是虚函数，都会隐藏</p></li></ul></li></ol><h4 id="10、指针常量和常量指针的区别"><a href="#10、指针常量和常量指针的区别" class="headerlink" title="10、指针常量和常量指针的区别"></a>10、指针常量和常量指针的区别</h4><ul><li><p>这里以以C++primer为准 </p><ul><li><p>指针常量：写作int const <em>p，<strong>指针本身</strong>是一个常量，它的<em>*值不能修改</em></em></p></li><li><p>常量指针：写作int<em> const p ,<strong>指针的指向</strong>是一个常量，它的<em>*指向不能修改</em></em></p></li></ul></li></ul><h4 id="11、野指针和悬空指针区别"><a href="#11、野指针和悬空指针区别" class="headerlink" title="11、野指针和悬空指针区别"></a>11、野指针和悬空指针区别</h4><p>首先，它们都是<strong>指向无效内存区域的指针</strong></p><p>野指针：指向的<strong>位置</strong>是<strong>不确定</strong>的</p><ul><li>原因：<strong>指针定义时没有进行初始化</strong></li><li>解决：定义时就进行初始化或置空</li></ul><p>悬空指针：指向的内存区域被释放</p><ul><li>原因：<strong>指针指向的内存被释放，但指针没有及时置空</strong></li><li>解决：<strong>内存释放后及时置空</strong></li></ul><h4 id="12、静态类型和动态类型的区别"><a href="#12、静态类型和动态类型的区别" class="headerlink" title="12、静态类型和动态类型的区别"></a>12、静态类型和动态类型的区别</h4><p>静态类型</p><ul><li>对象在<strong>声明时</strong>采用的类型，在<strong>编译期就已经确定</strong></li></ul><p>动态类型</p><ul><li><strong>一个指针或引用目前所指对象的类型</strong>，在<strong>运行期时才能确定</strong></li></ul><h4 id="13、源文本到文本可执行文件经历的过程"><a href="#13、源文本到文本可执行文件经历的过程" class="headerlink" title="13、源文本到文本可执行文件经历的过程"></a>13、源文本到文本可执行文件经历的过程</h4><p>C++从源码到指向文件有四个过程：预处理、编译、汇编、链接</p><ol><li><p>预处理过程如下</p><ul><li>将所有的#define删除，并且展开所有的<strong>宏定义</strong></li><li><p>处理一些预编译指令，如#ifndef、#ifdef等</p></li><li><p>处理#include预编译指令，将被包含的文件插入到该预编译指令的位置</p></li><li><p>过滤所有的注释</p></li><li>添加行号和文件名标识</li></ul><blockquote><p>ifndef、ifdef的作用是<strong>防止重复包含头文件</strong></p><p>include&lt;&gt; ，<strong>从标准库中寻找头文件。</strong></p><p>include””，<strong>从当前目录开始寻找头文件。</strong></p></blockquote></li><li><p>编译过程分为6步</p><ul><li>词法分析：将源代码的字符序列分割成一系列的记号</li><li>语法分析：对记号进行语法分析，产生语法树</li><li>语义分析：判断表达式是否有意义</li><li>代码优化</li><li>生成汇编代码</li><li>汇编代码优化</li></ul></li><li><p>汇编：这个过程主要是将汇编代码转变成机器可以执行的指令</p></li><li><p>链接：将不同源文件产生的目标文件进行链接，从而形成一个可以执行的程序</p></li></ol><h4 id="递归和循环的区别"><a href="#递归和循环的区别" class="headerlink" title="递归和循环的区别"></a>递归和循环的区别</h4><ol><li>递归时，每递归一层，就会<strong>在内存生成一个调用栈</strong>，来保存本次递归的信息，所以如果递归深度过深，就会有<strong>栈溢出</strong>的问题</li><li>循环是一次<strong>正向</strong>的过程，递归则需要<strong>回溯</strong></li><li>在写法上，递归需要不断调用自身的函数，循环则不需要</li></ol><h4 id="i-和-i的区别"><a href="#i-和-i的区别" class="headerlink" title="i++ 和 ++i的区别"></a>i++ 和 ++i的区别</h4><ol><li>首先 i++是先加后赋值<ul><li>而++i是先赋值后加</li></ul></li><li>其次 前置返回一个<strong>引用</strong>，后置返回一个<strong>对象</strong>。而前置不会产生临时对象，后置必须产生临时对象，临时对象会导致效率降低。所以++i更快</li></ol><hr><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="const的四种作用"><a href="#const的四种作用" class="headerlink" title="const的四种作用"></a>const的四种作用</h4><ol><li>const修饰<strong>局部变量或全局变量</strong>，初始化后不能更改</li><li>const修饰<strong>函数的参数</strong>，为了避免该参数被修改</li><li>用const修饰<strong>函数返回值</strong>，说明函数的返回类型是const的，则返回值不能被修改</li><li>用const修饰<strong>函数</strong>，则不能修改其成员变量的值</li></ol><h4 id="static的作用"><a href="#static的作用" class="headerlink" title="static的作用"></a>static的作用</h4><p>如果不考虑类的情况</p><ol><li>第一个作用是<strong>隐藏</strong>，不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，而加了之后，只能在该文件所在的编译模块中使用</li><li>然后 作用在局部变量上，可以<strong>提高其生命周期</strong>。它不会出代码块而销毁，而是存储在静态存储区中</li><li>最后 用static修饰的变量，<strong>默认初始化为0</strong></li></ol><p>考虑类的情况</p><p>static修饰<strong>成员变量</strong>或者<strong>成员函数</strong></p><p>它就只与类进行关联，而不再属于栈上某个对象的数据，所有对象都<strong>共享</strong>这一块静态存储空间</p><hr><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h4><ol><li><p>封装</p><ul><li>封装是把<strong>客观事物封装成抽象类。</strong>比如把公共的数据或方法用public修饰，把私有的数据或方法用private修饰</li></ul></li><li><p>继承</p><ul><li>继承是让<strong>某个类对象获得另一个类对象的属性和方法。</strong></li></ul></li><li><p>多态</p><ul><li><p>多态是指<strong>同一事物表现出不同的能力</strong></p></li><li><p>多态性是<strong>允许将子类类型的指针赋值给父类类型</strong></p></li></ul></li></ol><p>实现多态的方式有两种：<strong>重写(运行时多态)和重载(编译时多态)</strong></p><h4 id="类的默认成员函数"><a href="#类的默认成员函数" class="headerlink" title="类的默认成员函数"></a>类的默认成员函数</h4><ol><li>无参的构造函数：用于完成对象的初始化工作</li><li>拷贝构造函数：用于复制本类对象</li><li>赋值运算符重载函数：同样也是负责本类的对象</li><li>析构函数：用于对象的清理</li></ol><h4 id="C-类对象的初始化顺序，有多重继承情况下的顺序"><a href="#C-类对象的初始化顺序，有多重继承情况下的顺序" class="headerlink" title="C++ 类对象的初始化顺序，有多重继承情况下的顺序"></a>C++ 类对象的初始化顺序，有多重继承情况下的顺序</h4><ol><li>父类的构造函数<strong>优先</strong>初始化，若父类中包含成员类对象，则再初始化成员类对象，最后再初始化子类对象</li><li>成员变量的初始化与<strong>声明顺序</strong>有关</li><li>析构顺序与构造顺序相反</li></ol><blockquote><p>可以简单的理解为”套娃问题”,子类包含父类的属性和方法，那么子类一定比父类”大”,所以我们要先初始化”小”的，再从外面套上”大”的</p></blockquote><h4 id="简述一下-C-中的多态"><a href="#简述一下-C-中的多态" class="headerlink" title="简述一下 C++ 中的多态"></a>简述一下 C++ 中的多态</h4><p><strong>子类重写父类的方法</strong>，然后用<strong>父类引用或指针指向子类对象</strong>，最后当我们<strong>调用方法</strong>时会进行动态绑定，这就是多态</p><h4 id="静态多态和动态多态区别"><a href="#静态多态和动态多态区别" class="headerlink" title="静态多态和动态多态区别"></a>静态多态和动态多态区别</h4><p>静态多态：在编译期就已经确定，函数的重载就属于静态多态</p><p><strong>动态多态</strong>：在运行时才能确定，并且还需要完成动态绑定的条件</p><ol><li>父类中必须要有<strong>虚函数</strong>，然后<strong>子类重写父类虚函数</strong></li><li>通过父类的<strong>指针</strong>或<strong>引用</strong>来调用这个虚函数</li></ol><h4 id="虚函数指针大小以及位置"><a href="#虚函数指针大小以及位置" class="headerlink" title="虚函数指针大小以及位置"></a>虚函数指针大小以及位置</h4><h4 id="虚函数实现动态多态的原理"><a href="#虚函数实现动态多态的原理" class="headerlink" title="虚函数实现动态多态的原理"></a>虚函数实现动态多态的原理</h4><h4 id="虚函数和纯虚函数的异同"><a href="#虚函数和纯虚函数的异同" class="headerlink" title="虚函数和纯虚函数的异同"></a>虚函数和纯虚函数的异同</h4><p><strong>异</strong>：</p><ol><li><p>首先 含有纯虚函数的类被称为<strong>抽象类</strong></p><ul><li>而只含有虚函数的类不能被称为抽象类。</li></ul></li><li><p>其次 虚函数可以被直接使用，也可以被子类重载以后，以多态的形式调用</p><ul><li>而而纯虚函数<strong>必须在子类中实现该函数</strong>才可以使用，因为纯虚函数在基类有声明而没有定义</li></ul></li><li>最后 它们的<strong>定义形式</strong>也不同，虚函数是：virtual{}，而纯虚函数是virtual{} = 0;</li></ol><p>同：</p><ol><li>首先 虚函数和纯虚函数可以定义在<strong>同一个类</strong>中</li><li>其次 虚函数和纯虚函数都可以在子类中被重载，以多态的形式被调用。</li><li>最后 在虚函数和纯虚函数的定义中不能有static标识符，因为被static修饰的函数在<strong>编译时</strong>就要进行绑定，然而它们却是动态绑定的</li></ol><h4 id="为什么析构函数一般写成虚函数"><a href="#为什么析构函数一般写成虚函数" class="headerlink" title="为什么析构函数一般写成虚函数"></a>为什么析构函数一般写成虚函数</h4><p>如果析构函数不被声明成虚函数，则编译器执行的是静态绑定，在删除父类指针时，只会调用父类的析构函数</p><p>而不调用子类的析构函数，这样就会造成<strong>子类对象析构不完全</strong>，<strong>造成内存泄漏</strong></p><blockquote><p>C++默认的析构函数不写成虚函数，是因为虚函数需要额外的虚函数表和虚函数指针，会占用额外的内存空间。所以我们对于不会被继承的类来说，是不会设置为虚函数的</p></blockquote><h4 id="构造、析构函数是否可以为虚函数"><a href="#构造、析构函数是否可以为虚函数" class="headerlink" title="构造、析构函数是否可以为虚函数"></a>构造、析构函数是否可以为虚函数</h4><p>构造函数<strong>不可以</strong>为虚函数</p><ul><li>因为 虚函数所对应的<strong>虚函数表的地址</strong>是存储在<strong>对象的内存空间</strong>中的，而此时对象都还没实例化，就没有空间让虚函数表存储地址。所以这里就会冲突</li></ul><p>析构函数<strong>可以</strong>为虚函数</p><ul><li>我们可以将需要被继承的父类的析构函数设置为虚函数。当我们<strong>父类类型的指针绑定到子类对象</strong>时，能够保证<strong>释放父类指针的时候 可以同时释放掉子类的空间</strong>，防止内存泄漏</li></ul><h4 id="虚函数实现原理，虚指针大小"><a href="#虚函数实现原理，虚指针大小" class="headerlink" title="虚函数实现原理，虚指针大小"></a>虚函数实现原理，虚指针大小</h4><hr><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="什么是内存对齐"><a href="#什么是内存对齐" class="headerlink" title="什么是内存对齐"></a><strong>什么是内存对齐</strong></h4><p>系统对基本类型数据在<strong>内存中存放的位置</strong>有限制，它们会要求这些数据的<strong>首地址的值是某个数k（通常它为4或8）的倍数</strong>，这就是所谓的内存对齐。比如一个结构体中有一个int类型的数据和一个char类型的数据，它实际sizeof出来的大小占8个字节</p><p><strong>为什么要进行内存对齐</strong></p><p>为了<strong>提高数据读取的效率</strong>，程序分配的内存并不是连续存储的，而是按首地址为k的倍数的方式存储；这样就可以一次性读取数据，而不需要额外的操作</p><blockquote><p>结构体内成员<strong>按照声明顺序存储</strong>，<strong>第一个成员地址和整个结构体地址相同</strong></p><p> 未特殊说明时，按结构体中<strong>size最大</strong>的成员对齐（若有double成员，按8字节对齐。）</p></blockquote><h4 id="栈和堆的区别"><a href="#栈和堆的区别" class="headerlink" title="栈和堆的区别"></a>栈和堆的区别</h4><ol><li>首先 栈由操作系统自动分配释放，一般用于存放函数的参数，或局部变量<ul><li>堆由程序员通过new/delete关键字手动分配和释放</li></ul></li><li>其次 栈使用的是一级缓存，通常是被调用时处于存储空间中，调用完毕立即释放<ul><li>而堆则存在二级缓存中，速度要慢一些</li></ul></li><li>最后 栈的结果是先进先出，而堆是先进后出</li></ol><h4 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h4><p>在C++中，内存分成5个区。分别是<strong>栈区、堆区、静态存储区、常量存储区、以及代码区</strong></p><ul><li><strong>栈区</strong>：仅在<strong>定义的程序块运行</strong>时才存在。一般用于存储<strong>局部变量</strong>和<strong>函数的形参</strong></li><li><strong>堆区</strong>：堆区的内存是通过new运算符动态分配的，也必须通过detele运算符手动销毁</li><li><strong>静态存储区</strong>：内存在程序<strong>编译时</strong>就以及分配好,主要用于存放<strong>全局变量</strong>和<strong>静态变量</strong></li><li><strong>常量存储区</strong>：这是一块比较特殊的存储区域，里面存放着<strong>常量</strong>。不允许进行修改</li><li><strong>代码区</strong>：存放着程序的二进制代码</li></ul><h4 id="内存管理-1"><a href="#内存管理-1" class="headerlink" title="内存管理"></a>内存管理</h4><h4 id="C-类声明的对象占用的内存空间，大致里面有哪些内容"><a href="#C-类声明的对象占用的内存空间，大致里面有哪些内容" class="headerlink" title="C++ 类声明的对象占用的内存空间，大致里面有哪些内容"></a>C++ 类声明的对象占用的内存空间，大致里面有哪些内容</h4><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>简单地说就是申请了一块内存空间，使用完毕后没有释放掉</p><p>比如：</p><ol><li><p>new/malloc申请内存后，没有用delete/free释放</p></li><li><p>子类继承父类时，父类析构函数不是虚函数</p></li></ol><h4 id="避免内存泄漏"><a href="#避免内存泄漏" class="headerlink" title="避免内存泄漏"></a>避免内存泄漏</h4><ul><li>首先 可以用计数法，当我们使用new或者malloc的时候，计数就+1，而使用detele或free时，计数就-1。最后打印这个计数，看看最后结果是否为0</li><li>然后 一定要将父类的析构函数声明为虚函数</li><li>最后要保证new/delete ， malloc/free成对出现</li></ul><p>解决方法：使用<strong>智能指针</strong></p><h4 id="C-delete空指针会发生什么"><a href="#C-delete空指针会发生什么" class="headerlink" title="C++ delete空指针会发生什么"></a>C++ delete空指针会发生什么</h4><h4 id="new-delete-与-malloc-free的异同"><a href="#new-delete-与-malloc-free的异同" class="headerlink" title="new/delete 与 malloc/free的异同"></a>new/delete 与 malloc/free的异同</h4><p>相同点：<br>都可以用于内存的动态申请和释放</p><p>不同点：</p><ol><li><p>首先 new/delete 是C++中的<strong>运算符。</strong>而malloc/free是C/C++中的<strong>标准库函数</strong></p></li><li><p>其次 new 在分配内存时会<strong>自动计算空间大小。</strong>而malloc需要手动计算</p></li><li>最后 new/delete 除了分配内存和回收内存以外，还具有调用构造函数和析构函数的功能。而malloc/free则只有会分配内存和回收内存</li></ol><h4 id="new和delete是如何实现的"><a href="#new和delete是如何实现的" class="headerlink" title="new和delete是如何实现的"></a>new和delete是如何实现的</h4><p>new实现过程：</p><ol><li>先通过<strong>operator new()</strong>函数，它内部会调用malloc，在<strong>堆中分配一块内存</strong></li><li>然后 将<strong>void类型</strong>的指针，转换为<strong>类类型</strong>的指针</li><li>最后再<strong>通过指针调用构造函数</strong>，用于初始化对象</li></ol><p>delete实现过程：</p><ol><li>首先 调用<strong>析构函数</strong>，<strong>删除内存中指针所指的数据</strong></li><li>然后 通过<strong>operator delete()</strong>函数,它内部<strong>调用free去删除对象本身</strong></li></ol><hr><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><h4 id="STL中迭代器的作用，有指针为何还要迭代器"><a href="#STL中迭代器的作用，有指针为何还要迭代器" class="headerlink" title="STL中迭代器的作用，有指针为何还要迭代器"></a>STL中迭代器的作用，有指针为何还要迭代器</h4><ol><li><p>迭代器的作用</p><ul><li>用于指向<strong>顺序容器</strong>和<strong>关联容器</strong>中的元素</li><li>通过迭代器可以<strong>读取它指向的元素</strong></li><li>通过<strong>非const</strong>迭代器还可以<strong>修改其指向的元素</strong></li></ul></li><li><p>迭代器与指针的区别</p><ul><li>迭代器是<strong>类模板</strong>，它只是表现的像指针。它模拟了指针的一些功能，重载了指针的一些操作符</li></ul></li></ol><h4 id="vector-和-list的对比"><a href="#vector-和-list的对比" class="headerlink" title="vector 和 list的对比"></a>vector 和 list的对比</h4><p>  <strong>vector：一维数组</strong></p><p>  特点：元素在内存<strong>连续存放</strong>，支持<strong>动态扩容</strong>，在堆中分配内存，元素连续存放，有保留内存，如果减少大小后内存也不会释放。</p><p>  优点：和数组类似开辟一段连续的空间，并且支持随机访问，所以它的查找效率高其时间复杂度O(1)。</p><p>  缺点：由于开辟一段连续的空间，所以插入删除会需要对数据进行移动比较麻烦，时间复杂度O（n），另外当空间不足时还需要进行扩容。</p><p>  <strong>list：双向链表</strong></p><p>  特点：元素在堆中存放，每个元素都是存放在一块内存中，它的内存空间可以是不连续的，通过指针来进行数据的访问。</p><p>  优点：底层实现是循环双链表，当对大量数据进行插入删除时，其时间复杂度O(1)。</p><p>  缺点：底层没有连续的空间，只能通过指针来访问，所以查找数据需要遍历其时间复杂度O（n），没有提供[]操作符的重载。</p><h4 id="map-和-unordered-map-的区别以及底层实现"><a href="#map-和-unordered-map-的区别以及底层实现" class="headerlink" title="map 和 unordered_map 的区别以及底层实现"></a>map 和 unordered_map 的区别以及底层实现</h4><ul><li><p>map内部实现了一个<strong>红黑树</strong>，红黑树有<strong>自动排序</strong>的功能，因此map内部所有元素都是有序的。</p><p>红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。</p><p>map中的元素是按照<strong>二叉排序树</strong>的方式存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用<strong>中序遍历</strong>可将键值按照从小到大遍历出来</p></li><li><p>unordered_map内部实现了一个<strong>哈希表</strong>，通过把关键值映射到Hash表中一个位置来访问记录，查找时间复杂度可达O(1)。因此它是无序的</p></li></ul><h4 id="请说说-STL-中常见的容器，并介绍一下实现原理"><a href="#请说说-STL-中常见的容器，并介绍一下实现原理" class="headerlink" title="请说说 STL 中常见的容器，并介绍一下实现原理"></a>请说说 STL 中常见的容器，并介绍一下实现原理</h4><p>容器是可以用于存放各种类型数据的数据结构。可以分为<strong>顺序</strong>容器、<strong>关联式</strong>容器、<strong>容器适配器</strong>三种类型</p><p><strong>顺序容器</strong>：</p><p>​    容器中的元素没有进行排序，元素插入位置与元素的值无关。包含vector、list、deque</p><ul><li><p><strong>vector</strong> 的本质是<strong>动态数组</strong>。元素在内存<strong>连续存放</strong>。随机存取任何元素都能在常数时间完成。在<strong>尾端</strong>增删元素具有较佳的性能。</p></li><li><p><strong>list</strong> 的本质是<strong>双向链表</strong>。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。但<strong>不支持随机存取</strong>。</p></li><li>deque 的本质是<strong>双向队列</strong>。元素在内存<strong>连续存放</strong>。随机存取任何元素都能在常数时间完成（仅次于vector）。在<strong>两端</strong>增删元素具有较佳的性能（大部分情况下是常数时间）</li></ul><p><strong>关联式容器</strong>：</p><p>​      元素是<strong>排序</strong>的；插入任何元素，都<strong>按相应的排序规则来确定其位置</strong>；在<strong>查找</strong>时具有非常好的性能；通常以<strong>平衡二叉树</strong>的方式实现。包含set、multiset、map、multimap(都是基于<strong>红黑树</strong>实现)</p><ul><li><strong>map</strong> 的底层容器是<strong>红黑树</strong>。map 的所有元素都是<strong>成对</strong>的，它的第一个元素被当成键，第二个元素被当成值。所有的元素都会根据元素的键值<strong>自动排序</strong>，且<strong>不允许键值重复</strong></li><li>set 的底层容器也是红黑树。但set中所有的元素<strong>只有键</strong>，没有值。<strong>不允许键重复</strong>，其中的元素会被<strong>自动排序</strong>，且<strong>不能通过迭代器来改变set的值</strong>，因为set的值就是键，set的迭代器是const的</li></ul><p>所以map和set的<strong>区别</strong>在于map的值不作为键，<strong>键和值是分开的</strong></p><p>容器适配器</p><p>​     封装了一些基本的容器，使之具备了新的函数功能，比如把deque封装一下，变为一个具有stack功能的数据结构</p><h4 id="vector扩容机制，以及1-5倍扩容因子的优点"><a href="#vector扩容机制，以及1-5倍扩容因子的优点" class="headerlink" title="vector扩容机制，以及1.5倍扩容因子的优点"></a>vector扩容机制，以及1.5倍扩容因子的优点</h4><p>vector有保留内存，当减少vector的大小后，内存并不会释放；只有新增大小大于当前大小时，才会开辟新的内存空间</p><p><strong>扩容机制</strong>：</p><ul><li>首先 开辟1.5倍的内存空间</li><li>然后 将旧数据拷贝到新的内存</li><li>再 释放旧内存</li><li>最后 指向新内存</li></ul><h3 id="C-11特性"><a href="#C-11特性" class="headerlink" title="C++ 11特性"></a>C++ 11特性</h3><h4 id="简述一下移动构造函数"><a href="#简述一下移动构造函数" class="headerlink" title="简述一下移动构造函数"></a>简述一下移动构造函数</h4><p>移动构造函数实现的是<strong>对象值真实的转移</strong>。比如从A移动到B，这说明将分配给A的内存转移给了B。而不是新开一块内存给B</p><h4 id="智能指针是否线程安全"><a href="#智能指针是否线程安全" class="headerlink" title="智能指针是否线程安全"></a>智能指针是否线程安全</h4><p>智能指针包括一个实际数据指针和一个引用计数指针，这两个操作不是一个指令可以完成的，因此多线程环境下，是会有问题的</p><ul><li>同一个shared_ptr被多个线程读，是线程安全的；</li><li>同一个shared_ptr被多个线程写，不是线程安全的；</li></ul><h4 id="左值和右值的概念"><a href="#左值和右值的概念" class="headerlink" title="左值和右值的概念"></a>左值和右值的概念</h4><p><strong>左值</strong></p><ul><li>左值指既能够出现在等号左边，也能出现在等号右边的变量</li><li>它是可寻址的变量，有持久性</li><li>左值引用：引用一个对象(平时指的引用一般是左值引用)</li></ul><p><strong>右值</strong></p><ul><li><p>右值则是只能出现在等号右边的变量</p></li><li><p>一般是<strong>不可寻址</strong>的常量，或在表达式求值过程中创建的<strong>无名临时对象</strong>，<strong>短暂性</strong>的</p></li><li>右值引用：C++11中右值引用可以实现“移动语义”，通过 &amp;&amp; 获得右值引用</li></ul><h4 id="智能指针的作用、原理、以及常用的智能指针"><a href="#智能指针的作用、原理、以及常用的智能指针" class="headerlink" title="智能指针的作用、原理、以及常用的智能指针"></a>智能指针的作用、原理、以及常用的智能指针</h4><p><strong>作用</strong></p><p>让我们更方便的管理堆内存，若使用普通指针，则容易造成堆内存忘记释放、二次释放，程序发生异常时内存泄露等问题等。而使用智能指针能更好的管理堆内存</p><p><strong>原理</strong> </p><p>智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。将动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源 </p><p><strong>常用的智能指针</strong></p><ol><li>shared_ptr<ul><li>采用<strong>引用计数器</strong>的方法，允许多个智能指针指向同一个对象</li><li>每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1</li><li>当计数为0的时候会自动的释放动态分配的资源。</li></ul></li><li>unique_ptr<ul><li>采用的是<strong>独享所有权</strong>语义，一个非空的unique_ptr总是拥有它所指向的资源</li><li>转移一个 unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空；所以unique_ptr<strong>不支持普通的拷贝和赋值</strong>操作，<strong>不能用在STL标准容器中</strong></li><li>如果你拷贝一个unique_ptr，那么拷贝结束后，这两个unique_ptr都会指向相同的资源，造成 在结束时对同一内存指针多次释放而导致程序崩溃。</li></ul></li><li>weak_ptr<ul><li>首先 引用计数有一个问题就是<strong>互相引用形成环</strong>（环形引用），这样<strong>两个指针指向的内存都无法释放</strong>。</li><li>所以需要使用weak_ptr打破环形引用。weak_ptr是一个<strong>弱引用</strong>，它是为了配合shared_ptr而引入 的一种智能指针，<strong>它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期</strong>，也就是说，它只引用，不计数。</li><li>如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针。</li></ul></li><li>auto_ptr(C++ 11弃用)<ul><li>主要是为了解决“有<strong>异常抛出时发生内存泄漏</strong>”的问题 。因为发生异常而无法正常释放内存</li><li>但auto_ptr有拷贝语义，拷贝后源对象变得无效，这可能引发内存崩溃</li><li>而unique_ptr则无拷贝语义， 但提供了移动语义，避免这样的错误再次发生</li></ul></li></ol><h4 id="C-智能指针实现引用计数的原理"><a href="#C-智能指针实现引用计数的原理" class="headerlink" title="C++ 智能指针实现引用计数的原理"></a>C++ 智能指针实现引用计数的原理</h4><ol><li>智能指针将一个计数器与类指向的对象相关联，引用计数器跟踪共有多少个类对象共享同一指针 </li><li>每次创建类的新对象时，初始化指针并将引用计数置为1 </li><li>当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数 </li><li>对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则 删除对象），并增加右操作数所指对象的引用计数 </li><li>调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）</li></ol><h4 id="C-11-中四种类型转换"><a href="#C-11-中四种类型转换" class="headerlink" title="C++11 中四种类型转换"></a>C++11 中四种类型转换</h4><p>C++中四种类型转换分别为<strong>const_cast、static_cast、dynamic_cast、reinterpret_cast</strong></p><ul><li>const_cast：将const变量转为非const</li><li>static_cast：最常用，可以<strong>用于各种隐式转换</strong>，比如非const转const。还可以用于<strong>类向上转换</strong>，但向下转换能成功但是不安全</li><li>dynamic_cast：只能用于含有虚函数的类转换，用于类向上和向下转换</li><li>reinterpret_cast：可以做任何类型的转换，但不保证转换结果是否正确</li></ul><blockquote><p><strong>向上转换</strong>：子类向父类转换</p><p><strong>向下转换</strong>：父类向子类转换</p></blockquote><hr><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="TCP-三次握手和四次挥手的过程"><a href="#TCP-三次握手和四次挥手的过程" class="headerlink" title="TCP 三次握手和四次挥手的过程"></a>TCP 三次握手和四次挥手的过程</h3><p><strong>三次握手</strong></p><ul><li>第一次握手：建立连接时，客户端向服务器<strong>发送SYN包（seq=x）</strong>，请求建立连接，等待确认</li><li>第二次握手：服务端收到客户端的SYN包，<strong>回一个ACK包</strong>（ACK=x+1）确认收到，<strong>同时发送一个SYN包</strong>（seq=y）给客户端</li><li>第三次握手：客户端收到SYN+ACK包，<strong>再回一个ACK包</strong>（ACK=y+1）告诉服务端已经收到</li><li>最后三次握手完成，成功建立连接，开始传输数据</li></ul><blockquote><p>可以简单理解 SYN包用来建立联系，ACK包用来表示收到</p></blockquote><p><strong>四次挥手</strong></p><p>客户端发送<strong>FIN包</strong>（FIN=1)给服务端，告诉它自己的数据已经发送完毕，请求终止连接，此时<strong>客户端不发送数据</strong>，<strong>但还能接收数据</strong></p><ul><li>服务端收到FIN包，<strong>回一个ACK</strong>包给客户端告诉它已经收到包了，此时还<strong>没有断开socket连接</strong>，而是<strong>等待剩下的数据传输完毕</strong></li><li>服务端等待数据传输完毕后，向客户端<strong>发送FIN包</strong>，表明可以断开连接</li><li>客户端收到后，<strong>回一个ACK包</strong>表明确认收到，等待一段时间，确<strong>保服务端不再有数据发过来</strong>，然后彻底断开连接</li></ul><blockquote><p>FIN包用来终止联系</p></blockquote><h3 id="TCP-2次握手行不行？为什么要3次"><a href="#TCP-2次握手行不行？为什么要3次" class="headerlink" title="TCP 2次握手行不行？为什么要3次"></a>TCP 2次握手行不行？为什么要3次</h3><p>不行。为了实现可靠数据传输， TCP 协议的通信双方， 都必须<strong>维护一个序列号</strong>， 以标识在发送出去的数据包中， 确定哪些是已经被对方收到的</p><p>如果只是两次握手，则最多<strong>只有发送方的起始序列号能被确认</strong>，而<strong>另一方的序列号得不到确认</strong></p><h3 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h3><ol><li>TCP协议是<strong>有连接</strong>的，即开始传输实际数据之前，TCP的客户端和服务器端必须通过三次握手建立连接，会话结束之后也要结束连接<ul><li>而UDP是<strong>无连接</strong>的</li></ul></li><li><p>TCP协议保证数据<strong>按序发送</strong>，<strong>按序到达</strong>，提供<strong>超时重传</strong>来保证可靠性</p><ul><li>而UDP<strong>不保证按序到达</strong>，甚至<strong>不保证到达</strong>，只是<strong>努力交付</strong></li></ul></li><li><p>TCP协议<strong>所需资源多</strong>，TCP首部需20个字节</p><ul><li>而UDP首部字段只需8个字节</li></ul></li><li>TCP有<strong>流量控制</strong>和<strong>拥塞控制</strong><ul><li>而UDP没有，<strong>网络拥堵不会影响发送端的发送速率</strong></li></ul></li><li>TCP是<strong>一对一</strong>的连接<ul><li>UDP则可以支持<strong>一对一</strong>，<strong>多对多</strong>，<strong>一对多</strong>的通信</li></ul></li></ol><h3 id="进程、线程的区别"><a href="#进程、线程的区别" class="headerlink" title="进程、线程的区别"></a>进程、线程的区别</h3><ol><li><p>进程是<strong>资源分配和拥有的基本单位</strong></p><ul><li>而线程是<strong>CPU程序执行的基本单位</strong></li></ul></li><li><p>一个线程挂掉，对应的进程挂掉</p><ul><li>一个进程挂掉，不会影响其它进程</li></ul></li><li>进程系统开销明显大于线程开销<ul><li>线程所需的系统资源更新</li></ul></li></ol><h1 id="中大厂面经"><a href="#中大厂面经" class="headerlink" title="中大厂面经"></a>中大厂面经</h1><h2 id="37互娱"><a href="#37互娱" class="headerlink" title="37互娱"></a>37互娱</h2><h3 id="C-C"><a href="#C-C" class="headerlink" title="C++/C"></a>C++/C</h3><h4 id="引用和指针的区别"><a href="#引用和指针的区别" class="headerlink" title="引用和指针的区别"></a>引用和指针的区别</h4><h4 id="数组和vector容器的区别"><a href="#数组和vector容器的区别" class="headerlink" title="数组和vector容器的区别"></a>数组和vector容器的区别</h4><h4 id="C-的GC"><a href="#C-的GC" class="headerlink" title="C#的GC"></a>C#的GC</h4><p>垃圾回收的过程是<strong>遍历堆上动态分配的所有对象</strong>，通过识别它们<strong>是否被引用</strong>，来确定哪些对象是垃圾，哪些对象仍要被引用</p><h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><h4 id="说一种排序的思想，以及时间和空间复杂度"><a href="#说一种排序的思想，以及时间和空间复杂度" class="headerlink" title="说一种排序的思想，以及时间和空间复杂度"></a>说一种排序的思想，以及时间和空间复杂度</h4><h3 id="Unity相关"><a href="#Unity相关" class="headerlink" title="Unity相关"></a>Unity相关</h3><h4 id="GUI层级问题，王者英雄展示界面？"><a href="#GUI层级问题，王者英雄展示界面？" class="headerlink" title="GUI层级问题，王者英雄展示界面？"></a>GUI层级问题，王者英雄展示界面？</h4><h4 id="动画骨骼，Unity一个关节最多几个骨骼连接"><a href="#动画骨骼，Unity一个关节最多几个骨骼连接" class="headerlink" title="动画骨骼，Unity一个关节最多几个骨骼连接"></a>动画骨骼，Unity一个关节最多几个骨骼连接</h4><h3 id="其它相关"><a href="#其它相关" class="headerlink" title="其它相关"></a>其它相关</h3><h4 id="TCP和UDP，三次挥手问题"><a href="#TCP和UDP，三次挥手问题" class="headerlink" title="TCP和UDP，三次挥手问题"></a>TCP和UDP，三次挥手问题</h4><h4 id="协程和线程的区别和特点"><a href="#协程和线程的区别和特点" class="headerlink" title="协程和线程的区别和特点"></a>协程和线程的区别和特点</h4><h4 id="图形学渲染过程"><a href="#图形学渲染过程" class="headerlink" title="图形学渲染过程"></a>图形学渲染过程</h4><h4 id="Lua与热更新"><a href="#Lua与热更新" class="headerlink" title="Lua与热更新"></a>Lua与热更新</h4><h2 id="完美世界"><a href="#完美世界" class="headerlink" title="完美世界"></a>完美世界</h2><h3 id="C-C-1"><a href="#C-C-1" class="headerlink" title="C++/C"></a>C++/C</h3><h4 id="面向对象思想，多态如何实现。"><a href="#面向对象思想，多态如何实现。" class="headerlink" title="面向对象思想，多态如何实现。"></a>面向对象思想，多态如何实现。</h4><h4 id="虚函数原理，虚表指针位置"><a href="#虚函数原理，虚表指针位置" class="headerlink" title="虚函数原理，虚表指针位置"></a>虚函数原理，虚表指针位置</h4><h4 id="类的内存模型"><a href="#类的内存模型" class="headerlink" title="类的内存模型"></a>类的内存模型</h4><h4 id="C-11新特性（了解哪些）"><a href="#C-11新特性（了解哪些）" class="headerlink" title="C++11新特性（了解哪些）"></a>C++11新特性（了解哪些）</h4><h4 id="智能指针、野指针"><a href="#智能指针、野指针" class="headerlink" title="智能指针、野指针"></a>智能指针、野指针</h4><h4 id="stl容器"><a href="#stl容器" class="headerlink" title="stl容器"></a>stl容器</h4><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="vector删除所有值为value的元素"><a href="#vector删除所有值为value的元素" class="headerlink" title="vector删除所有值为value的元素"></a>vector删除所有值为value的元素</h4><h4 id="vector的扩容机制，插入元素的时间复杂度，如何计算"><a href="#vector的扩容机制，插入元素的时间复杂度，如何计算" class="headerlink" title="vector的扩容机制，插入元素的时间复杂度，如何计算"></a>vector的扩容机制，插入元素的时间复杂度，如何计算</h4><h3 id="Unity相关-1"><a href="#Unity相关-1" class="headerlink" title="Unity相关"></a>Unity相关</h3><h3 id="其它相关-1"><a href="#其它相关-1" class="headerlink" title="其它相关"></a>其它相关</h3><h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><h4 id="死锁相关"><a href="#死锁相关" class="headerlink" title="死锁相关"></a>死锁相关</h4><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><h4 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h4><h2 id="祖龙"><a href="#祖龙" class="headerlink" title="祖龙"></a>祖龙</h2><h3 id="C-C-2"><a href="#C-C-2" class="headerlink" title="C++/C"></a>C++/C</h3><h4 id="float和int分别以什么形式存储的"><a href="#float和int分别以什么形式存储的" class="headerlink" title="float和int分别以什么形式存储的"></a>float和int分别以什么形式存储的</h4><h4 id="多态如何实现"><a href="#多态如何实现" class="headerlink" title="多态如何实现"></a>多态如何实现</h4><h4 id="stl各种容器机制及其区别"><a href="#stl各种容器机制及其区别" class="headerlink" title="stl各种容器机制及其区别"></a>stl各种容器机制及其区别</h4><h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><h4 id="函数闭包"><a href="#函数闭包" class="headerlink" title="函数闭包"></a>函数闭包</h4><h4 id="模板、模板特化、模板偏特化"><a href="#模板、模板特化、模板偏特化" class="headerlink" title="模板、模板特化、模板偏特化"></a>模板、模板特化、模板偏特化</h4><h4 id="模板是如何实现的"><a href="#模板是如何实现的" class="headerlink" title="模板是如何实现的"></a>模板是如何实现的</h4><h4 id="auto关键字寻找类型的原理"><a href="#auto关键字寻找类型的原理" class="headerlink" title="auto关键字寻找类型的原理"></a>auto关键字寻找类型的原理</h4><h4 id="描述调用main函数、实例化类，调用类中的成员函数，这一系列操作中程序的执行过程"><a href="#描述调用main函数、实例化类，调用类中的成员函数，这一系列操作中程序的执行过程" class="headerlink" title="描述调用main函数、实例化类，调用类中的成员函数，这一系列操作中程序的执行过程"></a>描述调用main函数、实例化类，调用类中的成员函数，这一系列操作中程序的执行过程</h4><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="avl树和红黑树的区别，优劣"><a href="#avl树和红黑树的区别，优劣" class="headerlink" title="avl树和红黑树的区别，优劣"></a>avl树和红黑树的区别，优劣</h4><h4 id="红黑树的实现原理"><a href="#红黑树的实现原理" class="headerlink" title="红黑树的实现原理"></a>红黑树的实现原理</h4><h4 id="哈希表的实现原理，哈希冲突解决"><a href="#哈希表的实现原理，哈希冲突解决" class="headerlink" title="哈希表的实现原理，哈希冲突解决"></a>哈希表的实现原理，哈希冲突解决</h4><h4 id="单链表中删除一个指定节点的时间复杂度，如何计算。"><a href="#单链表中删除一个指定节点的时间复杂度，如何计算。" class="headerlink" title="单链表中删除一个指定节点的时间复杂度，如何计算。"></a>单链表中删除一个指定节点的时间复杂度，如何计算。</h4><h3 id="Unity相关-2"><a href="#Unity相关-2" class="headerlink" title="Unity相关"></a>Unity相关</h3><h4 id="协程执行的时机"><a href="#协程执行的时机" class="headerlink" title="协程执行的时机"></a>协程执行的时机</h4><h4 id="update、awake等的执行顺序"><a href="#update、awake等的执行顺序" class="headerlink" title="update、awake等的执行顺序"></a>update、awake等的执行顺序</h4><h4 id="timescale会影响update、fixedupdate或lateupdate吗"><a href="#timescale会影响update、fixedupdate或lateupdate吗" class="headerlink" title="timescale会影响update、fixedupdate或lateupdate吗"></a>timescale会影响update、fixedupdate或lateupdate吗</h4><h4 id="unity的架构了解吗"><a href="#unity的架构了解吗" class="headerlink" title="unity的架构了解吗"></a>unity的架构了解吗</h4><h4 id="如何判断物体在不在摄像机的范围中"><a href="#如何判断物体在不在摄像机的范围中" class="headerlink" title="如何判断物体在不在摄像机的范围中"></a>如何判断物体在不在摄像机的范围中</h4><h3 id="其它相关-2"><a href="#其它相关-2" class="headerlink" title="其它相关"></a>其它相关</h3><h4 id="帧同步与状态同步"><a href="#帧同步与状态同步" class="headerlink" title="帧同步与状态同步"></a>帧同步与状态同步</h4><h4 id="死锁预防、检测、消除"><a href="#死锁预防、检测、消除" class="headerlink" title="死锁预防、检测、消除"></a>死锁预防、检测、消除</h4><h4 id="使用udp的过程中，需要注意哪些问题"><a href="#使用udp的过程中，需要注意哪些问题" class="headerlink" title="使用udp的过程中，需要注意哪些问题"></a>使用udp的过程中，需要注意哪些问题</h4><h2 id="西山居"><a href="#西山居" class="headerlink" title="西山居"></a>西山居</h2><h3 id="C-C-3"><a href="#C-C-3" class="headerlink" title="C++/C"></a>C++/C</h3><h4 id="new、delete和malloc、free的区别"><a href="#new、delete和malloc、free的区别" class="headerlink" title="new、delete和malloc、free的区别"></a>new、delete和malloc、free的区别</h4><h4 id="构造、析构是否可以是虚函数"><a href="#构造、析构是否可以是虚函数" class="headerlink" title="构造、析构是否可以是虚函数"></a>构造、析构是否可以是虚函数</h4><h4 id="虚函数实现原理，虚指针大小-1"><a href="#虚函数实现原理，虚指针大小-1" class="headerlink" title="虚函数实现原理，虚指针大小"></a>虚函数实现原理，虚指针大小</h4><h4 id="内联、宏、普通函数的区别（内联和宏分别如何实现）"><a href="#内联、宏、普通函数的区别（内联和宏分别如何实现）" class="headerlink" title="内联、宏、普通函数的区别（内联和宏分别如何实现）"></a>内联、宏、普通函数的区别（内联和宏分别如何实现）</h4><h4 id="函数调用过程"><a href="#函数调用过程" class="headerlink" title="函数调用过程"></a>函数调用过程</h4><h4 id="c-object使用注意事项"><a href="#c-object使用注意事项" class="headerlink" title="c# object使用注意事项"></a>c# object使用注意事项</h4><h4 id="static特性，static变量初始化的时机。"><a href="#static特性，static变量初始化的时机。" class="headerlink" title="static特性，static变量初始化的时机。"></a>static特性，static变量初始化的时机。</h4><h4 id="程序运行时，存储区如何划分"><a href="#程序运行时，存储区如何划分" class="headerlink" title="程序运行时，存储区如何划分"></a>程序运行时，存储区如何划分</h4><h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="红黑树、哈希表优劣"><a href="#红黑树、哈希表优劣" class="headerlink" title="红黑树、哈希表优劣"></a>红黑树、哈希表优劣</h4><h4 id="红黑树原理、哈希表原理、哈希冲突"><a href="#红黑树原理、哈希表原理、哈希冲突" class="headerlink" title="红黑树原理、哈希表原理、哈希冲突"></a>红黑树原理、哈希表原理、哈希冲突</h4><h4 id="解决哈希冲突的方法各自的优劣"><a href="#解决哈希冲突的方法各自的优劣" class="headerlink" title="解决哈希冲突的方法各自的优劣"></a>解决哈希冲突的方法各自的优劣</h4>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Game101-03Transformation</title>
      <link href="blog/Game101-03Transformation/"/>
      <url>blog/Game101-03Transformation/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Transformation-变换"><a href="#Transformation-变换" class="headerlink" title="Transformation(变换)"></a>Transformation(变换)</h2><p><strong>课程回顾</strong></p><ul><li>向量点乘</li></ul><blockquote><p>向量点乘的结果是一个数，可以用来判断另一个物体位置的前后</p><p>点乘结果为正，另一个物体在前方</p><p>点乘结果为负，另一个物体在后方</p></blockquote><ul><li>向量叉乘</li></ul><blockquote><p> 向量叉乘结果是一个新向量，可以用来判断另一个物体的相对左右关系</p><p> 若新向量的结果大于0，根据右手定则判断，则另一个物体在左边</p><p> 若新向量的结果小于0，根据右手定则判断，则另一个物体在右边</p></blockquote><ul><li>矩阵</li></ul><blockquote><p>用来表示位置的变换</p></blockquote><h3 id="2D-变换"><a href="#2D-变换" class="headerlink" title="2D 变换"></a>2D 变换</h3><h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4><img src="/blog/Game101-03Transformation/image-20220506220710135.png" class="" title="image-20220506220710135"><blockquote><p>如果将一个图片进行缩放，就是将其的x、y 坐标缩放s 倍。在数学上的形式就是：</p><p>x’ = sx;</p><p>y’ = sy;</p><p>若将这两个式子写成矩阵形式：</p></blockquote><img src="/blog/Game101-03Transformation/image-20220506223318676.png" class="" title="image-20220506223318676"><blockquote><p>第一个矩阵是2行1列，第三个矩阵也是是2行一列，所以第二个矩阵就是2行2列，多出的用0补齐</p><p>这样的话也能满足</p><p>x‘ 是一行一列，它等于(s,0)向量和(x,y)向量的点乘，也就是sx</p><p>y’ 是二行一列，它等于(0,s)向量和(x,y)向量的点乘，也就是sy</p><p>所以这里的[s,0,0,s] 对角阵矩阵就被称为<strong>缩放矩阵</strong>，当s 等于0.5时，就对应着图像会缩放0.5倍</p></blockquote><p><strong>x、y不等比缩放</strong></p><img src="/blog/Game101-03Transformation/image-20220506224848203.png" class="" title="image-20220506224848203"><blockquote><p>对于x，y不等比缩放的情况，只需要将对角阵矩阵中的s对应修改就可以</p></blockquote><img src="/blog/Game101-03Transformation/image-20220506225016005.png" class="" title="image-20220506225016005"><h4 id="对称"><a href="#对称" class="headerlink" title="对称"></a><strong>对称</strong></h4><img src="/blog/Game101-03Transformation/image-20220506225212749.png" class="" title="image-20220506225212749"><blockquote><p>图片相对于y轴进行反转，就能得到相对于y轴的对称图形，数学形式表示如下</p><p>x’ = -x</p><p>y’ = y</p><p>若写成矩阵形式则表示如下</p></blockquote><img src="/blog/Game101-03Transformation/image-20220506225840974.png" class="" title="image-20220506225840974"><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><img src="/blog/Game101-03Transformation/image-20220506225943927.png" class="" title="image-20220506225943927"><blockquote><p>相当于拖着图片的上面那条边，向右沿着水平方向拖拽，图片发生形变。</p><p>由于是沿着水平方向拖拽，所以图片的y轴并没有发生改变</p><p>就能先得到y‘ = y</p><p>然后分析x轴，图片处于x轴坐标上的这条边位置变化为 0，而只有上面的边平移了a</p><p>也就是y = 0时 x轴变化为0，y = 1时 x变化为a，则水平方向移动了ay</p><p>所以能得到x’ = x + ay</p><p>用矩阵表示如下</p></blockquote><img src="/blog/Game101-03Transformation/image-20220506231928622.png" class="" title="image-20220506231928622"><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><img src="/blog/Game101-03Transformation/image-20220506232414740.png" class="" title="image-20220506232414740"><blockquote><p>当我们不说其它条件时，就是默认绕着<strong>原点</strong>(0,0)进行<strong>逆时针旋转</strong></p><p>图像旋转后，原本(1,0)的点，变成了(cosθ,sinθ)</p><p>再通过矩阵的计算，可以得到旋转后的矩阵</p><p>cosθ -sinθ</p><p>sinθ cosθ</p></blockquote><img src="/blog/Game101-03Transformation/image-20220608203553268.png" class="" title="image-20220608203553268"><img src="/blog/Game101-03Transformation/image-20220608203705822.png" class="" title="image-20220608203705822"><p>二维旋转，若不考虑齐次坐标的情况下，用矩阵表示如下</p><img src="/blog/Game101-03Transformation/image-20220609212913155.png" class="" title="image-20220609212913155"><blockquote><p>我们发现旋转-θ角度其实把旋转θ角度进行了一个转置</p><p>并且从定义上来看，旋转-θ角，就是旋转θ角的逆，也就是旋转θ角的转置</p><p>从数学的角度来看，若一个矩阵的逆 等于它的转置，那么这个矩阵就被称为正交矩阵</p></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>上述的变换都可以写成x’ = ax + by      y‘ = cx + dy的形式</p><p>矩阵形式如下</p><img src="/blog/Game101-03Transformation/image-20220608204735340.png" class="" title="image-20220608204735340"><blockquote><p>如果我们可以把变换写成 一个矩阵去乘以一个输入的坐标，可以得到输出的坐标</p><p>那我们就将这种变换称为线性变换 </p><p>x‘ = M x</p><p>注意：这里需要用相同维度的矩阵去乘以该变量</p></blockquote><h3 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h3><p>当我们遇到一种特殊的变换时，就需要用到齐次坐标的概念</p><h4 id="平移变换"><a href="#平移变换" class="headerlink" title="平移变换"></a>平移变换</h4><img src="/blog/Game101-03Transformation/image-20220608205900064.png" class="" title="image-20220608205900064"><blockquote><p>当图片进行平移时，数学形式的表示如下</p><p>x’ = x + tx</p><p>y’ = y + ty</p></blockquote><p>而平移变换的矩阵形式如下</p><img src="/blog/Game101-03Transformation/image-20220608210045660.png" class="" title="image-20220608210045660"><p>说明了<strong>平移矩阵并不属于线性变换</strong>，所以引入了齐次坐标来解决这个问题</p><h4 id="齐次坐标-1"><a href="#齐次坐标-1" class="headerlink" title="齐次坐标"></a>齐次坐标</h4><p>引入齐次坐标的目的就是为了<strong>将变换都能写成矩阵乘以向量的形式</strong></p><p>将二维的点或者向量，增加一个维度</p><ul><li><p>用(x,y,1)来表示二维的点</p></li><li><p>用(x,y,0)来表示二维的向量</p></li></ul><p>通过齐次坐标将平移写成了矩阵乘以向量的形式</p><img src="/blog/Game101-03Transformation/image-20220608211035843.png" class="" title="image-20220608211035843"><blockquote><p>注意：这里为什么要将向量和点进行区别对待</p><p>因为向量具有平移不变性，将一个向量平移到另一个地方，本质上还是那个向量</p></blockquote><p>在齐次坐标下，有以下概念</p><ul><li>向量 + 向量 = 向量</li><li>点 - 点 = 向量</li><li>点 + 向量 = 点</li><li>点 + 点 = 这两个点的中点</li></ul><h4 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h4><p>对于任何的一种变换若能写成<strong>线性变换加上平移</strong>，那么我们称之为仿射变换</p><img src="/blog/Game101-03Transformation/image-20220608211919859.png" class="" title="image-20220608211919859"><p>而所有的仿射变换，都能够写成齐次坐标的形式</p><img src="/blog/Game101-03Transformation/image-20220608211949391.png" class="" title="image-20220608211949391"><blockquote><p>如果我们用齐次坐标去表示二维的仿射变换</p><p>那么<strong>它的最后一行，一定是(0 0 1)</strong></p><p>平移的坐标一定是写在<strong>最后一列的头两个数</strong></p><p>然后剩余左边的<strong>2 × 2矩阵是 原来线性变换矩阵的值</strong></p></blockquote><img src="/blog/Game101-03Transformation/image-20220608212353485.png" class="" title="image-20220608212353485"><p><strong>注意：</strong>只有用齐次坐标表示二维的仿射变换它的矩阵最后一行才是(0 0 1)</p><h3 id="其它变换"><a href="#其它变换" class="headerlink" title="其它变换"></a>其它变换</h3><h4 id="逆变换"><a href="#逆变换" class="headerlink" title="逆变换"></a>逆变换</h4><p>将一个操作的变换反过来，就被称为逆变换</p><img src="/blog/Game101-03Transformation/image-20220608212826148.png" class="" title="image-20220608212826148"><blockquote><p>逆变换在数学上所对应的<strong>乘以该变换的逆矩阵</strong></p><p><strong>一个矩阵乘以它的逆矩阵一定等于单位矩阵</strong></p></blockquote><h4 id="组合变换"><a href="#组合变换" class="headerlink" title="组合变换"></a>组合变换</h4><ul><li>复杂的变换可以通过简单的变换得到</li><li>变换过程种的先后顺序非常重要，会影响到变换结果</li></ul><p>假设，我们想要将得到下图</p><img src="/blog/Game101-03Transformation/image-20220608213248486.png" class="" title="image-20220608213248486"><p>若是先平移再进行旋转，则不能得到目标结果</p><img src="/blog/Game101-03Transformation/image-20220608213322952.png" class="" title="image-20220608213322952"><p>若是<strong>先旋转再平移</strong>，则能够得到目标结果</p><img src="/blog/Game101-03Transformation/image-20220608213355040.png" class="" title="image-20220608213355040"><blockquote><p>虽说上述两种方法做的单个事情一样，但组合后的顺序不一样，则得到的结果也不一样。</p><p>这个可以通过矩阵的乘法理解，变换就是在<strong>某个向量前乘以一个矩阵</strong>，若再变换一次，就再从前面乘以一个矩阵。</p><p>若矩阵相乘的顺序改变了，它不满足交换律，所以结果也改变了</p></blockquote><p><strong>组合矩阵的计算顺序</strong></p><p>当一个向量前面乘了多个矩阵，它会依次<strong>从右到左</strong>开始计算</p><img src="/blog/Game101-03Transformation/image-20220608214039269.png" class="" title="image-20220608214039269"><p>  <strong>变换的分解</strong></p><p>若我们不以原点进行旋转，而是以c点进行旋转，我们可以先将c点移动到原点上，再进行旋转，之后再平移回去</p><img src="/blog/Game101-03Transformation/image-20220608215600276.png" class="" title="image-20220608215600276"><img src="/blog/Game101-03Transformation/image-20220608215740179.png" class="" title="image-20220608215740179"><h3 id="3D-变换"><a href="#3D-变换" class="headerlink" title="3D 变换"></a>3D 变换</h3><p>3D变换就是在2D变化的基础上增加了一个维度，与2D变换类似</p><p>3D 点 = (x,y,z,1)</p><p>3D 向量=(x,y,z,0)</p><p>三维空间中的齐次坐标表示仿射变换</p><img src="/blog/Game101-03Transformation/image-20220608220635005.png" class="" title="image-20220608220635005"><blockquote><p>规律和二维类型</p><p>最后一行是(0 0 0 1)</p><p>最后一列的头三个数表示</p><p>左边剩下的3×3矩阵就是三维空间中的线性变换</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 图形学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> games101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归：如何用三行代码找到“最终推荐人”？</title>
      <link href="blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E9%80%92%E5%BD%92/"/>
      <url>blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="如何理解递归"><a href="#如何理解递归" class="headerlink" title="如何理解递归"></a>如何理解递归</h2><p>递归是一种应用非常广的算法。DFS深度优先搜索、前中后序二叉树遍历等都需要用到递归</p><p>举一个列子，当我们在排队时，我们并不知道自己是第几位，我们只能问前面的人，然后再加上1就好。</p><p>若前面的人也不知道自己的序号，则就只能一个一个的往前问，直到遇见排在第一个的人，然后第一个人报数为1，这样他身后的人就能依次开始报数，等到我们这里时，就知道自己是第几个了</p><blockquote><p>这是一个非常标准的递归求解问题的分解过程</p><p>去的过程叫“递”，相当于从当前位置开始有一个问题，然后不断向前传递，直到得到已知的结果位置</p><p>回来的过程叫”归”，将已知的结果通过式子不断返回，最后得到目标位置的结果</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如上述例子就能用以下递归公式表示、</span></span><br><span class="line">f(n) = f(n<span class="number">-1</span>) + <span class="number">1</span> 其中 f(<span class="number">1</span>) = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">f(n) 表示自己的位置</span></span><br><span class="line"><span class="comment">f(n-1) 表示前面对象的位置</span></span><br><span class="line"><span class="comment">f(1)=1 表示已知队伍第一个人的位置为1 </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过以上的递归公式，将其改为递归代码如下</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f(n<span class="number">-1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归满足的三个条件"><a href="#递归满足的三个条件" class="headerlink" title="递归满足的三个条件"></a>递归满足的三个条件</h2><p>若有一个问题同时满足下述<strong>三个条件</strong>，就可以用递归来解决</p><ul><li>一个问题的解 可以分为几个子问题的解</li></ul><blockquote><p>什么是子问题呢？</p><p>子问题就是数据规模更小的问题</p><p>比如前面排队的例子，我们要知道“自己的位置”，可以分解为”前面人的位置”</p></blockquote><ul><li><strong>将问题分解后，除了数据规模不同，子问题的求解思路要完全一样</strong></li></ul><blockquote><p>比如上述排队的例子，我们求解“自己的位置” 的思路，和前面那个人求解“自己的位置” 的思路要一样，都是询问前面的人</p></blockquote><ul><li><strong>存在递归终止条件</strong></li></ul><blockquote><p>把问题分解为子问题，再把子问题分解为子子问题，但不能存在无线循环，总得有个终止条件。</p><p>还是以上述排队为例，队首的第一个就必须自己是第一个人。否则递归就会出问题</p></blockquote><h3 id="如何编写递归代码"><a href="#如何编写递归代码" class="headerlink" title="如何编写递归代码"></a>如何编写递归代码</h3><p>写递归代码最关键的就是 <strong>写出递归公式，然后找到终止条件</strong></p><p>假设有n个台阶，每次你可以跨1个台阶或2个台阶，请问走这n个台阶有多少种走法</p><blockquote><p>实际上，可以根据第一步的走法 把所有走法分为两类</p><p>一类是第一步走1个台阶</p><p>另一类是第一步走2个台阶</p><p>递归公式：f(n) = f(n-1) + f(n-2)</p><p>n = 1时，表示只有一个台阶，那就只有一种走法</p><p>n = 2 时，表示有两个台阶，那就有两种走法，直接走两个台阶，和走两次一个台阶</p><p>终止条件：f(1) = 1; f(2) = 2</p></blockquote><p>所以最终递归代码如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> f(n<span class="number">-1</span>) + f(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：写递归代码的关键，就是找到如何将大问题分解为小问题的规律，并<strong>写出递归公式</strong>，然后再<strong>敲定终止条件</strong>，最后<strong>将递归公式和终止条件翻译成代码</strong></p><h2 id="递归代码要警惕堆栈溢出"><a href="#递归代码要警惕堆栈溢出" class="headerlink" title="递归代码要警惕堆栈溢出"></a>递归代码要警惕堆栈溢出</h2><p>编写递归代码时，可能会遇到堆栈溢出。这样会导致系统性的崩溃</p><p>我们知道，函数调用会使用栈来保存临时变量。<strong>每调用一个函数</strong>，<strong>都会将临时变量封装为栈帧压入栈中，等函数执行完，返回后才会出栈</strong>。而系统栈的内存一般不大，如果递归求解的数据规模很大，则有可能导致堆栈溢出的风险</p><p>那么，如何避免堆栈溢出呢？</p><p>我们可以通过代码<strong>限制递归调用的最大深度</strong>，当递归调用超过一定深度后，我们直接返回报错</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量，表示递归的深度。</span></span><br><span class="line"><span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  depth++；</span><br><span class="line">  <span class="keyword">if</span> (depth &gt; <span class="number">1000</span>) <span class="keyword">throw</span> exception;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> f(n<span class="number">-1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归代码要警惕重复计算"><a href="#递归代码要警惕重复计算" class="headerlink" title="递归代码要警惕重复计算"></a>递归代码要警惕重复计算</h2><p>除了堆栈溢出外，使用递归还可能出现重复计算的问题。比如上述的跳台阶问题</p><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E9%80%92%E5%BD%92/%E8%B7%B3%E5%8F%B0%E9%98%B6%E5%88%86%E8%A7%A3.jpg" class=""><blockquote><p>我们从图中可以看到，f(3)被计算了多次，这就是重复计算问题，为了避免重复计算，我们可以通过一个数据结构(如散列表)来保存已经求解过的f(k)</p><p>当递归调用到f(k)时，可以先看下是否已经求解过了</p><p>若已经求解过，则直接从散列表中取值返回，不需要重复计算</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>队列：队列在线程池等有限资源池中的应用</title>
      <link href="blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E9%98%9F%E5%88%97/"/>
      <url>blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="如何理解队列"><a href="#如何理解队列" class="headerlink" title="如何理解队列"></a>如何理解队列</h2><p>可以将队列想象成排队买票，先来的先买，从前面出，后来的后买，从后面进。</p><p><strong>先进先出</strong>，这就是队列的特点</p><p>队列的功能也与栈相似，最基本的操作有<strong>入列 enqueue()</strong>：将一个数据放到队列尾部；<strong>出列dequeue()</strong>：从队列头部取一个元素</p><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E9%98%9F%E5%88%97/%E9%98%9F%E5%88%97%E7%89%B9%E7%82%B9.jpg" class=""><p>所以，队列和栈一样，也是<strong>操作受限的线性表数据结构</strong>。</p><p>队列的应用也非常广泛，比如循环队列、并发队列、阻塞队列</p><h2 id="顺序队列和链式队列"><a href="#顺序队列和链式队列" class="headerlink" title="顺序队列和链式队列"></a>顺序队列和链式队列</h2><p>用数组实现的队列叫<strong>顺序队列</strong>，用链表实现的队列叫<strong>链式队列</strong></p><p>对于栈来说，顺序栈只需要一个<strong>栈顶指针</strong>。但队列则需要两个指针，一个head 指向队头，一个tail 指针指向队尾</p><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E9%98%9F%E5%88%97/%E9%98%9F%E5%88%97.jpg" class=""><p>当我们出队时，head指针就会向后移动，而当我们入队时，则是tail指针向后移动</p><blockquote><p>这里需要注意，当有一个元素出队时，不用急着将后续元素往前搬移，因为这样的事件复杂度是O(n)。</p><p>我们可以稍微优化一下，假设a，b，c 都出队了，我们不用着急将后续数据搬移，一直等到有后续元素入队，此时tail指针就会往后移动，若tail指针指向最后一个元素，就说明当前队列已经不能从后面入队了，但此时前面出队的空间还在，这时，我们才将所有数据进行搬移。</p><p>这样的话就能保证时间复杂度为O(1)，C#中的垃圾回收机制，就采用了这种思想</p></blockquote><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E9%98%9F%E5%88%97/%E4%B8%8B%E8%BD%BD.jpg" class=""><p>接下来，看看<strong>基于链表的队列实现方法</strong></p><p>基于链表的实现，我们同样需要head 指针和tail 指针。</p><p>它们分别指向链表的第一个结点和最后一个结点</p><p>入队时，tail-&gt;next = new_node，tail = tail-&gt;next;</p><p>出队时,head = head-&gt;next</p>.jpg)## 循环队列在**顺序队列**中，当tail == n时，会有数据搬移操作，这样入队性能就会受到影响> 这是因为队列中后方空间已满，而前方的空间因为元素出队而空了出来，所以就要把后方的元素往前移而假如队列是一个环，就不存在数据搬移的问题了<img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E9%98%9F%E5%88%97/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.jpg" class=""><p>当<strong>head  == tail时，循环队列为空</strong></p><p>当<strong>(tail+1)%n = head</strong> 时，<strong>循环队列已满</strong>。而当队列满时，tail所指空间没有数据</p><h2 id="队列在线程池等有限资源池中的应用"><a href="#队列在线程池等有限资源池中的应用" class="headerlink" title="队列在线程池等有限资源池中的应用"></a>队列在线程池等有限资源池中的应用</h2><p>当线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？</p><p>我们一般有两种处理策略</p><ul><li>第一种是非阻塞的处理方式，直接拒绝任务请求</li><li>另一种是阻塞的处理方式，请求排队，等到有空闲线程时，取出排队的请求处理</li></ul><p>对于顺序队列和链式队列在排队请求中的区别</p><ul><li>链式队列可以实现一个支持<strong>无线排队的无界队列</strong>，但是可能会导致过多的请求排队等待，请求处理的响应时间过长，不适合响应时间敏感的系统</li><li>顺序队列可以实现有界队列，<strong>当线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝</strong>，适合响应时间敏感的系统</li></ul><blockquote><p>所以设置一个合理的队列大小，否则队列太大，则导致需要等待的请求太多</p><p>若队列太小，则无法充分利用系统资源</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Lua热更新</title>
      <link href="blog/Lua%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
      <url>blog/Lua%E7%83%AD%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="AssetBundle"><a href="#AssetBundle" class="headerlink" title="AssetBundle"></a>AssetBundle</h2><h3 id="AB包理论基础"><a href="#AB包理论基础" class="headerlink" title="AB包理论基础"></a>AB包理论基础</h3><p>AB包是<strong>特定平台</strong>的<strong>资源压缩包</strong>，有点类似于压缩文件</p><p>资源包括：模型、贴图、预设体、音效、材质球等等</p><blockquote><p>不能打包C#代码，所以热更新用Lua制作</p></blockquote><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h4><ul><li>相对于Resources下的资源，AB包更加便于管理</li></ul><blockquote><p>Resources下的资源，在打包时，不管该资源有没有用，都会全部打包</p><p>并且打包后的资源只读，无法修改</p><p>而AB包更加灵活，<strong>存储位置</strong>和<strong>压缩方式</strong>都可以自定义，后期还可以<strong>动态更新</strong></p></blockquote><ul><li><strong>减少包体大小</strong></li></ul><blockquote><p>1、在打包过程中可以压缩资源，节约硬盘空间</p><p>2、减少初始包大小，打包时可以将其放到服务器上，出去后就只有一些默认资源</p></blockquote><ul><li><strong>热更新</strong></li></ul><blockquote><p>热更新基本规则：</p><p>客户端通过AB包的形式，自带很少的默认资源</p><p>然后来到服务端同步一些信息，获取资源服务器地址等</p><p>接着来到资源服务器下载资源对比文件</p><p>通过资源对比文件 来比较远程的AB包和本地的AB</p><p>最后再检查哪些资源需要更新</p></blockquote><hr><h3 id="AB包资源打包"><a href="#AB包资源打包" class="headerlink" title="AB包资源打包"></a>AB包资源打包</h3><h4 id="通过官方提供的Asset-Bundle-Browser打包工具"><a href="#通过官方提供的Asset-Bundle-Browser打包工具" class="headerlink" title="通过官方提供的Asset Bundle Browser打包工具"></a>通过官方提供的<strong>Asset Bundle Browser</strong>打包工具</h4><blockquote><ul><li>可以再Package Manage 中下载</li><li>也可以从外部将压缩包直接导入</li></ul><p>注意：unity在2020版本后主推<strong>Addressables</strong>工具来管理ab包</p></blockquote><ol><li>将资源与AB包进行关联(包括了预制体、材质球等)</li><li>选中资源后可以看到Inspector窗口下方出现了AssetBundle选项，点击它后可以为其创建一个包名</li><li>打开AssetBundle窗口，就会出现一个AB包，里面有我们刚才打包好的资源</li></ol><h4 id="窗口了解"><a href="#窗口了解" class="headerlink" title="窗口了解"></a>窗口了解</h4><ul><li><strong>Configure</strong>：配置页签。用于关联资源对象</li></ul><blockquote><p>在Unity面板上将资源对象与AB包进行关联</p></blockquote><ul><li><strong>Build</strong>：构建打包页签</li></ul><blockquote><p>当资源对象与AB包关联以后，Build页签中就会出现几个参数，用于最终打包的设置</p><ul><li>Build Target：构建打包的平台。每打一次包，只能指定一个平台</li><li>Output Path：目标输出路径</li><li>Clear Foloders：勾选后清空文件夹，当我们进行多次打包时，它会清空一些无用的文件夹，一般清空下勾选。但若打包资源太多，需要等待较长的时间</li><li><p>Copy to StreamingAssets：勾选后会将<strong>输出路径</strong>的资源，复制一份到StreamingAssets文件夹中，建议勾选</p></li><li><p><strong>Compression</strong>：压缩方式</p><ul><li>No Compression：不压缩，打包出去的资源大，但解压快，一般不使用</li><li>LZMA：打包出去的资源最小，但解压慢，而且当我们只想要AB包中的其中一个资源时，它会将所有资源都解压出来，比较消耗性能</li><li><strong>LZ4</strong>：可以单独解压一个资源，内存占用低，建议使用</li></ul></li></ul><p>注意：打包后要在Assets文件夹下进行刷新才会出现StreamingAssets文件夹</p><p>最终的导出路径在<strong>工程文件</strong>的<strong>AssetsBundles</strong>下</p></blockquote><ul><li><strong>Inspect</strong>：检查页签</li></ul><blockquote><p>通过检查页签，可以看到打包出去的AB包的大小，以及一些关键的信息</p></blockquote><h4 id="AB包生成文件"><a href="#AB包生成文件" class="headerlink" title="AB包生成文件"></a>AB包生成文件</h4><ul><li><strong>没有后缀名</strong>的AB包文件：这里面是用二进制表示的<strong>资源文件</strong></li><li>后缀名为<strong>manifest</strong>的文件：它是AB包的配置文件。当AB包加载时提供一些关键信息，以及<strong>依赖关系</strong></li><li>和<strong>目录名</strong>一样的主包：主包中记录了AB包的依赖关系</li></ul><h3 id="使用AB包资源文件"><a href="#使用AB包资源文件" class="headerlink" title="使用AB包资源文件"></a>使用AB包资源文件</h3><p>使用Unity提供的API加载资源文件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ABTest</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//第一步 加载AB包</span></span><br><span class="line">        AssetBundle ab = AssetBundle.LoadFromFile(Application.streamingAssetsPath + <span class="string">&quot;/&quot;</span> + <span class="string">&quot;model&quot;</span>);</span><br><span class="line">        <span class="comment">//第二步 加载AB包中的资源</span></span><br><span class="line">        <span class="comment">//它还有一个重载是不加泛型的</span></span><br><span class="line">        <span class="comment">//如果不加泛型，而资源包中又有同名不同类型的情况，则加载过程中会分不清</span></span><br><span class="line">        <span class="comment">//GameObject obj = ab.LoadAsset&lt;GameObject&gt;(&quot;Cube&quot;);   </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果不用泛型的话，可以用另一带type的重载，它返回的类型是Object，所以要用as强转为GameObject</span></span><br><span class="line">        <span class="comment">//它常用于热更新中，因为Lua中不支持泛型，所以只能用这种形式</span></span><br><span class="line">        GameObject obj2 = ab.LoadAsset(<span class="string">&quot;Cube&quot;</span>,<span class="keyword">typeof</span>(GameObject)) <span class="keyword">as</span> GameObject;</span><br><span class="line">        Instantiate(obj2);  <span class="comment">//将从AB包中加载的资源实例化到场景中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>同一个AB包不能重复加载，否则会报错。即AB包只需要加载一次，就可以加载AB包中的资源的多个资源</p></blockquote><p>使用<strong>协程异步加载</strong>AB包</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ABTest</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用协程异步加载AB包</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        StartCoroutine(LoadABRes(<span class="string">&quot;model&quot;</span>,<span class="string">&quot;Cube&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">LoadABRes</span>(<span class="params"><span class="built_in">string</span> ABName, <span class="built_in">string</span> resName</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//第一步 加载AB包</span></span><br><span class="line">        <span class="comment">//使用AB包异步加载的API</span></span><br><span class="line">        AssetBundleCreateRequest abcr = AssetBundle.LoadFromFileAsync(Application.streamingAssetsPath + <span class="string">&quot;/&quot;</span> + ABName);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> abcr;  <span class="comment">//等待AB包异步加载结束</span></span><br><span class="line">        <span class="comment">//第二部 加载AB包中的资源</span></span><br><span class="line">        <span class="comment">//使用加载资源的异步API</span></span><br><span class="line">        AssetBundleRequest abr =  abcr.assetBundle.LoadAssetAsync(resName,<span class="keyword">typeof</span>(GameObject));</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> abr;</span><br><span class="line">        Instantiate(abr.asset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>补充一个API：AssetBundle.UnloadAllAssetBundles()</p><p>如果参数为true，则会卸载所有加载的AB包，并删除由AB包创建的资源</p><p>如果参数为false，则之后卸载所有加载的AB包，并不会卸载由AB包创建的资源</p><p>所以我们一般填false</p></blockquote><h4 id="将资源和AB包进行关联"><a href="#将资源和AB包进行关联" class="headerlink" title="将资源和AB包进行关联"></a>将资源和AB包进行关联</h4><blockquote><ul><li>选择需要打包的资源对象</li><li>然后在Inspector面板中最下方，选中None，点击New，就可以创建包名，即该资源对象将被打到这个包中。后面选项是拓展名，不作更改</li><li>这样就能将资源打入到包名中</li></ul><p>注意：Unity中C#代码不能打入到AB包中，所以才需要使用Lua代码</p></blockquote><h4 id="打包AB包"><a href="#打包AB包" class="headerlink" title="打包AB包"></a>打包AB包</h4><blockquote><p>每次打包AB包时，都是指定某一个平台，当有多个平台时，需要打包多次</p></blockquote><h3 id="AB包依赖"><a href="#AB包依赖" class="headerlink" title="AB包依赖"></a>AB包依赖</h3><p><strong>什么是AB包依赖</strong></p><p>一个资源身上若用到了别的AB包中的资源，此时如果只加载自己的AB包，那么就会出现资源丢失的情况</p><p><strong>解决办法</strong></p><ul><li>将两个资源都打包到同一个AB包中</li><li>或者 将另一个AB包中的资源也加载出来</li></ul><blockquote><p>这两种方法效率太低，所以我们一般用主包获取依赖信息</p></blockquote><p><strong>利用主包获取依赖信息</strong></p><ul><li>首先 加载主包</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里写法和加载普通包一样，只不过是主包的包名</span></span><br><span class="line">AssetBundle abMain = AssetBundle.LoadFromFile(Application.streamingAssetsPath + <span class="string">&quot;/&quot;</span> + <span class="string">&quot;PC&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>然后 加载主包中的固定文件</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里是加载主包中文件的固定写法</span></span><br><span class="line">AssetBundleManifest abManifest = abMain.LoadAsset&lt;AssetBundleManifest&gt;(<span class="string">&quot;AssetBundleManifest&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>最后 从固定文件中得到依赖信息</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数填入所需资源依赖的包名</span></span><br><span class="line"><span class="comment">//得到将所需的依赖都存到数组中</span></span><br><span class="line"><span class="built_in">string</span>[] strs = abManifest.GetAllDependencies(<span class="string">&quot;model&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过for循环加载数组中的依赖资源</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; strs.Length; i++)&#123;</span><br><span class="line">    AssetBundle ab = AssetBundle.LoadFromFile(Application.streamingAssetsPath + <span class="string">&quot;/&quot;</span> + <span class="string">&quot;model&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Lua语法"><a href="#Lua语法" class="headerlink" title="Lua语法"></a>Lua语法</h2><h3 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h3><p>环境安装</p><blockquote><p>从github中下载Lua For Windows</p><p><a href="https://github.com/rjpcomputing/luaforwindows/releases">https://github.com/rjpcomputing/luaforwindows/releases</a></p><p>从中选中exe文件即可</p><p>安装时建议使用默认路径</p><p>打开cmd，输入lua，若出现版本号，则说明安装成功</p></blockquote><p>IDE的选择</p><blockquote><p>学习过程中使用Sublime Text</p><p>实际项目过程中使用VS</p></blockquote><hr><h3 id="第一个Lua程序"><a href="#第一个Lua程序" class="headerlink" title="第一个Lua程序"></a>第一个Lua程序</h3><ul><li>在Lua语法中，每条语句结尾<strong>可以省略分号</strong></li><li>Lua的打印输出语法也是<strong>print</strong></li><li>在Sublime Text中使用 <strong>Ctrl + B</strong> 运行Lua程序</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello Word&quot;</span>)</span><br><span class="line"><span class="comment">--单行注释</span></span><br><span class="line"><span class="comment">--lua中可以省略分号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">多行</span></span><br><span class="line"><span class="comment">注释</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>lua中有基本变量类型和复杂变量类型</p><p>基本数据类型有：<strong>nil，number，string，boolean</strong></p><ul><li>nil：作用类似于null</li><li>number：所有的值类型都是number</li><li>string：lua中用” “(双引号) 或者 ‘ ‘单引号表示字符串</li></ul><blockquote><p>注意：</p><p>1、lua声明变量时，会自动进行类型检测</p><p>2、同一个变量，可以初始化不同类型的值</p><p>3、在lua中使用未声明的变量，将会输出nil</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--lua中简单的变量类型</span></span><br><span class="line"><span class="comment">--nil,number,string,boolean</span></span><br><span class="line"></span><br><span class="line">a = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">print</span>(a);</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">print</span>(a);</span><br><span class="line"></span><br><span class="line">a = <span class="number">1.5</span>;</span><br><span class="line"><span class="built_in">print</span>(a);</span><br><span class="line"></span><br><span class="line">a = <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a);</span><br><span class="line"></span><br><span class="line">a = <span class="string">&#x27;1234&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a);</span><br><span class="line"><span class="comment">--通过type()函数可以得到该变量的类型</span></span><br><span class="line"><span class="comment">--而type()函数的返回值是一个string类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a));</span><br><span class="line"></span><br><span class="line"><span class="comment">--b未声明，处处nil</span></span><br><span class="line"><span class="built_in">print</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">--复杂的数据类型</span></span><br><span class="line"><span class="comment">--函数 function</span></span><br><span class="line"><span class="comment">--表 table</span></span><br><span class="line"><span class="comment">--数据结构 userdata</span></span><br><span class="line"><span class="comment">--协调程序 thread(协程)</span></span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li><p>在lua中一个汉字占3个长度，字母占1个长度</p></li><li><p>在字符串前面加<strong>#</strong>号，可以获取字符串长度</p></li><li>通过转义字符<strong>\n</strong>,可以让字符串多行打印</li><li>通过 <strong>..</strong> 可以将字符串和数值进行拼接</li><li>通过string.format(“%d”,20)替换内容</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;****************获取字符串长度***************&quot;</span>);</span><br><span class="line">str1 = <span class="string">&quot;123字符串&quot;</span>;</span><br><span class="line"><span class="built_in">print</span>(#str1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;****************打印多行字符串***************&quot;</span>);</span><br><span class="line"><span class="comment">--转移字符打印多行字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123\n123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--双括号打印多行字符串</span></span><br><span class="line">s = <span class="string">[[1</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">34</span></span><br><span class="line"><span class="string">]]</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;****************字符串拼接***************&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--1、通过 .. 拼接</span></span><br><span class="line">s1 = <span class="number">111</span>;</span><br><span class="line">s2 = <span class="string">&quot;111&quot;</span>;</span><br><span class="line"><span class="built_in">print</span>(s1 .. s2);</span><br><span class="line"></span><br><span class="line"><span class="comment">--2、通过 format()函数替换 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;我今年%d&quot;</span>,<span class="number">20</span>)); </span><br><span class="line"><span class="comment">-- &amp;d：与数字替换</span></span><br><span class="line"><span class="comment">-- &amp;a：与字母替换</span></span><br><span class="line"><span class="comment">-- &amp;s：与字符替换</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;****************字符串提供的方法***************&quot;</span>);</span><br><span class="line">str = <span class="string">&quot;abCdEF&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--小写转大写</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">upper</span>(str));</span><br><span class="line"><span class="comment">--大写转小写</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">lower</span>(str));</span><br><span class="line"><span class="comment">--反转字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">reverse</span>(str));</span><br><span class="line"><span class="comment">--这些方法不会改变原字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--字符串索引查找,返回值为起始位置 和 结束位置</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">find</span>(str,<span class="string">&quot;Cd&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">--截取字符串,该函数有重载，若只有一个参数,则截取从该位置开始的所有字符串</span></span><br><span class="line"><span class="comment">--若有2个参数，则截取该范围的字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">sub</span>(str,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">--字符串修改,此方法还会返回修改成功的次数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">gsub</span>(str,<span class="string">&quot;Cd&quot;</span>,<span class="string">&quot;**&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">--字符串转 ASCII码</span></span><br><span class="line">a = <span class="built_in">string</span>.<span class="built_in">byte</span>(<span class="string">&quot;Lua&quot;</span>,<span class="number">1</span>);<span class="comment">--将指定位置的字符转为ASCII码</span></span><br><span class="line"><span class="built_in">print</span>(a);</span><br><span class="line"><span class="comment">--ASCII码转 字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">char</span>(a));</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>Lua中的索引位置是从<strong>1</strong>开始，并且可以有<strong>多返回值</strong></p></blockquote><hr><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li>lua中不支持自增和自减，以及复合运算符。但新增了幂运算符</li><li>条件运算符中不等于用<strong>~=</strong>表示</li><li>“或，与，非” 用 and or not 表示</li><li>不支持位运算符 和 三目运算符</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;****************运算符***************&quot;</span>);</span><br><span class="line"><span class="comment">--lua中支持 + - * / % 等运算符</span></span><br><span class="line"><span class="comment">--但不支持自增、自减、以及复合运算符</span></span><br><span class="line"><span class="comment">--lua中新增了^ 幂运算</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--若字符串中是数值，则在进行运算符计算时，会将其转换为number计算</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123.4&quot;</span> + <span class="number">1</span>); <span class="comment">--结果为124.4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--幂运算</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> ^ <span class="number">2</span>); <span class="comment">--结果为4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;****************条件运算符***************&quot;</span>);</span><br><span class="line"><span class="comment">--lua只有不等于运算符较为特殊表示为 ~=</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span>~=<span class="number">1</span>);<span class="comment">--结果为true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;****************逻辑云算符***************&quot;</span>);</span><br><span class="line"><span class="comment">--在C#中&quot;与&quot;是&amp;&amp; ，&quot;或&quot;是 || ， &quot;逻辑非&quot;是 ！</span></span><br><span class="line"><span class="comment">--lua中是 and  ， or 和 not </span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">true</span> <span class="keyword">and</span> <span class="literal">false</span>);<span class="comment">--结果为false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">true</span> <span class="keyword">or</span> <span class="literal">false</span>); <span class="comment">--结果为true</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> <span class="literal">true</span>);<span class="comment">--结果为false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--lua中不支持位运算符和逻辑运算符</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="条件分支语句"><a href="#条件分支语句" class="headerlink" title="条件分支语句"></a>条件分支语句</h3><ul><li>在lua中，用<strong>then…end</strong> 代替了if语法中的代码块</li><li>可以不用小括号包裹条件</li><li>在多分支语句中elseif其中，一定不能有空格！否则会报错</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;****************条件分支语句***************&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--在lua中，if语法可以不用小括号包裹条件</span></span><br><span class="line"><span class="comment">--通过 then end ，代替中括号的代码块</span></span><br><span class="line">a = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">5</span>) <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;语句执行成功&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;****************双分支语句***************&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a &lt; <span class="number">5</span>) <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;语句没执行&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;语句执行成功&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;****************多分支语句***************&quot;</span>);</span><br><span class="line"><span class="comment">--lua中elseif一定不能有空格！否则会报错！</span></span><br><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">6</span>) <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;语句1执行&quot;</span>);</span><br><span class="line"><span class="keyword">elseif</span> (a &lt; <span class="number">6</span>) <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;语句2执行&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--lua中没有switch case语法</span></span><br></pre></td></tr></table></figure><hr><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;****************while循环***************&quot;</span>);</span><br><span class="line"><span class="comment">--lua中while循环用do...end 代替 代码块</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">10</span>) <span class="keyword">do</span></span><br><span class="line">a = a + <span class="number">1</span>;</span><br><span class="line">i = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(a); <span class="comment">--结果为20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;****************do while循环***************&quot;</span>);</span><br><span class="line"><span class="comment">--lua中do while循环与其它语言有很大的不同</span></span><br><span class="line"><span class="comment">--repeat..until 代替了do while</span></span><br><span class="line">num = <span class="number">0</span>;</span><br><span class="line"><span class="comment">--这条语句的意思是，重复执行num++,直到num &gt; 5 时退出重复执行</span></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">num = num + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">until</span> (num &gt; <span class="number">5</span>) <span class="comment">--这里是结束循环时的条件，而不进入循环时条件</span></span><br><span class="line"><span class="built_in">print</span>(num); <span class="comment">--结果为6</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;****************for循环***************&quot;</span>);</span><br><span class="line"><span class="comment">--lua中的for循环也与其它语言有些许区别</span></span><br><span class="line"><span class="comment">--语法：for i = 1, 5 do...end</span></span><br><span class="line"><span class="comment">--for循环中的条件语句也不能用小括号包裹</span></span><br><span class="line"><span class="comment">--参数1为起始值，参数2是小于等于该值时进入循环，参数3默认不填时为1 作用是自增1</span></span><br><span class="line">num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">5</span> <span class="keyword">do</span></span><br><span class="line">num = num + <span class="number">1</span>;</span><br><span class="line"><span class="comment">--这里默认会有一个i的自增1,当i小于等于5时会执行</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(num);<span class="comment">--结果为5</span></span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">num = num + <span class="number">1</span>;</span><br><span class="line"><span class="comment">--这里默认自增2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(num);<span class="comment">--结果为3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;****************函数***************&quot;</span>);</span><br><span class="line"><span class="comment">--语法：function 函数名()...end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--另一种写法： a = function()...end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;****************无参无返回值***************&quot;</span>);</span><br><span class="line"><span class="comment">--在lua中，函数是一种变量类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;函数被调用&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">f1()</span><br><span class="line"></span><br><span class="line">f2 = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;F2函数被调用&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(f2))<span class="comment">--结果为function</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;****************有参数***************&quot;</span>);</span><br><span class="line"><span class="comment">--lua中不用指定变量类型，也就是可以传递任意类型，lua会自动匹配</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f3</span><span class="params">( a )</span></span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">f3(<span class="number">1</span>)</span><br><span class="line">f3(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">f3(<span class="literal">true</span>)</span><br><span class="line"><span class="comment">--如果传入的参数和函数参数不匹配</span></span><br><span class="line"><span class="comment">--lua中不会报错，只会用nil填补，或者丢弃</span></span><br><span class="line">f3()<span class="comment">--结果为nil</span></span><br><span class="line">f3(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)<span class="comment">--结果为1,其它参数会被自动丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;****************有返回值**************&quot;</span>);</span><br><span class="line"><span class="comment">--lua中支持多返回值的操作，可以用对应的变量接收返回值</span></span><br><span class="line"><span class="comment">--若接收的变量与返回值个数不一致，则会补空或丢弃</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f4</span><span class="params">(a)</span></span></span><br><span class="line"><span class="keyword">return</span> a, <span class="string">&quot;123&quot;</span> , <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">temp1, temp2, temp3 = f4(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(temp1)</span><br><span class="line"><span class="built_in">print</span>(temp2)</span><br><span class="line"><span class="built_in">print</span>(temp3)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;****************函数重载**************&quot;</span>);</span><br><span class="line"><span class="comment">--lua中函数不支持重载</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;****************变长参数**************&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f7</span><span class="params">( ... )</span></span></span><br><span class="line"><span class="comment">-- 变长参数是用一个表存起来</span></span><br><span class="line"><span class="built_in">arg</span> = &#123;...&#125;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>,#<span class="built_in">arg</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">arg</span>[i])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">f7(<span class="number">1</span>,<span class="string">&quot;12&quot;</span>,<span class="literal">true</span>,<span class="literal">nil</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;****************函数嵌套**************&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f8</span><span class="params">( )</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">f9 = f8()</span><br><span class="line">f9()</span><br><span class="line"><span class="comment">--在lua中，闭包的体现是什么？</span></span><br><span class="line"><span class="comment">--在函数内部返回一个函数，改变了外部函数的生命周期</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f9</span><span class="params">( x )</span></span></span><br><span class="line"><span class="comment">--这里传入的x是临时变量</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(y)</span></span></span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">f10 = f9(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(f10(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><hr><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;****************table***************&quot;</span>);</span><br><span class="line"><span class="comment">--lua中并没有数组、字典、类等数据类型，这些本质上都是table的特征实现</span></span><br><span class="line">a = &#123;&#125; <span class="comment">--空表：</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;****************数组***************&quot;</span>);</span><br><span class="line"><span class="comment">--lua中的数组可以存放不同类型</span></span><br><span class="line">a = &#123;<span class="number">1</span>,<span class="string">&quot;12&quot;</span>,<span class="literal">true</span>,<span class="literal">nil</span>&#125; <span class="comment">--数组</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>]) <span class="comment">--结果为0,lua的索引从1开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--#是lua获取长度的关键字</span></span><br><span class="line"><span class="comment">--lua中遇见nil就会返回，即如果nil在第2位，数组长度为1，遇见nil返回</span></span><br><span class="line"><span class="built_in">print</span>(#a)<span class="comment">--长度为3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;****************数组遍历***************&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, #a <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(a[i]) <span class="comment">--结果为1，12，true</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;****************二维数组***************&quot;</span>);</span><br><span class="line">a = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;&#125;</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>][<span class="number">1</span>])<span class="comment">--结果为1</span></span><br></pre></td></tr></table></figure><h4 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h4><p>由于#得到的长度并不准确，所以一般不用#来遍历表。</p><p>一般用迭代器遍历来遍历表</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*******迭代器遍历*****&quot;</span>)</span><br><span class="line"><span class="comment">--迭代器遍历是解决#的问题</span></span><br><span class="line"></span><br><span class="line">a = &#123;[<span class="number">0</span>] = <span class="number">1</span>, <span class="number">2</span>, [<span class="number">-1</span>] = <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*******ipairs迭代器遍历*****&quot;</span>)</span><br><span class="line"><span class="comment">--ipairs</span></span><br><span class="line"><span class="comment">--特点：还是从1开始遍历，下标小于等于0的值，会被丢弃。</span></span><br><span class="line"><span class="comment">--并且只能得到连续索引的键。如下标4不存在，则得不到自定义的5</span></span><br><span class="line"><span class="keyword">for</span> i,k <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ipairs遍历键值&quot;</span>..i..<span class="string">&quot;_&quot;</span>..k)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--结果 i下标1 k的值为2，i下标2 k的值为4，i下标3 k的值为5，</span></span><br><span class="line"><span class="comment">--其中自定义下标0和-1的值被丢弃了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*******pairs迭代器遍历*****&quot;</span>)</span><br><span class="line"><span class="comment">--pairs</span></span><br><span class="line"><span class="comment">--特点：能够找到所有的键，通过键可以得到所有的值</span></span><br><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;pairs遍历键值&quot;</span>..i..<span class="string">&quot;_&quot;</span>..v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--结果为pairs遍历键值1_2</span></span><br><span class="line"><span class="comment">--pairs遍历键值2_4</span></span><br><span class="line"><span class="comment">--pairs遍历键值3_5</span></span><br><span class="line"><span class="comment">--pairs遍历键值0_1</span></span><br><span class="line"><span class="comment">--pairs遍历键值-1_3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="表实现字典"><a href="#表实现字典" class="headerlink" title="表实现字典"></a>表实现字典</h4><p>在lua中，以中括号的字符串内容构成键，等号右边构成值</p><hr><h2 id="xLua热更新解决方案"><a href="#xLua热更新解决方案" class="headerlink" title="xLua热更新解决方案"></a>xLua热更新解决方案</h2><p><strong>热更新解决方案的本质</strong></p><p>是<strong>为Unity提高Lua编程能力，让C#和Lua可以相互调用访问</strong></p><ul><li>xLua的下载</li></ul><blockquote><p>打开github，搜索xLua即可找到腾讯提供的xLua，我们点击 Code/Download ZIP下载到本地即可</p><p>我们将下载的xLua压缩包解压后，会发现其实它的本质上是一个Unity工程文件</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity入门基础</title>
      <link href="blog/Unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/"/>
      <url>blog/Unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-Unity运行机制"><a href="#1-Unity运行机制" class="headerlink" title="1. Unity运行机制"></a>1. Unity运行机制</h2><h3 id="1-1-生命周期"><a href="#1-1-生命周期" class="headerlink" title="1.1 生命周期"></a>1.1 生命周期</h3><p> 生命周期的<strong>概念</strong></p><p>所有继承MonoBehavior的脚本 最终目的都是为了挂载到游戏对象上。</p><p>而C#<strong>脚本</strong>在<strong>挂载</strong>到<strong>游戏对象</strong>上时，就会在整个生命周期中通过<strong>反射</strong>自动<strong>调用</strong>的一些<strong>特殊函数</strong></p><p>生命周期的<strong>种类</strong></p><img src="/blog/Unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-16457084803721.png" class="" title="生命周期"><h3 id="1-2-特性"><a href="#1-2-特性" class="headerlink" title="1.2 特性"></a>1.2 特性</h3><p>在C#脚本中，一般只有<strong>公有</strong>的成员变量才能显示在<strong>Inspector</strong>窗口中</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> a;</span><br><span class="line"><span class="keyword">protected</span> <span class="built_in">int</span> b;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> c;</span><br></pre></td></tr></table></figure><img src="/blog/Unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220224212310086-16457089925892.png" class="" title="image-20220224212310086"><h4 id="1-强制序列化字段特性"><a href="#1-强制序列化字段特性" class="headerlink" title="1.强制序列化字段特性"></a>1.强制序列化字段特性</h4><p>但是我们可以使用<strong>[Serializefield]</strong>特性，让<strong>私有</strong>和<strong>保护</strong>成员变量显示在Inspector窗口中,</p><p>还能使用<strong>[System.Serializefield]</strong>特性，使得<strong>自定义类型</strong>显示在窗口</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> B;</span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="keyword">protected</span> <span class="built_in">int</span> A;</span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> C;</span><br></pre></td></tr></table></figure><img src="/blog/Unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220224212725928-16457092469983.png" class="" title="image-20220224212725928"><h4 id="2-隐藏特性"><a href="#2-隐藏特性" class="headerlink" title="2.隐藏特性"></a>2.隐藏特性</h4><p>也可以使用<strong>[HideInInspector]</strong>特性，<strong>隐藏</strong>不需要的成员变量</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HideInInspector</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> B;</span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="keyword">protected</span> <span class="built_in">int</span> A;</span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> C;</span><br></pre></td></tr></table></figure><img src="/blog/Unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220224213130673-16457094917834.png" class="" title="image-20220224213130673"><h4 id="3-辅助特性"><a href="#3-辅助特性" class="headerlink" title="3.辅助特性"></a>3.辅助特性</h4><ul><li><strong>分组说明</strong>特性 <strong>Header</strong>：为成员分组</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Header(<span class="meta-string">&quot;苹果&quot;</span>)</span>]</span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">int</span> B;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Header(<span class="meta-string">&quot;香蕉&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="keyword">protected</span> <span class="built_in">int</span> A;</span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> C;</span><br></pre></td></tr></table></figure><img src="/blog/Unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220224214205233.png" class="" title="image-20220224214205233"><ul><li><strong>悬停注释 </strong>  Tooltip：为变量添加说明</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Tooltip(<span class="meta-string">&quot;苹果&quot;</span>)</span>]</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">int</span> B;</span><br><span class="line">   </span><br><span class="line">   [<span class="meta">Header(<span class="meta-string">&quot;香蕉&quot;</span>)</span>]</span><br><span class="line">   [<span class="meta">SerializeField</span>]</span><br><span class="line">   <span class="keyword">protected</span> <span class="built_in">int</span> A;</span><br><span class="line"></span><br><span class="line">   [<span class="meta">SerializeField</span>]</span><br><span class="line">   <span class="keyword">private</span> <span class="built_in">int</span> C;</span><br></pre></td></tr></table></figure><img src="/blog/Unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220224214551250.png" class="" title="image-20220224214551250"><ul><li>间隔特性 Space():让两个字段出现间隔</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Tooltip(<span class="meta-string">&quot;苹果&quot;</span>)</span>]</span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">int</span> B;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Header(<span class="meta-string">&quot;香蕉&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="keyword">protected</span> <span class="built_in">int</span> A;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Space()</span>]</span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> C;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/blog/Unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220224214819807.png" class="" title="image-20220224214819807"><ul><li>修饰数值的滑条范围 <strong>Range</strong></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Range(0,10)</span>]</span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> C;</span><br></pre></td></tr></table></figure><img src="/blog/Unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220224215033513.png" class="" title="image-20220224215033513"><ul><li>滚动条显示字符串 TextArea(3,4): 默认超过3行显示滚动条</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TextArea(3,4)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> A;</span><br></pre></td></tr></table></figure><img src="/blog/Unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220224215622401.png" class="" title="image-20220224215622401"><ul><li>为变量添加快捷方法 ContextMenuItem</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数1 显示按钮名</span></span><br><span class="line"><span class="comment">//参数2 方法名 不能有参数</span></span><br><span class="line">[<span class="meta">ContextMenuItem(<span class="meta-string">&quot;重置钱&quot;</span>,<span class="meta-string">&quot;Test&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> money;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    money = <span class="number">99</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/Unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220224220733718.png" class="" title="image-20220224220733718"><h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h4><ol><li>Inspector窗口中的变量关联的就是对象的成员变量，运行时改变他们就是改变成员变量</li><li>拖拽到游戏对象后，再修改脚本中的变量，不会改变Inspector窗口的值<ol><li>通过重新添加脚本</li><li>手动修改窗口的值与脚本中变量值保持一致</li></ol></li><li>运行中修改窗口中的值，它并不会保存</li></ol><h3 id="1-3-MonoBehavior中的重要内容"><a href="#1-3-MonoBehavior中的重要内容" class="headerlink" title="1.3 MonoBehavior中的重要内容"></a>1.3 MonoBehavior中的重要内容</h3><h4 id="1-3-1-Mono的重要成员"><a href="#1-3-1-Mono的重要成员" class="headerlink" title="1.3.1 Mono的重要成员"></a>1.3.1 Mono的重要成员</h4><ul><li>获取依附的GameObject</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取依附的游戏对象</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Debug.Log(<span class="keyword">this</span>.gameObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/Unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220224222316952.png" class="" title="image-20220224222316952"><ul><li>获取依附的Gameobject的<strong>位置信息</strong></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">       <span class="comment">//获取脚本依附游戏对象的位置信息</span></span><br><span class="line">       Debug.Log(<span class="keyword">this</span>.transform.position); <span class="comment">//位置</span></span><br><span class="line">       Debug.Log(<span class="keyword">this</span>.transform.eulerAngles);  <span class="comment">//角度</span></span><br><span class="line">       Debug.Log(<span class="keyword">this</span>.transform.lossyScale);   <span class="comment">//缩放大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">       Debug.Log(<span class="keyword">this</span>.gameObject.transform.position); <span class="comment">//位置</span></span><br><span class="line">       Debug.Log(<span class="keyword">this</span>.gameObject.transform.eulerAngles);  <span class="comment">//角度</span></span><br><span class="line">       Debug.Log(<span class="keyword">this</span>.gameObject.transform.lossyScale);   <span class="comment">//缩放大小</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/blog/Unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220224223121585.png" class="" title="image-20220224223121585"><ul><li>获取脚本依附游戏对象是否<strong>激活</strong></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取脚本是否激活</span></span><br><span class="line"><span class="keyword">this</span>.enabled = <span class="literal">false</span>;   <span class="comment">//失活</span></span><br></pre></td></tr></table></figure><img src="/blog/Unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220224223542431.png" class="" title="image-20220224223542431"><ul><li>通过脚本获取其他游戏对象的信息<ol><li>其他游戏对象必须挂载有<strong>相同脚本</strong></li><li>申明一个与<strong>类名相同</strong>的成员变量</li><li><strong>互相拖拽</strong>游戏对象到该成员变量中让二者形成<strong>关联</strong></li><li>最后即可使用该成员变量获取其他游戏对象信息</li></ol></li></ul><h4 id="1-3-2-Mono的重要方法"><a href="#1-3-2-Mono的重要方法" class="headerlink" title="1.3.2 Mono的重要方法"></a>1.3.2 Mono的重要方法</h4><p><strong>当前</strong>脚本如何得到依附对象上挂载的<strong>其他</strong>脚本</p><ol><li><p>得到自己挂载的单个脚本</p><p>根据<strong>泛型</strong>获取</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前对象的其他脚本</span></span><br><span class="line"><span class="comment">//通过泛型获取</span></span><br><span class="line">Test t=<span class="keyword">this</span>.GetComponent&lt;Test&gt;();   </span><br><span class="line">Debug.Log(t);</span><br></pre></td></tr></table></figure><img src="/blog/Unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220228152032950.png" class="" title="image-20220228152032950"></li></ol><p>2.得到<strong>子对象</strong>挂载的脚本(它默认也会找自己身上是否挂载脚本)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取子对象脚本</span></span><br><span class="line">t=<span class="keyword">this</span>.GetComponentInChildren&lt;Test&gt;();</span><br><span class="line">Debug.Log(t);</span><br></pre></td></tr></table></figure><hr><h2 id="2-Unity-重要组件和API"><a href="#2-Unity-重要组件和API" class="headerlink" title="2. Unity 重要组件和API"></a>2. Unity 重要组件和API</h2><h3 id="2-1-GameObject"><a href="#2-1-GameObject" class="headerlink" title="2.1 GameObject"></a>2.1 GameObject</h3><h4 id="2-1-1GameObject中的成员变量"><a href="#2-1-1GameObject中的成员变量" class="headerlink" title="2.1.1GameObject中的成员变量"></a>2.1.1GameObject中的成员变量</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//名字</span></span><br><span class="line">print(<span class="keyword">this</span>.gameObject.name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//改名</span></span><br><span class="line"><span class="keyword">this</span>.gameObject.name = <span class="string">&quot;正方体&quot;</span>;</span><br><span class="line">print(<span class="keyword">this</span>.gameObject.name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否激活</span></span><br><span class="line">print(<span class="keyword">this</span>.gameObject.activeSelf);</span><br><span class="line"></span><br><span class="line"><span class="comment">//层级</span></span><br><span class="line">print(<span class="keyword">this</span>.gameObject.layer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//标签</span></span><br><span class="line">print(<span class="keyword">this</span>.gameObject.tag);</span><br><span class="line"></span><br><span class="line"><span class="comment">//transform</span></span><br><span class="line">print(<span class="keyword">this</span>.gameObject.transform.position);</span><br><span class="line">print(<span class="keyword">this</span>.gameObject.transform.eulerAngles);</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/blog/Unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220228155747064.png" class="" title="image-20220228155747064"><h4 id="2-1-2-GameObject中的静态方法"><a href="#2-1-2-GameObject中的静态方法" class="headerlink" title="2.1.2 GameObject中的静态方法"></a>2.1.2 GameObject中的静态方法</h4><ul><li>创建自带几何体</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建自带的集合体</span></span><br><span class="line"><span class="comment">//只要得到了一个GameObject对象,就可以通过obj.GetComponent来得取身上的任何脚本信息</span></span><br><span class="line">GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube);</span><br><span class="line">obj.name = <span class="string">&quot;Unity创建的几何体&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li><p>查找对象相关知识</p><ol><li>通过tag查找单个对象(<strong>无法找到失活对象</strong>)</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过tag查找对象</span></span><br><span class="line">GameObject obj2 = GameObject.FindGameObjectWithTag(<span class="string">&quot;Player&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (obj2 != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">  print(obj2.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  print(<span class="string">&quot;没有找到相应的对象&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>注意：当多个对象的tag相同时，无法进行精确查找</p><p>​    2.通过tag查找多个对象</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过tag查找多个对象</span></span><br><span class="line">GameObject [ ] objs = GameObject.FindGameObjectsWithTag(<span class="string">&quot;Player&quot;</span>);</span><br><span class="line">print(<span class="string">&quot;找到tag为Player对象的个数&quot;</span> + objs.Length);</span><br></pre></td></tr></table></figure><ul><li>实例化对象(克隆对象)的方法</li></ul><p>根据一个GameObject对象或者预设体 动态创建出相同的对象</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> GameObject obj;<span class="comment">//先定义obj对象</span></span><br><span class="line"></span><br><span class="line">GameObject myobj= GameObject.Instantiate(obj);</span><br></pre></td></tr></table></figure><ul><li>删除对象</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GameObject.Destroy(obj);</span><br><span class="line"></span><br><span class="line">GameObject.Destroy(obj，<span class="number">3</span>);<span class="comment">//延迟3秒删除</span></span><br><span class="line"></span><br><span class="line">GameObject.Destroy(<span class="keyword">this</span>);<span class="comment">//还可以删除指定的脚本对象</span></span><br></pre></td></tr></table></figure><p>注意：Destory方法 不会马上移除对象，一般情况下它会在下一帧把这个对象移除，降低卡顿的几率</p><ul><li>过场景不移除</li></ul><p>默认情况 在切换场景时 场景中对象都会被自动删除掉</p><p>可以通过下面代码 让依附的GameObject对象不被移除</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GameObject.DontDestroyLoad(<span class="keyword">this</span>.Object);</span><br></pre></td></tr></table></figure><h4 id="2-1-3-GameObject中的成员方法"><a href="#2-1-3-GameObject中的成员方法" class="headerlink" title="2.1.3 GameObject中的成员方法"></a>2.1.3 GameObject中的成员方法</h4><ul><li>创建空物体</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GameObject obj = <span class="keyword">new</span> GameObject(<span class="string">&quot;创建空物体并添加脚本&quot;</span>,<span class="keyword">typeof</span>(clong)); </span><br></pre></td></tr></table></figure><ul><li>为指定对象添加脚本</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">est test= obj.AddComponent&lt;Test&gt;();</span><br></pre></td></tr></table></figure><ul><li>标签比较</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.gameObject.CompareTag(<span class="string">&quot;Player&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">print(<span class="string">&quot;对象标签 是 Player&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">print(<span class="string">&quot;对象标签 不是 Player&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>设置激活失活</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.SetActive(flase);<span class="comment">//flase失活true 激活</span></span><br></pre></td></tr></table></figure><h3 id="2-2-Time相关"><a href="#2-2-Time相关" class="headerlink" title="2.2 Time相关"></a>2.2 Time相关</h3><p>主要用于 游戏中参与<strong>位移</strong>，<strong>记时</strong>，<strong>时间暂停</strong>等</p><p><strong>时间缩放比例</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Time.timeScale=<span class="number">0</span>;<span class="comment">//时间停止</span></span><br><span class="line"></span><br><span class="line">Time.timeScale=<span class="number">1</span>;<span class="comment">//回复正常,默认时间</span></span><br><span class="line"></span><br><span class="line">Time.timeScale=<span class="number">2</span>;<span class="comment">//2倍数</span></span><br></pre></td></tr></table></figure><p><strong>帧间隔时间</strong>：最近的一帧 用了多长时间(秒)</p><ul><li>主要用来计算<strong>位移</strong></li><li>路程=时间*速度</li><li>如果希望 游戏有<strong>倍速</strong>或者<strong>暂停</strong>功能，就使用 <strong>deltaTime</strong></li><li>如果希望 游戏不受暂停影响 就使用<strong>unscaledDeltaTime</strong></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(Time.deltaTime);<span class="comment">//受到scale影响</span></span><br><span class="line"></span><br><span class="line">print(Time.unscaledDeltaTime)<span class="comment">//不受scale影响</span></span><br></pre></td></tr></table></figure><p><strong>游戏开始到现在的时间</strong></p><ul><li>主要用于单机游戏的 <strong>计时</strong></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(Time.time);<span class="comment">//受到scale影响</span></span><br><span class="line"></span><br><span class="line">print(Time.unscaledTime);<span class="comment">//不受scale影响</span></span><br></pre></td></tr></table></figure><p><strong>物理帧间隔时间</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FixedUpdate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    print(Time.fixedDeltaTime);<span class="comment">//受到scale影响</span></span><br><span class="line">    </span><br><span class="line">    print(Time.fixedUnscaledDeltaTime);<span class="comment">//不受scale影响</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>帧数</strong></p><ul><li>游戏在运行过程中跑的循环数</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(Time.frameCout);</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：常用Time相关内容</p><ol><li>帧间隔时间，计算位移相关内容</li><li>时间缩放比例，用来暂停或者倍速</li><li>帧数(帧同步)</li></ol><h3 id="2-3-Transform"><a href="#2-3-Transform" class="headerlink" title="2.3 Transform"></a>2.3 Transform</h3><p>游戏对象的<strong>位移、旋转、缩放、父子关系、坐标转换</strong>等操作都是由它来处理</p><h4 id="2-3-1-Vector3的基础知识"><a href="#2-3-1-Vector3的基础知识" class="headerlink" title="2.3.1 Vector3的基础知识"></a>2.3.1 <strong>Vector3</strong>的基础知识</h4><p>主要用来表示三维坐标系中的 <strong>一个点</strong> 或者<strong>一个向量</strong></p><ul><li>Vector3的常用属性</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//申明</span></span><br><span class="line">Vector3 v = <span class="keyword">new</span> Vector3(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//常用属性</span></span><br><span class="line">print(Vector3.zero);<span class="comment">//0,0,0</span></span><br><span class="line">print(Vector3.right);<span class="comment">//1,0,0</span></span><br><span class="line">print(Vector3.forward);<span class="comment">//0,0,1</span></span><br><span class="line">print(Vector3,up);<span class="comment">//0,1,0</span></span><br></pre></td></tr></table></figure><ul><li>Vector3的常用方法，计算两点之间的距离</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector3.Distance(v1.v2)</span><br></pre></td></tr></table></figure><h4 id="2-3-2-位置"><a href="#2-3-2-位置" class="headerlink" title="2.3.2 位置"></a>2.3.2 <strong>位置</strong></h4><ul><li>相对世界坐标位置</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="keyword">this</span>.transform.position);<span class="comment">//获取相对世界坐标位置</span></span><br></pre></td></tr></table></figure><ul><li>相对本地坐标位置(父对象)</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="keyword">this</span>.transform.localPosition);</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ol><li>通过<strong>position</strong>得到的位置是<strong>相对于世界坐标系</strong>的 原点位置</li><li>通过<strong>localPosition</strong>得到的位置是相对于<strong>父对象</strong>的 位置</li><li>而<strong>面板上显示的位置</strong>是<strong>相对于父对象的位置</strong></li><li>只有该对象<strong>没有父对象</strong>或者<strong>父对象的坐标在原点</strong>时，得到的位置才与面板保持一致</li></ol><p><strong>赋值</strong></p><p>由于<strong>transform</strong>是<strong>Vector3</strong> 数据类型的</p><p>所以只能通过Vector3类型的变量进行赋值</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果只要想更改一个坐标，而保持其余坐标一致</span></span><br><span class="line"><span class="keyword">this</span>.transform.position = <span class="keyword">new</span> Vector3(<span class="number">20</span>,<span class="keyword">this</span>.transform.position.y,<span class="keyword">this</span>.transform.position.z)</span><br></pre></td></tr></table></figure><p><strong>对象当前朝向</strong></p><p>世界坐标系中，Z轴为前方，X轴为右方，Y轴为上方。可以用右手来判断</p><p>而当对象进行<strong>旋转</strong>时，对象的朝向将<strong>不再</strong>与世界坐标保持一致</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(transform.position.forward);<span class="comment">//对象当前的面朝向，与对象的旋转有关</span></span><br></pre></td></tr></table></figure><h4 id="2-3-3-位移"><a href="#2-3-3-位移" class="headerlink" title="2.3.3 位移"></a>2.3.3 位移</h4><p>坐标系下的位移计算公式：路程=方向<em> 速度 </em> 时间</p><ul><li>通过公式实现位移</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//朝向自己的前方移动,该方法会随着自身的旋转而变换位置</span></span><br><span class="line"><span class="keyword">this</span>.transform.position+=<span class="keyword">this</span>.transform.forward*<span class="number">1</span>*Time.deltaTime;    </span><br><span class="line"></span><br><span class="line"><span class="comment">//朝向世界坐标的前方移动，不会变换位置</span></span><br><span class="line"><span class="keyword">this</span>.transform.position += Vector3.forward*<span class="number">1</span>*Time.deltaTime;</span><br></pre></td></tr></table></figure><p><strong>利用API实现位移</strong>（主要使用方式）</p><p><strong>Translate</strong>(参数一：表示位移多少,参数二：表示 相对坐标系 默认是相对自己的坐标系)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//朝着世界坐标向前方移动 </span></span><br><span class="line"><span class="keyword">this</span>.transform.Translate(Vector3.forward*<span class="number">1</span>*Time.deltaTime,Space.World);</span><br><span class="line"></span><br><span class="line"><span class="comment">//朝着对象本身的前方移动</span></span><br><span class="line"> <span class="keyword">this</span>.transform.Translate(<span class="keyword">this</span>.transform.forward*<span class="number">1</span>*Time.deltaTime,Space.Self);</span><br></pre></td></tr></table></figure><h4 id="2-3-4-角度和旋转"><a href="#2-3-4-角度和旋转" class="headerlink" title="2.3.4 角度和旋转"></a>2.3.4 角度和旋转</h4><p>相对世界坐标角度</p><ul><li><p>由于position返回的对象是四元数结构类型</p></li><li><p>所以此处调用的属性是<strong>eulerAngles</strong>(欧拉角)，</p></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相对世界坐标角度</span></span><br><span class="line">print(<span class="keyword">this</span>.transform.eulerAngles);</span><br></pre></td></tr></table></figure><p>相对父对象角度</p><ul><li>与位置类似，面板上显示的角度是本地坐标角度，当该对象有父对象时，调用localEulerAngles属性才能与面板上显示角度保持一致</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相对父对象坐标角度</span></span><br><span class="line">print(<span class="keyword">this</span>.transform.localEulerAngles);</span><br></pre></td></tr></table></figure><p>注意：</p><p>角度与位置一样，不能单独改变一个轴向的属性，需要用Vector3一起设置</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.transform.eulerAngles = <span class="keyword">new</span> Vector3</span><br><span class="line">    (<span class="number">10</span>, <span class="keyword">this</span>.transform.eulerAngles.y, <span class="keyword">this</span>.transform.eulerAngles.z);</span><br></pre></td></tr></table></figure><p><strong>旋转相关</strong></p><p><strong>自转</strong>：使用Rotate( )</p><p>每个轴 具体转多少度</p><ul><li>参数一： 旋转角度</li><li>参数二： 是坐标轴  默认为当前对象的轴向。可以用 Space.World 更改为世界坐标</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相对于世界坐标轴的y轴进行自传</span></span><br><span class="line"><span class="keyword">this</span>.transform.Rotate(<span class="keyword">new</span> Vector3(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>)*Time.deltaTime, Space.World);</span><br></pre></td></tr></table></figure><p>相对于某个轴 转多少度</p><ul><li>参数一：相对于哪个轴进行转动</li><li>参数二：转动的 角度多少</li><li>参数三：是坐标轴  默认为当前对象的轴向</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.transform.Rotate(Vector3.right,<span class="number">10</span>*Time.deltaTime, Space.World);</span><br></pre></td></tr></table></figure><p>绕着一个点进行<strong>公转</strong>：RotateAround( )</p><p>参数一：公转圆心所在<strong>位置</strong></p><p>参数二：公转轴向</p><p>参数三：公转度数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绕着Z轴进行公转</span></span><br><span class="line"><span class="keyword">this</span>.transform.RotateAround(Vector3.zero,Vector3.up,<span class="number">10</span>*Time.deltaTime);</span><br></pre></td></tr></table></figure><h4 id="2-3-5-缩放和看向"><a href="#2-3-5-缩放和看向" class="headerlink" title="2.3.5 缩放和看向"></a>2.3.5 缩放和看向</h4><p>相对世界坐标缩放</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="keyword">this</span>.transform.lossyScale);</span><br></pre></td></tr></table></figure><p>相对本地坐标系(父对象)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="keyword">this</span>.transform.localScale);</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>缩放同样不能该xyz 只能用Vector3()一起改</li><li>不能更改世界坐标的缩放大小，<strong>只能修改本地坐标缩放</strong></li><li>Unity没有提供缩放对应的API</li></ul><p>对象在本地坐标下的<strong>持续缩放</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.transform.localScale += Vector3.one*Time.deltaTime;</span><br></pre></td></tr></table></figure><p><strong>看向</strong></p><p>可以让一个对象的面朝向 始终看向一个点或者另一个对象</p><p>使用LookAt()</p><p>可以传入一个点</p><p>或者一个对象的Transform信息</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、创建一个Transform的属性</span></span><br><span class="line"><span class="keyword">public</span> Transform lookAtObj;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、在Update中调用LookAt方法</span></span><br><span class="line"><span class="keyword">this</span>.transform.LookAt(lookAtObj);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、最后在Unity中拖动目标对象到脚本的lookAtObj属性中</span></span><br></pre></td></tr></table></figure><p><strong>作用</strong>：</p><ul><li>可以实现摄像机的视角跟随</li><li>以及简单AI的目标瞄向</li></ul><h4 id="2-3-6-父子关系"><a href="#2-3-6-父子关系" class="headerlink" title="2.3.6 父子关系"></a>2.3.6 父子关系</h4><p>transform面板显示的是<strong>当前对象</strong>的位置信息</p><p>当<strong>没有父子关系</strong>时，当前对象的位置就是在<strong>世界坐标系</strong>下</p><p>而在设置父子关系之后，transform面板显示的就是<strong>本地坐标系</strong></p><p>所以transform面板上的数据会从<strong>世界坐标变成本地坐标</strong></p><p>取消父子关系后，就会<strong>重新变回世界坐标</strong></p><p><strong>获取和设置父对象</strong></p><ul><li>获取父对象</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="keyword">this</span>.transform.parent.name);</span><br></pre></td></tr></table></figure><ul><li>取消父对象</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.transform.parent = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><ul><li>设置新的父对象</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、设置GameObject 属性</span></span><br><span class="line"><span class="keyword">public</span> GameObject obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、用obj的transform属性做初始化操作</span></span><br><span class="line"><span class="keyword">this</span>.transform.parent=obj.transform;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、将父对象拖拽到面板上的obj对象中</span></span><br></pre></td></tr></table></figure><p>利用API设置父子关系</p><p><strong>SetParent()</strong></p><p>参数一：新父对象的位置</p><p>参数二：是否保留世界坐标的 位置信息。</p><ul><li>true 默认保留，设置父子关系时 用世界坐标系 和 父对象 进行计算 得到本地坐标系的信息</li><li>false 不会保留 设置父子关系时 会直接把世界坐标系下的 transform 赋值到 本地坐标中</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取消父对象</span></span><br><span class="line"><span class="keyword">this</span>.transform.SetParent(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置新的父对象</span></span><br><span class="line"><span class="keyword">this</span>.transform.SetParent(obj.transform,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p><strong>取消子对象</strong></p><p>仅能取消自己的子对象，不能取消子对象的子对象</p><p>DetachChildren()</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.transform.DetachChildren();</span><br></pre></td></tr></table></figure><p><strong>获取子对象</strong></p><ul><li>按照名字查找子对象，但并不能查找”孙子”</li></ul><p>Find方法能找到 失活对象！</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Find方法能找到 失活对象！ 而GameObject相关的 查找 找不到失活对象</span></span><br><span class="line">print(<span class="keyword">this</span>.transform.Find(<span class="string">&quot;Cube(1)&quot;</span>).name);</span><br></pre></td></tr></table></figure><ul><li>遍历子对象</li></ul><p>失活的子对象也算数量</p><p>”孙子“不会算数量</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统计子对象的总数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.transform.childCount; i++)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//根据编号获取子对象的 transform信息</span></span><br><span class="line">  print(<span class="keyword">this</span>.transform.GetChild(i).name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>操作子对象</strong></p><ul><li>判断父对象是谁</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断该对象是否为自己的父对象</span></span><br><span class="line"><span class="keyword">public</span> Transform son;</span><br><span class="line">son.IsChildOf(<span class="keyword">this</span>.transform);</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后将需要判断的对象拖到脚本的son属性中</span></span><br></pre></td></tr></table></figure><ul><li>得到子对象的编号</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编号从0开始</span></span><br><span class="line">print(son.GetSiblingIndex());</span><br><span class="line"></span><br><span class="line"><span class="comment">//将自己的编号设置为1，如果超出范围，将会设置到</span></span><br><span class="line">son.SetSibilingIndex(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要得到哪个子对象编号，就将该对象拖入到son属性中</span></span><br></pre></td></tr></table></figure><h4 id="2-3-7-坐标转换"><a href="#2-3-7-坐标转换" class="headerlink" title="2.3.7 坐标转换"></a>2.3.7 坐标转换</h4><p>世界坐标转本地坐标</p><p>概念：</p><p>表明该点在世界坐标上，但在本地坐标系表示出来</p><p>API：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将点(0,0,1)转换,受到缩放影响</span></span><br><span class="line">print(<span class="string">&quot;转换后的点&quot;</span>+<span class="keyword">this</span>.transform.InverseTransformPoint(Vector.forward));</span><br><span class="line"></span><br><span class="line"><span class="comment">//将方向转换,受到缩放影响</span></span><br><span class="line">print(<span class="string">&quot;转换后的点&quot;</span>+<span class="keyword">this</span>.transform.InverseTransformDirection(Vector.forward));</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/blog/Unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220306152818440.png" class="" title="image-20220306152818440"><ul><li>转换关系受到两点的位置影响</li></ul><p><strong>本地坐标转世界坐标</strong></p><p>概念：</p><p>表明该点在本地坐标上，但要在世界坐标上表示出来</p><p>API</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本地的点转世界的点</span></span><br><span class="line">print(<span class="keyword">this</span>.transform.TransformPoint(Vector3.forward));</span><br><span class="line"></span><br><span class="line"><span class="comment">//本地的方向转世界的方向</span></span><br><span class="line">print(<span class="keyword">this</span>.transform.TransformVector(Vector3.forward));</span><br></pre></td></tr></table></figure><img src="/blog/Unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220306155711042.png" class="" title="image-20220306155711042"><p><strong>总结</strong>：</p><ul><li><strong>本地坐标系的点 转世界坐标系的点 极其重要</strong></li><li>当角色需要攻击前方的单位时，只需要将对方的本地坐标位置转换为世界坐标位置，就可以进行攻击范围判断</li></ul><h3 id="2-4-Input和Screen"><a href="#2-4-Input和Screen" class="headerlink" title="2.4 Input和Screen"></a>2.4 Input和Screen</h3><h4 id="2-4-1-输入相关Input"><a href="#2-4-1-输入相关Input" class="headerlink" title="2.4.1 输入相关Input"></a>2.4.1 输入相关Input</h4><p>注意：输入相关内容，肯定是输入在Update当中</p><p> 知识点一：<strong>鼠标在屏幕输入</strong></p><p>屏幕的坐标<strong>原点</strong> 在屏幕的<strong>左下角</strong> 往右是Z轴正方向，往上是Y轴正方形</p><p>返回值是Vector3 ，但只有x和y有值</p><p><strong>API</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(Input.mousePosition);</span><br></pre></td></tr></table></figure><p>知识点二：<strong>检测鼠标输入</strong></p><p><strong>参数</strong>：0 左键，1 右键，2中键</p><p><strong>API</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//鼠标按下的瞬间被调用</span></span><br><span class="line"><span class="keyword">if</span>(Input.GetMouseButtonDowm(<span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">print(<span class="string">&quot;鼠标左键被按下&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标抬起的瞬间被调用</span></span><br><span class="line"><span class="keyword">if</span>(Input.GetMouseButtonUp(<span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;鼠标左键被抬起了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标长按时一直被调用</span></span><br><span class="line"><span class="keyword">if</span>(Input.GetMouseButton(<span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">print(<span class="string">&quot;鼠标右键按下&quot;</span>);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中键滚动</span></span><br><span class="line"><span class="comment">//返回值是Vector2的值，鼠标中间滚动时 改变Y值</span></span><br><span class="line"><span class="comment">//-1 往下滚动 0 不滚动 1 往上滚动</span></span><br><span class="line">print(Input.mouseScrollDelta);</span><br></pre></td></tr></table></figure><p><strong>功能</strong>：</p><ol><li>可以做 发射子弹</li><li>可以控制摄像机视角移动</li></ol><p>知识点二：<strong>检测键盘输入</strong></p><p><strong>API</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//键盘按下</span></span><br><span class="line"><span class="keyword">if</span>(Input.GetKeyDown(KeyCode.W))</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;W键被按下&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//键盘抬起</span></span><br><span class="line"><span class="keyword">if</span>(Input.GetKeyUp(KeyCode.W))</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;W键抬起&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//键盘长按</span></span><br><span class="line"><span class="keyword">if</span>(Input.Getkey(KeyCode.W))</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;W键长按&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>作用</strong>：</p><ol><li>按键释放技能 或者 切换武器</li><li>人物行走</li></ol><p>知识点三：<strong>检测默认轴输入</strong></p><p>API</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//键盘AD按下时 返回 -1到1之间的变换</span></span><br><span class="line"><span class="comment">//得到的值就是 左右方向 可以通过它来控制 对象左右移动 或者左右旋转</span></span><br><span class="line">print(Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//键盘SW按下时 返回 -1到1之间的变换</span></span><br><span class="line">print(Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标横向移动时 -1 到 1 左右</span></span><br><span class="line">print(Input.GetAxis(<span class="string">&quot;Mouse X&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标竖向移动时 -1 到 1 下上</span></span><br><span class="line">print(Input.GetAxis(<span class="string">&quot;Mouse Y&quot;</span>));</span><br></pre></td></tr></table></figure><p>知识点四： 其他</p><p><strong>改键操作</strong></p><p>API</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任意键按下</span></span><br><span class="line"><span class="keyword">if</span>(Input.anyKey)</span><br><span class="line">&#123;</span><br><span class="line">print(<span class="string">&quot;有一个键长按&quot;</span>)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任意键长按</span></span><br><span class="line"><span class="keyword">if</span>(Input.anyKeyDown)</span><br><span class="line">&#123;</span><br><span class="line">print(<span class="string">&quot;有一个键 被按下&quot;</span>)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录这一帧的键盘输入</span></span><br><span class="line">print(Input.inputString);</span><br></pre></td></tr></table></figure><p>移动设备触摸相关</p><p>API</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Input.touchCout&gt;<span class="number">0</span>)<span class="comment">//手指触摸屏幕时 就会有一个 touch对象</span></span><br><span class="line">&#123;</span><br><span class="line">    Touch t1 = Input.touches[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//触摸位置</span></span><br><span class="line">    print(t1.position);</span><br><span class="line">    <span class="comment">//相对上次触摸位置的变化</span></span><br><span class="line">    print(t1.deltaPosition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-2-屏幕相关Screen"><a href="#2-4-2-屏幕相关Screen" class="headerlink" title="2.4.2 屏幕相关Screen"></a>2.4.2 屏幕相关Screen</h4><p>知识点一：静态属性</p><ol><li><strong>当前屏幕分辨率</strong></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到当前显示器的分辨率 以及 帧数</span></span><br><span class="line">Resolution r = Screen.currentResolution;</span><br><span class="line">print(<span class="string">&quot;当前屏幕分辨率是&quot;</span>+r.width+<span class="string">&quot;×&quot;</span>+r.height+ <span class="string">&quot;×&quot;</span> +r.refreshRate);</span><br></pre></td></tr></table></figure><p>2.<strong>game视图当前宽高</strong></p><p>一般写代码 用窗口宽高做计算时 就用他们</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前游戏窗口的分辨率</span></span><br><span class="line">Resolution r = Screen.currentResolution;</span><br><span class="line"></span><br><span class="line">print(Screen.width + <span class="string">&quot;×&quot;</span> +Screen.height);</span><br></pre></td></tr></table></figure><p>3.屏幕休眠模式</p><p>设置手机屏幕是否息屏</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//永远不息屏</span></span><br><span class="line">Screen.sleepTimeout = SleepTimeout.NeverSleep;</span><br><span class="line"></span><br><span class="line"><span class="comment">//跟随系统设置</span></span><br><span class="line">Screen.sleepTimeout = SleepTimeout.SystemSetting;</span><br></pre></td></tr></table></figure><p>4.全屏或者窗口化模式</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行时 是否全屏</span></span><br><span class="line">Screen.fullScreen= <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//独占全屏</span></span><br><span class="line">Screen.fullScreenMode = FullScreenMode.ExclusiveFullScreen;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全屏窗口</span></span><br><span class="line">Screen.fullScreenMode = FullScreenMode.FullScreenWindow;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大化窗口</span></span><br><span class="line">Screen.fullScreenMode = FullScreenMode.MaximizedWindow;</span><br><span class="line"></span><br><span class="line"><span class="comment">//窗口模式</span></span><br><span class="line">Screen.fullScreenMode = FullScreenMode.Windowed;</span><br></pre></td></tr></table></figure><p>知识点二：静态方法</p><ol><li>设置分辨率，一般移动设备不使用</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前面的参数为分辨率，后面参数为 是否全屏</span></span><br><span class="line">Screen.SetResolution(<span class="number">1920</span>,<span class="number">1080</span>,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h4 id="示例：控制物体移动和旋转"><a href="#示例：控制物体移动和旋转" class="headerlink" title="示例：控制物体移动和旋转"></a><strong>示例</strong>：控制物体移动和旋转</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//控制物体前后移动</span></span><br><span class="line"><span class="keyword">this</span>.transform.Tramslate(Vector3.forward * moveSpeed * Time.deltaTime * Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制物体旋转</span></span><br><span class="line"><span class="keyword">this</span>.transform.Rotate(Vector3.up * rotateSpeed * Time.deltaTime * Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="2-5-Camera相关"><a href="#2-5-Camera相关" class="headerlink" title="2.5 Camera相关"></a>2.5 Camera相关</h3><p>相机默认的视角方向是<strong>Z轴</strong>方向</p><h4 id="2-5-1-Camera编辑器相关"><a href="#2-5-1-Camera编辑器相关" class="headerlink" title="2.5.1 Camera编辑器相关"></a>2.5.1 Camera编辑器相关</h4><img src="/blog/Unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220307170417241.png" class="" title="image-20220307170417241"><p>Camera组件信息</p><ol><li><strong>Clear Flags</strong>：如何清除背景<ol><li>skybox 天空盒渲染 主要用于3D游戏</li><li>solid Color 颜色填充 将颜色填满整个game视图 用于2D游戏</li><li>Depth only 只渲染对象，将背景透明  用于<strong>多个相机叠加渲染</strong></li></ol></li></ol><ol><li><strong>Culling Mask</strong>：选择性渲染部分层级</li></ol><p>​        1.可以指定只渲染对应层级的对象</p><ol><li><strong>Projection</strong>：相机的透视方式</li></ol><p>​        1.默认为Perspective <strong>透视模式</strong> 符合“近大远小”，用于3D</p><p>​        2.Orthograpgic <strong>正交模式</strong> 。一般用于2D游戏</p><p><img src="Unity入门基础/image-20220307162155169.png" style="zoom: 80%;" /></p><ol><li><strong>Clipping Planes</strong>：裁剪平面距离。用于设置相机最近和最远的视野</li></ol><ol><li><strong>Depth</strong>：渲染顺序上的深度 ，该参数需要多摄像机起作用</li></ol><p>​        1.渲染深度<strong>越大</strong>，渲染画面时间就<strong>越后</strong>，并且还能<strong>挡住</strong>其            他相机的画面    </p><p>​        2.通过修改<strong>深度高</strong>相机中的 <strong>Depth only</strong> 参数，并且<strong>取消        除对象外的所有渲染</strong>，就可以让两个相机渲染的对象<strong>同时</strong>        被看到</p><ol><li><p><strong>Target Texture</strong>：渲染纹理，可以把摄像机画面渲染到一张图上，<strong>用于制作小地图</strong></p><ol><li><p>再project 中右键创建 <strong>Reder Texture</strong></p></li><li><p>给相机的<strong>Target Texture</strong>属性添加 <strong>Reder Texture</strong></p></li></ol></li></ol><p>​    7.<strong>Occlusion Culling</strong> ：<strong>是否开启剔除遮挡</strong></p><p>​        1. 开启后将 不会渲染 被遮挡到的 对象 ，可以节约性能</p><h4 id="2-5-2-代码相关"><a href="#2-5-2-代码相关" class="headerlink" title="2.5.2 代码相关"></a>2.5.2 代码相关</h4><p>相机相关类型需要卸载<strong>LateUpdate</strong>里面</p><p>知识点一：重要静态成员</p><ol><li><p><strong>获取摄像机</strong></p><p>主摄像机的Tag 必须为MainCamera，否则不能通过以下API查找</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找摄像机</span></span><br><span class="line">print(Camera.main.name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取摄像机数量</span></span><br><span class="line">print(Camera.allCamerasCount);</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到所有摄像机，返回值是数组类型</span></span><br><span class="line">Camera[] allCamera=Camera.allCameras;</span><br><span class="line">print(allCamera.Length)</span><br></pre></td></tr></table></figure></li></ol><p>知识点二：重要成员</p><ol><li>界面上的参数 都可以再Camera中获取</li><li>世界坐标转换为<strong>屏幕坐标</strong></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector3 v = Camera.main.WorldToScreenPoint(<span class="keyword">this</span>.transform.position);</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>得到的坐标X,Y轴代表<strong>屏幕坐标</strong></li><li>而Z轴则代表<strong>相机与对象之间的距离</strong>。常用于制作头顶血条相关功能</li></ul><p>3.屏幕坐标转世界坐标</p><p>注意：</p><p>因为鼠标移动改变的是X，Y轴。</p><p>所以移动鼠标时，实际上一直是在由相机的X,Y轴所构成的平面上移动。</p><p>而Z轴是相机与平面之间形成的距离</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vector3 v = Input.mousePosition;<span class="comment">//获取鼠标屏幕坐标的X,Y值</span></span><br><span class="line">v.z=<span class="number">10</span>;<span class="comment">//为鼠标屏幕坐标的Z轴赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将屏幕坐标转换为世界坐标，并将该坐标赋值给实体</span></span><br><span class="line">obj.position = Camera.main.ScreenToWorldPoint(v);</span><br></pre></td></tr></table></figure><hr><h2 id="3-Unity-核心系统"><a href="#3-Unity-核心系统" class="headerlink" title="3. Unity 核心系统"></a>3. Unity 核心系统</h2><h3 id="3-1-光源系统"><a href="#3-1-光源系统" class="headerlink" title="3.1 光源系统"></a>3.1 光源系统</h3><p><strong>光源组件</strong></p><img src="/blog/Unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220309155509767.png" class="" title="image-20220309155509767"><p>知识点：</p><ul><li><strong>Type</strong>：光源类型<ul><li>Point：点光源，类似于于“灯泡”</li><li>Sopt：聚光灯，类似于一个从上往下照的“手电筒”<ul><li>参数Range：发光范围距离</li><li>参数Spot Angle：光圈大小</li></ul></li><li>Area：面光源：只在烘焙状态下有用，不能实时渲染，好处是可以性能</li></ul></li></ul><ul><li>Color：光源颜色</li></ul><ul><li><strong>Mode</strong>：光源模式<ul><li>Realtime：实时光源。每帧实时计算，性能消耗大</li><li>Baked：烘焙光源。事件计算好，无法动态变化</li><li>Mixed：混合光源。预先计算+实时运算</li></ul></li></ul><ul><li><strong>Intensity</strong>：光源亮度。若想模拟夜晚效果，可以稍微降低数值</li></ul><ul><li><strong>Shadow Type</strong>：阴影种类<ul><li>SoftShadows：柔和阴影。默认参数</li><li>HardShadows：生硬阴影，有锯齿，性能消耗低</li><li>NoShadows：关闭阴影</li></ul></li></ul><ul><li><p>Cookie：投影遮罩。使用贴图代替灯光的投影</p></li><li><p>Drwa Halo：球形光环开关。类似蜡烛的光晕效果</p></li><li><p>Flare：耀斑。类似人眼看太阳的效果，Game视图默认看不到，需要在相机中添加Flare Layer脚本才行</p></li></ul><ul><li><strong>Culling Mask</strong>：剔除遮罩层，决定哪些层的对象受到该光源影响</li></ul><p><strong>光相关面板</strong></p><p>面板路径：</p><p>Window—&gt;Rendering—&gt;Lighting</p><img src="/blog/Unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220309163834203.png" class="" title="image-20220309163834203"><ul><li>环境相关设置<ul><li><strong>天空盒材质</strong>：可以改变天空盒</li></ul></li></ul><img src="/blog/Unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220309164106881.png" class="" title="image-20220309164106881"><img src="/blog/Unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220309164121379.png" class="" title="image-20220309164121379"><hr><h3 id="3-2-碰撞检测"><a href="#3-2-碰撞检测" class="headerlink" title="3.2 碰撞检测"></a>3.2 碰撞检测</h3><p>碰撞产生的条件，<strong>两个物体都有碰撞器，至少有一个物体有刚体</strong></p><h4 id="3-2-1-刚体"><a href="#3-2-1-刚体" class="headerlink" title="3.2.1 刚体"></a>3.2.1 刚体</h4><img src="/blog/Unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220309165348540.png" class="" title="image-20220309165348540"><ul><li><p>Mass：质量(默认为千克)，质量越大，摩擦力越大，产生的动量也越大</p></li><li><p>Drag：空气阻力，0表示没有阻力</p></li><li><strong>Angular Drag</strong>：扭矩阻力，影响<strong>物体旋转</strong>的空气阻力</li><li>Use Gravity：是否开启重力</li></ul><ul><li>Is Kinematic：开启选项后，该对象<strong>不受力的作用</strong></li></ul><ul><li><p>Interpolate：插值运算。当<strong>物理帧更新较长</strong>时，就能用<strong>插值运算</strong>解决对象<strong>运动不平滑</strong>问题</p><ul><li>None：不应用插值运算</li><li><strong>Interpolate</strong>：根据<strong>前一帧</strong>的变换来平滑变换。适用于<strong>物理帧更新较长</strong></li><li>Extrapolate：根据<strong>后一帧</strong>的变换来平滑变换</li></ul></li></ul><p><strong>重要</strong>：</p><ul><li><p>Conllison Detection(碰撞检测模式)：<strong>防止对象移动过快而检测不到碰撞</strong></p><img src="/blog/Unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220309171225228.png" class="" title="image-20220309171225228"></li></ul><ul><li><strong>Constraints</strong>：约束。对刚体运动进行限制，<strong>避免角色在移动过程中被撞飞</strong><ul><li><strong>Freeze Position</strong>：有选择的 避免刚体沿着世界的X,Y,Z轴移动</li><li><strong>Freeze Rotation</strong>：有选择的 避免刚体围绕本地的X,Y,Z轴旋转</li></ul></li></ul><h4 id="3-2-2-碰撞器"><a href="#3-2-2-碰撞器" class="headerlink" title="3.2.2 碰撞器"></a>3.2.2 碰撞器</h4><p><strong>3D碰撞器种类</strong></p><ol><li>盒装</li><li>球状</li><li>胶囊</li><li>网格</li><li>轮胎</li><li>地形</li></ol><p><strong>共同参数</strong></p><ul><li><strong>Is Trigger</strong>(触发器)：用于<strong>触发事件</strong>，并取消该物体的物理碰撞效果<ul><li>作用：可以将穿透武器设置为触发器，这样它就能攻击到后方的怪物，还能在穿过怪物时，设置触发事件</li></ul></li></ul><ul><li>Material(物理材质)：可以确定碰撞体和其它对象碰撞时的交互方式</li></ul><ul><li>Center：碰撞体在对象局部空间中的位置。可以进行更改</li></ul><p><strong>常用碰撞器</strong></p><ul><li><p>Box Collider(盒装碰撞器)</p><ul><li>size：碰撞体在X,Y,Z放上的缩放大小</li></ul></li><li><p>Sphere Collider(球状碰撞器)</p><ul><li>Radius：球形碰撞体的半径大小</li></ul></li><li>Capsule Collider(胶囊碰撞器)：可以理解为一个圆柱和两个半圆组成<ul><li>Radius：胶囊体的半径，决定两个半圆的大小</li><li>Height：胶囊体的高度，决定圆柱体的高</li><li>Direction：胶囊体在对象局部空间中的轴向。决定胶囊的朝向</li></ul></li></ul><p><strong>复杂物体使用多种碰撞器组合</strong></p><p>刚体对象的 子对象碰撞器也能 参与碰撞检测</p><h4 id="3-2-3-物理材质"><a href="#3-2-3-物理材质" class="headerlink" title="3.2.3 物理材质"></a>3.2.3 物理材质</h4><p><strong>创建物理材质</strong></p><img src="/blog/Unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220309205704616.png" class="" title="image-20220309205704616"><ul><li>创建物理材质之后，将材质拖动到 对象碰撞器组件中的<strong>Material</strong>中</li></ul><p><strong>物理材质参数</strong></p><ul><li>Dynamic Friction：移动时使用的摩擦力，通常在0~1之间</li><li>Static Friction：静止时表明的摩擦力</li><li>Bounciness：表明的弹性。值为0时不会反弹，值为1时反弹不损失能量</li></ul><h4 id="3-2-4-碰撞检测函数"><a href="#3-2-4-碰撞检测函数" class="headerlink" title="3.2.4 碰撞检测函数"></a>3.2.4 碰撞检测函数</h4><p>碰撞和触发响应函数，属于 特殊的生命周期函数，也是通过反射调用</p><img src="/blog/Unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/image-20220309210945700.png" class="" title="image-20220309210945700"><ul><li>每执行一次物理帧更新，都会去检测<strong>碰撞</strong>和<strong>触发</strong>函数</li></ul><p>知识点一：<strong>物理碰撞检测函数</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//碰撞刚接触时 时调用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionEnter</span>(<span class="params">Collision collision</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">//1.碰撞到 对象的碰撞器信息</span></span><br><span class="line">    print(collision.collider.name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.碰撞对象(GameObject)</span></span><br><span class="line">    print(collision.gameObject);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.碰撞对象的位置信息</span></span><br><span class="line">    print(collision.transform);       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//碰撞结束 时调用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionExit</span>(<span class="params">Collision collision</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个物体相互摩擦时 会一直调用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionStay</span>(<span class="params">Collision collision</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知识点二：<strong>触发器检测函数</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//触发开始</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>) <span class="comment">// 参数是碰撞器相关内容，相当于把碰撞器当作参数传入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//这里的other相当于触发对象的 触发器脚本</span></span><br><span class="line">    print(<span class="keyword">this</span>.name + <span class="string">&quot;被&quot;</span> + other.gameObject.name + <span class="string">&quot;触发了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//触发结束</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerExit</span>(<span class="params">Collider other</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//触发过程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerStay</span>(<span class="params">Collider other</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知识点三：明确什么时候会响应函数</p><ul><li>只要挂载脚本的对象 能和其它物体产生<strong>碰撞</strong>或者<strong>触发</strong>，就能被响应</li><li>如果是一个复杂的物体，刚体和脚本必须挂载在同一个对象上</li></ul><h4 id="3-2-5-刚体添加力"><a href="#3-2-5-刚体添加力" class="headerlink" title="3.2.5 刚体添加力"></a>3.2.5 刚体添加力</h4><p>刚体加力的目的就是 让其有一个速度 朝着某一方向移动</p><p>知识点一：刚体自带添加力的方法</p><ul><li>首先应该获取刚体组件</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rigidbody rb;<span class="comment">//声明成员变量</span></span><br><span class="line">rb=<span class="keyword">this</span>.GetComponent&lt;Rigidbody&gt;();<span class="comment">//获取刚体组件</span></span><br></pre></td></tr></table></figure><ul><li>给刚体对象添加力</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相对世界坐标系添加一个力,当对象没有其它阻力时，将会一直保持运动</span></span><br><span class="line">rb.AddForce(Vector3.forward * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//相对本地坐标系 添加一个力</span></span><br><span class="line"></span><br><span class="line">rb.AddRelativeForce(Vector3.forward * <span class="number">10</span>);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">rb.AddForce(<span class="keyword">this</span>.transform.forward * <span class="number">10</span>);</span><br></pre></td></tr></table></figure><ul><li>给刚体添加扭矩力，让刚体旋转</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3、扭矩力</span></span><br><span class="line"> <span class="comment">//相对世界坐标</span></span><br><span class="line">rb.AddTorque(Vector3.up * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//相对本地坐标</span></span><br><span class="line">rb.AddRelativeTorque(Vector3.up * <span class="number">10</span>);</span><br></pre></td></tr></table></figure><ul><li>直接改变刚体速度</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4、直接改变速度</span></span><br><span class="line"><span class="comment">//相对于世界坐标系</span></span><br><span class="line">rb.velocity = Vector3.forward * <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>知识点二：力的几种模式</p><p>第二个参数是指 力的模式，主要的作用是 计算方式不同</p><p>由于四种计算方式不同，最终的移动速度就会不同</p><ul><li>Acceleration：给物体增加一个持续的加速度，<strong>忽略其质量</strong><ul><li>v=Ft/m    动量定理</li><li>F：(0,0,10)，t：0.02s 物理帧更新时间，m：默认为1</li><li>v=10*0.02/1=0.2 m/s</li><li>每物理帧更新移动：0.2*0.02 = 0.004 m</li></ul></li></ul><ul><li><p><strong>Force</strong>：给物体添加一个持续的力，与<strong>物体的质量有关</strong></p><ul><li><p>v=Ft/m    动量定理</p></li><li><p>F：(0,0,10)，t：0.02s 物理帧更新时间，m：2kg</p></li><li><p>v=10*0.02/2=0.1 m/s</p></li><li><p>每物理帧更新移动：0.2*0.02 = 0.002 m</p></li></ul></li></ul><ul><li>Impulse：给物体添加一个瞬间的力，与物体质量有关，忽略时间，默认为1<ul><li>v=Ft/m    动量定理</li><li>F：(0,0,10)，t：默认为1，m：2kg</li><li>v=10*1/2=5 m/s</li><li>每物理帧更新移动：5*0.02 = 0.1 m</li></ul></li></ul><ul><li><p>VelocityChange：给物体添加一个瞬时速度，忽略质量</p><ul><li><p>v=Ft/m</p></li><li><p>F：(0,0,10)，t：默认为1，m：默认为1</p></li><li><p>v=10*1/1=10 m/s</p></li><li><p>每物理帧更新移动：10*0.02=0.2 m</p></li></ul></li></ul><p>知识点三：刚体休眠</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Unity为了节约性能，有时会让刚体进入休眠状态，此时会产生意想不到的结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rb.IsSleeping())</span><br><span class="line">&#123;</span><br><span class="line"> rb.WakeUp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-3-音效系统"><a href="#3-3-音效系统" class="headerlink" title="3.3 音效系统"></a>3.3 音效系统</h3><h4 id="3-3-1-音频文件导入"><a href="#3-3-1-音频文件导入" class="headerlink" title="3.3.1 音频文件导入"></a>3.3.1 音频文件导入</h4><p>常用音频格式</p><ul><li>wav</li><li>mp3</li><li>ogg</li><li>aiff</li></ul><p><strong>音频文件属性设置</strong></p><ul><li>Force To Mono：多声道转单声道，<strong>默认不勾选</strong></li><li><strong>Load In Background</strong>：在后台加载，不阻塞主线程。适应于较大的音效</li><li>Ambisonic：立体混响声，适用于特定的VR或XR应用，默认不勾选</li></ul><ul><li><strong>LoadType</strong>：音效加载类型<ul><li>Decompress On Load：加载快，占用内存高。适用于小音效</li><li>Compress in memory：加载慢，占用内存小。适用于大音效</li><li>Streaming：在内存不够的极端情况下使用</li></ul></li></ul><ul><li><strong>Preload Audio Data</strong>：预加载音效，进入场景前就加载音效。默认勾选</li><li>compression Format：压缩方式<ul><li>PCM：音频以最高质量存储。适用于背景音乐</li><li>Vorbis：相对PCM压缩更小，根据质量决定</li><li>ADPCM：包含噪音。适用于打击音效</li></ul></li></ul><h4 id="3-3-2-音频源和音频监听"><a href="#3-3-2-音频源和音频监听" class="headerlink" title="3.3.2 音频源和音频监听"></a>3.3.2 音频源和音频监听</h4><p><strong>AudioSource</strong>(音频源)</p><ul><li><strong>AudioClip</strong>：关联需要播放的音频文件</li><li><p>Mute：静音开关</p></li><li><p><strong>Play On Awake</strong>：对象创建时就播放音乐。一般用于背景音乐的自动播放</p></li><li><strong>Loop</strong>：循环播放，默认不勾选</li><li>Volume：音量大小</li><li>Pitch：音高，用于游戏倍速</li></ul><ul><li><strong>Spatial Blend</strong>：音频受3D空间的影响程度，默认为2D，设置为1时，就受3D空间的影响。</li></ul><ul><li><p>3D Sound Settings：和 Spatial Blend 参数成正比应用</p><ul><li><p>Volume Rolloff：声音衰减速度</p><ul><li><strong>Linear Rolloff</strong>：与音频源的距离越远，听到的声音越小。类似于脚步声</li></ul></li><li><p>Min/Max Distance：最小距离内，声音保持最大响度。最大距离外，声音开始减弱</p></li></ul></li></ul><p><strong>Audio Listener</strong>(音频监听)</p><p>该脚本处于摄像机上，并且保证<strong>有且只有一个</strong>Audio Listener，音频才能工作</p><h4 id="3-3-3-代码控制音频源"><a href="#3-3-3-代码控制音频源" class="headerlink" title="3.3.3 代码控制音频源"></a>3.3.3 代码控制音频源</h4><p>知识点一：代码控制播放停止</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">AudioSource audioSource;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">audioSource = <span class="keyword">this</span>.GetComponent&lt;AudioSource&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//知识点一：代码控制播放停止</span></span><br><span class="line"><span class="keyword">if</span> (Input.GetKeyDown(KeyCode.P))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//从头播放音效</span></span><br><span class="line">audioSource.Play();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Input.GetKeyDown(KeyCode.S))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//停止音效</span></span><br><span class="line">    audioSource.Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//暂停音效</span></span><br><span class="line">    audioSource.Pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知识点二：如何检测音效播放完毕</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Updata中 不停的检测该属性</span></span><br><span class="line"><span class="comment">//如果是false则表示播放完毕</span></span><br><span class="line"><span class="keyword">if</span> (audioSource.isPlaying)</span><br><span class="line">&#123;</span><br><span class="line">   print(<span class="string">&quot;播放中&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">print(<span class="string">&quot;播放完毕&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知识点三：动态控制音效播放</p><ul><li>直接挂载在需要播放音效的对象上</li><li>用AudioSource来控制播放不同的音效</li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-UGUI</title>
      <link href="blog/Unity-UGUI/"/>
      <url>blog/Unity-UGUI/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="六大组件"><a href="#六大组件" class="headerlink" title="六大组件"></a>六大组件</h2><h3 id="Unity中如何使用UGUI"><a href="#Unity中如何使用UGUI" class="headerlink" title="Unity中如何使用UGUI"></a>Unity中如何使用UGUI</h3><p>UGUI是Unity内置的UI，可以在Unity中直接使用</p><img src="/blog/Unity-UGUI/image-20220412155303158.png" class="" title="image-20220412155303158"><p>当我们创建UI对象时，都会创建在Canvas的子对象中</p><img src="/blog/Unity-UGUI/image-20220412155516996.png" class="" title="image-20220412155516996"><p><strong>六大基础组件的作用</strong></p><img src="/blog/Unity-UGUI/image-20220412155727066.png" class="" title="image-20220412155727066"><p>总结：</p><ul><li>UGUI无需外部引用内容，直接右键使用</li><li><strong>Canvas</strong>对象和<strong>EventSystem</strong>对象上的组件被合称为六大组件</li></ul><hr><h3 id="Canvas-画布组件"><a href="#Canvas-画布组件" class="headerlink" title="Canvas(画布组件)"></a>Canvas(画布组件)</h3><p>Canvas 的意思是画布，它主要负责<strong>渲染</strong>自己的所有<strong>UI子对象</strong></p><p>可以通过修改Canvas组件上的参数 来修改渲染方式</p><p>特点：</p><p>场景中允许多个Canvas对象存在，可以<strong>分别管理不同画布的渲染方式</strong>，<strong>分辨率适应方式</strong>等参数</p><p>但，如果没有特殊需求，一个场景上一个Canvas即可</p><p>三种渲染方式(Render Mode)：</p><ul><li>Overlay：屏幕空间下的覆盖模式，<strong>UI始终显示在前面</strong></li><li>Camera：屏幕空间下的摄像机模式，<strong>3D物体可以显示在UI前</strong></li><li>World Space：世界空间下的3D模式，一般用于UI围绕着人物旋转，VR场景使用较多</li></ul><p><strong>Overlay</strong>(覆盖模式)：覆盖整个场景中的游戏画面，显示在最前方</p><ul><li>Pixel Perfect：开启无锯齿精确渲染，用性能换效果</li><li><strong>SortOrder</strong>：排序层编号(数字越大的画面，显示在越前方)</li><li>TargetDisplay：在哪个显示设备上显示，用于多显示器游戏</li></ul><p><strong>Camera</strong>(摄像机模式)：常用于将人物模型面板显示在UI之前</p><ul><li><strong>RenderCamera</strong>：用户渲染UI的摄像机(如果不设置 则类似于覆盖模式)</li><li><p><strong>Plane Distance</strong>：UI平面在摄像机的前方距离，类似于Z轴的感觉</p></li><li><p><strong>Sorting Layer</strong>：所在排序层，<strong>排序层越靠后，显示越前面</strong></p></li><li><strong>Order in Layer</strong>：排序层的序号，当<strong>排序层相同</strong>时，<strong>序号越大，显示越前</strong></li></ul><blockquote><p>第二种模式一般会专门新建一个摄像机来渲染UI</p><p>1、新建摄像机，并更改其Culling Mask参数为UI，让其只渲染UI层</p><p>2、然后主摄像机的Culling Mask参数 不渲染UI层</p><p>3、将新建摄像机关联到Render Camera</p><p>4、并修改新建摄像机的Clear Flags参数为Deaph only，让新摄像机只渲染UI层</p></blockquote><p>World Space(3D模式)：常用于VR或AR</p><blockquote><p>还可以用于制作对话框，以及跟随人物的血条等</p></blockquote><ul><li>Event Camera：用于处理UI事件的摄像机，通过关联主摄像机</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>游戏开发中常用<strong>Camera</strong>(摄像机模式)渲染</p><h3 id="CanvasScaler-分辨率自适应组件"><a href="#CanvasScaler-分辨率自适应组件" class="headerlink" title="CanvasScaler(分辨率自适应组件)"></a>CanvasScaler(分辨率自适应组件)</h3><p>CanvasScaler是 <strong>画布缩放控制器</strong>，它用于<strong>分辨率自适应组件</strong></p><p>主要负责 不同分辨率下<strong>UI控件大小的自适应</strong>，并不负责位置自适应</p><p>它提供了<strong>三种用于分辨率自适应的模式</strong></p><p>必备知识</p><img src="/blog/Unity-UGUI/image-20220412165527842.png" class="" title="image-20220412165527842"><img src="/blog/Unity-UGUI/image-20220412165548923.png" class="" title="image-20220412165548923"><img src="/blog/Unity-UGUI/image-20220412165839246.png" class="" title="image-20220412165839246"><img src="/blog/Unity-UGUI/image-20220412165905764.png" class="" title="image-20220412165905764"><p><strong>三种适配模式</strong></p><ul><li>Constant Pixel Size(恒定像素模式)：无论屏幕大小如何，<strong>UI始终保持相同像素大小</strong></li><li><strong>Scale With Screen Size</strong>(缩放模式)：<strong>随屏幕尺寸进行缩放大小</strong></li><li>Constant Physical Size(恒定物理模式)：无论屏幕大小和分辨率如何，UI元素<strong>始终保持相同物理大小</strong></li></ul><h4 id="恒定像素模式"><a href="#恒定像素模式" class="headerlink" title="恒定像素模式"></a><strong>恒定像素模式</strong></h4><ul><li><p>Scale Factor：缩放系数，会<strong>按照此系数缩放画布中的所有UI元素</strong></p></li><li><p>Reference Pixels Per Unit：单位参考像素，多少个像素对应Unity中的一个单位(默认为100像素)。会与图片设置中的Pixels Per Unit设置，一起参与计算</p></li></ul><img src="/blog/Unity-UGUI/image-20220412171705063.png" class="" title="image-20220412171705063"><p>注意：</p><p>恒定像素模式<strong>不会让UI控件进行分辨率自适应</strong>，使用较少</p><h4 id="缩放模式"><a href="#缩放模式" class="headerlink" title="缩放模式"></a><strong>缩放模式</strong></h4><p>最常用的模式，会根据屏幕尺寸进行缩放大小</p><ul><li><strong>Reference Resolution</strong>：参考分辨率。用于参与分辨率自适应计算</li><li><strong>Screen Match Mode</strong>：屏幕匹配模式，当前屏幕分辨率宽高比，不适用参考分辨率时，用分辨率大小自适应的匹配模式</li></ul><p><strong>三种匹配模式</strong></p><ul><li>Expand：水平或垂直<strong>拓展画布</strong>区域，会根据宽高比的变化来放大缩小画布，可能会有黑边</li></ul><img src="/blog/Unity-UGUI/image-20220420205431975.png" class="" title="image-20220420205431975"><ul><li><p>Shrink：水平或垂直<strong>裁剪画布</strong>区域，会根据宽高比的变化来放大缩小画布，可能会裁剪</p><img src="/blog/Unity-UGUI/image-20220420210022044.png" class="" title="image-20220420210022044"></li><li><p>Match Width Or Height：默认模式，以<strong>宽高或二者的平均值作为参考</strong>，来缩放画布区域</p><img src="/blog/Unity-UGUI/image-20220420210351615.png" class="" title="image-20220420210351615"></li></ul><img src="/blog/Unity-UGUI/image-20220420210511767.png" class="" title="image-20220420210511767"><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>游戏开发中一般使用<strong>Scale With Screen Size</strong> 缩放模式</p><p>若游戏存在横竖屏切换</p><ul><li>则选择<strong>Expand</strong>(拓展匹配，有黑边)和<strong>Shrink</strong>(收缩匹配，有裁剪)</li></ul><p>若游戏不存在横竖屏切换</p><ul><li>则使用<strong>Match Width or Height</strong>(宽高匹配)</li><li><strong>横屏游戏 Match = 1</strong>，<strong>竖屏游戏 Match = 0</strong></li></ul><hr><h3 id="Graphic-Raycaster-射线事件交互组件"><a href="#Graphic-Raycaster-射线事件交互组件" class="headerlink" title="Graphic Raycaster(射线事件交互组件)"></a>Graphic Raycaster(射线事件交互组件)</h3><p>Graphic Raycaster意思是<strong>图形射线投射器</strong>，用于<strong>检测UI输入事件的射线发射器</strong></p><p>作用：</p><p>主要<strong>通过射线检测</strong> <strong>判断玩家是否点击到了UI元素</strong></p><img src="/blog/Unity-UGUI/image-20220725215852986.png" class="" title="image-20220725215852986"><p>参数：</p><ul><li><p>Ignore Reversed Graphics：是否忽略反转图，默认勾选，则忽略反转图</p><blockquote><p>勾选后，若图形的 Rotation发生反转，则不能发生交互响应</p></blockquote></li><li><p>Blocking Object：<strong>射线被哪些类型的碰撞器阻挡</strong>(覆盖渲染模式下无效)</p><blockquote><p>None：不被阻挡</p><p>Two D：被2D碰撞器阻挡，即不能通过2D碰撞器去跟图形进行交互</p><p>Three D：被3D碰撞器阻挡</p><p>All：都阻挡</p></blockquote></li><li><p>Blocking Mask：<strong>射线被哪些层级的碰撞器阻挡</strong>(覆盖渲染模式下无效)</p><blockquote><p>该参数一般与第二个参数配合使用，为2D或者3D碰撞器添加专门的层级，使其单独生效</p></blockquote></li></ul><hr><h3 id="EventSystem和Standalone-Input-Module"><a href="#EventSystem和Standalone-Input-Module" class="headerlink" title="EventSystem和Standalone Input Module"></a>EventSystem和Standalone Input Module</h3><h4 id="EventSystem组件"><a href="#EventSystem组件" class="headerlink" title="EventSystem组件"></a><strong>EventSystem组件</strong></h4><ul><li><p>EventSystem是<strong>事件系统</strong>。它用于<strong>管理玩家输入事件并分发给各UI控件</strong></p></li><li><p>它是事件逻辑处理模块。<strong>所有的UI事件都通过EventSystem组件，进行检测并做相应的执行</strong></p></li><li><p><strong>它类似于一个中转站，和许多模块一起共同协作</strong></p></li></ul><blockquote><p>如果没有它，所有的点击、拖拽等等行为都不会被响应</p></blockquote><h4 id="EventSystem组件参数"><a href="#EventSystem组件参数" class="headerlink" title="EventSystem组件参数"></a><strong>EventSystem组件参数</strong></h4><p>参数面板如图</p><img src="/blog/Unity-UGUI/image-20220524160805691.png" class="" title="image-20220524160805691"><ul><li>First Selected：<strong>首先选择的游戏对象，可以设置游戏一开始的默认选择</strong></li></ul><blockquote><p>将一个UI对象与其关联，可以让该UI对象变为默认选中状态</p><p>比如我们创建三个Button按钮，更改其选中后的颜色</p><p>之后将其中一个按钮于First Selected进行关联，程序运行后，被关联的对象默认选中</p></blockquote><img src="/blog/Unity-UGUI/image-20220524162044548.png" class="" title="image-20220524162044548"><ul><li>Send Navigation Events：<strong>是否允许导航事件(移动/按下/取消)</strong></li></ul><blockquote><p>该参数的功能是通过键盘上的<strong>方向键</strong>或<strong>W/S/A/D键</strong>更改当前UI控件被选中的对象</p><p>通过<strong>回车</strong>和<strong>空格</strong>键来点击按钮</p></blockquote><img src="/blog/Unity-UGUI/image-20220524162349648.png" class="" title="image-20220524162349648"><ul><li>Drag Threshold：<strong>拖拽操作的阈值(移动多少像素算拖拽)</strong></li></ul><blockquote><p> 我们可以长按UI控件进行拖拽处理，这里会写上相应的逻辑代码，该处的设置就是拖拽多少各像素算拖拽</p></blockquote><h4 id="Standalone-Input-Module组件"><a href="#Standalone-Input-Module组件" class="headerlink" title="Standalone Input Module组件"></a>Standalone Input Module组件</h4><p>它是<strong>独立输入模块</strong>，主要针对<strong>处理鼠标/键盘/控制器/触屏(新版Unity)的输入</strong></p><p>而<strong>输入的事件是通过EventSystem进行分发</strong>，所以<strong>它依赖于EventSystem组件</strong>，他们两缺一不可</p><h4 id="Standalone-Input-Module组件参数"><a href="#Standalone-Input-Module组件参数" class="headerlink" title="Standalone Input Module组件参数"></a><strong>Standalone Input Module组件参数</strong></h4><p>参数面板如图</p><img src="/blog/Unity-UGUI/image-20220524163602204.png" class="" title="image-20220524163602204"><ul><li>Input Actions Per Second：<strong>每秒运允许键盘/控制器输入的数量</strong></li></ul><blockquote><p>当我们对键盘或者控制器进行长按时，对输入检测进行限制，每秒最多输入10次</p></blockquote><ul><li><p>Repeat Delay：<strong>当输入操作有重复操作时，在生效前会有一个延迟时间</strong></p></li><li><p>ForceModule Active：是否强制模块处于激活状态</p></li></ul><blockquote><p>该组件的所有参数了解即可，一般不会进行修改</p></blockquote><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ul><li><p>EventSystem还在<strong>右下角提供了调试信息</strong></p></li><li><p>若场景中的UI控件不能被点击，先检查EventSystem是否被误删</p></li><li>若Canvas中的<strong>Graphic Raycaster组件</strong>未开启，UI控件也不能进行点击</li></ul><hr><h3 id="RectTransform-矩形变换"><a href="#RectTransform-矩形变换" class="headerlink" title="RectTransform(矩形变换)"></a>RectTransform(矩形变换)</h3><p>RectTransfrom意思是矩形变换，它<strong>继承于Transfrom</strong>是专门<strong>用于处理UI元素位置大小的相关组件</strong></p><p>RectTransfrom在Transfrom的基础上加入了矩形相关，<strong>将UI元素当作一个矩形来处理</strong></p><p>加入了<strong>中心点、锚点、长宽等属性</strong></p><p>其目的是<strong>更加方便的控制其大小</strong>以及<strong>分辨率自适应中的位置适应</strong></p><h4 id="RectTransfrom参数"><a href="#RectTransfrom参数" class="headerlink" title="RectTransfrom参数"></a>RectTransfrom参数</h4><p>参数如图</p><img src="/blog/Unity-UGUI/image-20220725220411016.png" class="" title="image-20220725220411016"><blockquote><p>Rect Transfrom是继承与Transfrom，所以有些属性与Transfrom类似</p></blockquote><ul><li>Pivot：<strong>轴心(中心)点</strong>，取值范围0~1</li></ul><blockquote><p>一般位于组件中央的蓝色小圆圈，如果看不到。则可以选中组件，然后按下键盘的T键</p><p>我们创建一个Image，它左下角坐标为(0,0)、右上角坐标为(1,1)，中心点的取值范围在这之间</p><p>作用：</p><p>1、轴心点会做为旋转的中心</p><p>2、轴心点所在位置，会影响图片拉伸时向两边拉伸的比例</p></blockquote><ul><li>Anchors：<strong>相对父矩形的锚点</strong></li></ul><blockquote><p>锚点是由四个小三角形组成的点，一般位于Canvas的中央</p><p>Canvas中的白框就是Image中的父矩形，同样左下角坐标为(0,0)，右上角坐标为(1,1)</p><p>Min是矩形锚点范围X和Y的最小值</p><p>Max是矩形锚点范围X和Y的最大值</p><p><strong>当锚点是一个点时，它就相当于image中心点的原点</strong></p><p>image的Pos坐标就相当于image中心点与锚点之间的<strong>偏移距离</strong></p><p>作用：用于分辨率自适应，能够保持图片在Canvas中的相对位置</p><p>将锚点放在Canvas的左上角，并且将image也移动到Canvas左上角，就能完成分辨率自适应</p><p>当锚点是一个<strong>范围</strong>时，是<strong>基于锚点位置和image四个点位置进行计算</strong>，即image四个点所构成的矩形和Canvas所构成的矩形进行对比</p><p>这时的Pos位置将会变为Left/Top/Right/Bottom，来表示四个点之间所对应的距离</p><p>作用：制作背景图时，会image会根据Canvas的变化而进行变化</p></blockquote><ul><li>蓝图模式：开启后，编辑<strong>旋转</strong>和<strong>缩放</strong>不会影响矩形，只会影响显示内容</li></ul><blockquote><p>即开启蓝图模式后，当我们改变image的旋转和缩放时，image的白框并不会改变。一般不开启</p></blockquote><ul><li>原始编辑模式：开启后，改变<strong>轴心点</strong>和<strong>锚点</strong>不会改变矩形位置</li></ul><blockquote><p>image的Pos位置是根据轴心点和锚点进行计算的</p><p>当我们改变轴心点或锚点后，计算出的位置就会进行改变</p><p>当我们开启原始编辑模式后，就能保证image的Pos位置保持不变</p></blockquote><h4 id="快速设置中心点和锚点"><a href="#快速设置中心点和锚点" class="headerlink" title="快速设置中心点和锚点"></a>快速设置中心点和锚点</h4><p>通过点击左上角方框，可以快捷设置锚点和中心点</p><ul><li>按住Shift点击鼠标左键，可以同时设置中心点(相对自身矩形)</li><li>按照Alt键点击鼠标左键，可以同时设置image的位置</li></ul><hr><h2 id="AnChor锚点"><a href="#AnChor锚点" class="headerlink" title="AnChor锚点"></a>AnChor锚点</h2><hr><h2 id="三大基础控件"><a href="#三大基础控件" class="headerlink" title="三大基础控件"></a>三大基础控件</h2><h3 id="Image图片控件"><a href="#Image图片控件" class="headerlink" title="Image图片控件"></a>Image图片控件</h3><p>Image是图像组件，是UGUI中<strong>用于精灵图片的关键组件</strong></p><p>除了背景图等大图，一般都用Image来显示UI中的图片元素</p><blockquote><p>多个Image的渲染顺序问题</p><p>若我们创建了多个Image控件，那么越后创建的Image就会显示在越前方</p><p>我们可以改变Hierarchy面板下Image的顺序来改变不同Image的渲染</p></blockquote><h4 id="Image参数"><a href="#Image参数" class="headerlink" title="Image参数"></a>Image参数</h4><p> 参数面板如图</p><p><img src="Unity-UGUI/image-20220525092144579.png" alt="image-20220525092144579" style="zoom:100%;" /></p><ul><li><strong>Source Image</strong>：图片来源</li></ul><blockquote><p>将需要显示的图片与Source Image相关联，图片的类型必须为Sprite</p></blockquote><ul><li>Color：图像的颜色</li></ul><blockquote><p>这里会给图像添加一个叠加色</p><p>图像最终呈现效果是 图像原本颜色与添加颜色后叠加的结果</p></blockquote><ul><li><p>Material：图像的材质(一般不修改，使用UI的默认材质)</p></li><li><p><strong>Raycast Target</strong>：是否作为射线检测的目标</p></li></ul><blockquote><p>默认开启，开启该参数后，射线检测会被Image所阻挡</p><p>若此时Image后方还有一个Button，则Button被Image所遮挡的部分不能点击</p><p>取消Raycast Target后才能穿过Image，去点击后方的Button</p></blockquote><ul><li><p><strong>Maskable</strong>：是否能被遮罩</p></li><li><p><strong>Image Type</strong>：<strong>图片类型</strong></p></li></ul><blockquote><p>1、Simple(普通模式)：均匀缩放整个图片</p><p>该模式下，当我们拉伸图片时，这个图片上的像素都会被均匀的拉伸，图片会产生形变。一般当我们的图片不需要改变尺寸时，才会用到普通模式</p><p>2、Sliced(切片模式)：九宫格拉伸，只拉伸中央十字区域</p><p>该模式下，我们先需要编辑图片的Sprite Editor，移动图片中的小绿点，将其划分为九宫格。</p><p>之后再拉伸图片的过程中，只有九宫格内的十字区域被拉伸，而九宫格边缘的四个角则不会被拉伸</p><p>一般作为面板背景图时，将一个小图通过九宫格拉伸的方式改为大图，能够起到节约资源的效果</p><p>3、Tiled(平铺模式)：重复平铺中央部分</p><p>该模式下，通过编辑图片的九宫格，可以使图片拥有底纹的效果</p><p>4、Filled(填充模式)：通过改变填充量，图片会不断填充出现</p><p>该模式下有许多参数，一般用于制作进度条类的效果</p><p>Fill Method：填充方式。图片以哪种形式进行填充</p><p>Fill Origin：填充原点。图片从上/下/左/右 开始填充</p><p>Preserve Aspect：保持宽高比</p></blockquote><ul><li><strong>Set Native Size</strong>：设置为图片资源的原始大小</li></ul><blockquote><p>当我们导入一张图时，就可以点击该按钮，就能自动的将图片设置为图片像素大小的 原始尺寸</p><p>但它会根据Canvas中的适配模式不同，效果也会有所不同</p></blockquote><h4 id="代码控制"><a href="#代码控制" class="headerlink" title="代码控制"></a>代码控制</h4><p>Image常用API</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用前需要引入UnityEngine.UI</span></span><br><span class="line">Image img = <span class="keyword">this</span>.GetComponent&lt;Image&gt;();</span><br><span class="line"><span class="comment">//动态加载图片的路径</span></span><br><span class="line">img.sprite = Resources.Load&lt;Sprite&gt;(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//g</span></span><br><span class="line">img.color = Color.red;</span><br></pre></td></tr></table></figure><hr><h3 id="Text文本控件"><a href="#Text文本控件" class="headerlink" title="Text文本控件"></a>Text文本控件</h3><p>Text是UGUI中用于显示文本的关键组件</p><h4 id="Text参数相关"><a href="#Text参数相关" class="headerlink" title="Text参数相关"></a>Text参数相关</h4><p>参数面板如图</p><p><img src="Unity-UGUI/image-20220525162735745.png" alt="image-20220525162735745" style="zoom:100%;" /></p><ul><li>Text：文本框内显示的内容</li><li>Font：文本字体样式</li></ul><blockquote><p>此处可以将电脑上的字体导入到Unity中，就能给Unity添加额外的字体</p></blockquote><ul><li>FontStyle：字体样式</li></ul><blockquote><p>Normal：默认</p><p>Bold：加粗</p><p>Italic：斜体</p><p>Bold And Italic：加粗+协调</p></blockquote><ul><li>Font Size：字体大小</li></ul><blockquote><p>当我们字体大小足够大时，可能会出现看不到字体的qingk</p><p>这时可以更改Rect Transform中的宽高，也就是更改Text中的白框大小即可</p></blockquote><ul><li>Line Spacing：每一行之间的间距</li><li>Rich Text：是否开启富文本</li></ul><blockquote><p>开启富文本后，就能在文本框中实现类似HTML的效果</p><p>加粗：<b></b></p><p>斜体：<i></i></p><p>大小：<size=50></size></p></blockquote><ul><li>Alignment：对齐方式</li><li><strong>Horizontal Overflow</strong>：处理<strong>文本太宽</strong>无法放入矩形范围时的问题</li></ul><blockquote><p>Wrap：包裹模式，字体始终在矩形范围内，超出会自动换行</p><p>Overflow：溢出模式，字体可以溢出矩形框，只能通过回车换行</p></blockquote><ul><li><strong>Vertical Overflow</strong>：处理<strong>文本太高</strong>无法放入矩形范围时的问题</li></ul><blockquote><p>Truncate：截断模式，字体始终在矩形范围内，超出部分会裁剪</p><p>Overflow：溢出模式，字体可以溢出矩形框</p></blockquote><ul><li>Best Fit：忽略字体大小，始终把内容完全显示在矩形框中，会自动调整大小</li></ul><blockquote><p>MinSize：当字数过少时，字体大小最小为多小</p><p>MaxSize：当字数过多时，字体大小最大为多大</p></blockquote><ul><li>Raycast Target：射线检测</li></ul><blockquote><p>当文本框较大时，非常容易挡住后面的Button按钮</p><p>所以当我们不需要在文本中开启点击事件时，一般取消Raycast Target</p></blockquote><h4 id="边缘线和阴影"><a href="#边缘线和阴影" class="headerlink" title="边缘线和阴影"></a>边缘线和阴影</h4><p>UGUI中没有边缘性和阴影的设置，它是通过了两个脚本进行设置</p><ul><li>边缘线组件：Outline </li><li>阴影组件：Shadow</li></ul><blockquote><p>若想要Text控件中有边缘性和阴影的效果，需要手动Add Component</p></blockquote><h4 id="代码控制-1"><a href="#代码控制-1" class="headerlink" title="代码控制"></a>代码控制</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Text tex = <span class="keyword">this</span>.GetComponent&lt;Text&gt;();</span><br><span class="line">txt.text = <span class="string">&quot;123&quot;</span>;<span class="comment">//动态改变文本框内容</span></span><br></pre></td></tr></table></figure><hr><h3 id="Rawimage原始图像控件"><a href="#Rawimage原始图像控件" class="headerlink" title="Rawimage原始图像控件"></a>Rawimage原始图像控件</h3><p>它是UGUI中用于<strong>显示任何纹理图片的关键组件</strong></p><blockquote><p>它和Image的区别是，一般RwaImage用于显示大图(背景图、不需要打入图集的图片、网络下载图等)</p><p>而Image一般是用来显示小的UI元素</p></blockquote><h4 id="Rawimage参数"><a href="#Rawimage参数" class="headerlink" title="Rawimage参数"></a>Rawimage参数</h4><p>它的外观上和Image无任何区别，仅在参数上有所不同</p><p>参数面板如图</p><p><img src="Unity-UGUI/image-20220525172616185.png" alt="image-20220525172616185" style="zoom:100%;" /></p><ul><li><strong>Texture</strong>：图像纹理</li></ul><blockquote><p>它可以关联任何类型的图片，而不仅仅是Sprite</p></blockquote><h4 id="代码控制-2"><a href="#代码控制-2" class="headerlink" title="代码控制"></a>代码控制</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RawImage raw = <span class="keyword">this</span>.GetComponent&lt;RawImage&gt;();</span><br><span class="line">raw.texture = Resources.Load&lt;Texture&gt;(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="组合控件"><a href="#组合控件" class="headerlink" title="组合控件"></a>组合控件</h2><h3 id="Button按钮"><a href="#Button按钮" class="headerlink" title="Button按钮"></a>Button按钮</h3><p>Button是按钮组件，是UGUI中用于<strong>处理玩家按钮交互</strong>的关键组件</p><p>默认创建的Button是由2个对象组成</p><blockquote><p>父对象是Button组件所依附对象，同时挂载了一个Image组件，作为按钮图片</p><p>子对象是Text组件，用于显示按钮文本。该组件是可选项，若Button图片上以及做好了文字，则不需要Text组件</p></blockquote><img src="/blog/Unity-UGUI/image-20220526190230847.png" class="" title="image-20220526190230847"><h4 id="Button参数"><a href="#Button参数" class="headerlink" title="Button参数"></a>Button参数</h4><p>参数面板如图</p><p><img src="Unity-UGUI/image-20220526190447920.png" alt="image-20220526190447920" style="zoom:100%;" /></p><ul><li><strong>Interactable</strong>：按钮是否能够被点击</li></ul><blockquote><p>该选项默认勾选，取消勾选后Button不能被点击</p></blockquote><ul><li><strong>Transition</strong>：按钮被点击时的过渡效果</li></ul><blockquote><p>该选项用来设置按钮被点击时所发生的反馈效果</p><p>1、<strong>默认为Color Tinr</strong>，点击按钮后用不同的颜色来反馈</p><p>Target Graphic：用于关联Button按钮上的图片</p><p>Normal Color：正常状态下的Button颜色</p><p>Highlighted Color：鼠标移动到Button按钮上时，所显示的颜色</p><p>Pressed Color：鼠标按下Button时，所显示的颜色</p><p>Selected Color：当鼠标上一次按下结束，下一次按下未开始时，当前鼠标的焦点就会处于Button上，也就是处于选中状态</p><p>Disabled Color：当鼠标取消Interactable时，所显示的颜色</p><p><strong>FadeDuration</strong>：Button从一种颜色变为另一种颜色所需时间</p><p>2、Sprite Swap：用图片表示不同状态时的变化</p><p>3、Animation：用动画表示不同状态时的变化</p></blockquote><ul><li><strong>Navigation</strong>：导航模式</li></ul><blockquote><p>可以用键盘的方向键或W/S/A/D去<strong>控制多个Button之间的切换</strong>。可以通过开启Visualize 来看到多个Button之间的导航线</p><p>None：不能通过键盘控制多个Button之间的切换</p><p>Everything：自动</p><p>Horizontal：只能控制水平方向之间的切换</p><p>Verticval：只能控制垂直方向之间的切换</p><p>Autiomatic：自动导航</p><p>Explicit：指定关联某个方向上的Button按钮</p></blockquote><h4 id="代码控制-3"><a href="#代码控制-3" class="headerlink" title="代码控制"></a>代码控制</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Button btn = <span class="keyword">this</span>.GetComponent&lt;Button&gt;();</span><br><span class="line"><span class="comment">//按钮可以被点击</span></span><br><span class="line">btn.interactable = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若想改变Button上的图片,可以直接改变Image组件</span></span><br><span class="line">Image img = <span class="keyword">this</span>.GetComponent&lt;Image&gt;();</span><br></pre></td></tr></table></figure><h4 id="监听点击事件的两种方式"><a href="#监听点击事件的两种方式" class="headerlink" title="监听点击事件的两种方式"></a>监听点击事件的两种方式</h4><p>点击事件是在Button区域抬起、按下一次，才算一次点击</p><blockquote><p>若在Button区域按下，区域外抬起 则不算点击</p></blockquote><p>方式1：拖动脚本</p><ul><li>通过点击面板On Click()上的”+”号，就会出现以下内容</li></ul><p><img src="Unity-UGUI/image-20220526195229707.png" alt="image-20220526195229707" style="zoom:100%;" /></p><ul><li>我们将需要监听的Button按钮拖动到None中，与之关联</li></ul><p><img src="Unity-UGUI/image-20220526195407828.png" alt="image-20220526195407828" style="zoom:100%;" /></p><ul><li>此时No Function就会被激活，我们就能选择依附在Button脚本上的函数</li></ul><blockquote><p>此时当我们再点击Button后，就会调用选择好的函数。不过此处只能选择公共函数，私有函数不能选择</p></blockquote><img src="/blog/Unity-UGUI/image-20220526195716754.png" class="" title="image-20220526195716754"><p>方式2：代码关联</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若面板上的按钮较多，则可以使用代码的方式完成关联</span></span><br><span class="line">Button btn = <span class="keyword">this</span>.GetComponent&lt;Button&gt;();</span><br><span class="line"><span class="comment">//通过获取的btn对象，来获取监听,并往其中传入一个委托函数即可</span></span><br><span class="line">btn.OnClick.AddListener(ClickBtn);</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除监听</span></span><br><span class="line">btn.OnClick.RemoveListener(ClickBtn);</span><br><span class="line"><span class="comment">//移除所有监听函数</span></span><br><span class="line">btn.OnClick.RemoveAllListener();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClickBtn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    print(<span class="string">&quot;按钮被点击&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例：点击按钮后发射子弹"><a href="#示例：点击按钮后发射子弹" class="headerlink" title="示例：点击按钮后发射子弹"></a>示例：点击按钮后发射子弹</h4><blockquote><p>思路：</p><p>1、创建游戏对象</p><p>2、创建子弹对象</p><p>3、拼UI面板</p></blockquote><ul><li>创建一个游戏对象，并在脚本中实现子弹的创建</li></ul><blockquote><p>该游戏对象和其脚本仅用于创建预设体子弹，而子弹的移动功能则写在子弹的脚本中</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Test脚本，作用于GamePlayer中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fire</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//动态创建子弹对象,并设置子弹出现的位置和角度</span></span><br><span class="line">        GameObject obj = Instantiate(Resources.Load&lt;GameObject&gt;(<span class="string">&quot;Bullet&quot;</span>), <span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.rotation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建子弹对象，并在脚本中实现子弹的移动功能</li></ul><blockquote><p>将子弹对象拖入到Resources文件夹下，将其做成预设体</p><p>之后再从BulletObject脚本中完成子弹移动功能</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Bulletobject脚本，作用于Bulletd</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BulletObject</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> moveSpeed = <span class="number">20</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//延迟3s后，删除子弹</span></span><br><span class="line">        Destroy(<span class="keyword">this</span>.gameObject, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//子弹移动</span></span><br><span class="line">        <span class="keyword">this</span>.transform.Translate(moveSpeed * Vector3.forward * Time.deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建面板Panel作为Button按钮的父对象</li></ul><blockquote><p>Panel的其实就是添加了一个Image组件，只不过锚点分布在全屏</p><p>所以它会随着分辨率的变化，面板大小也会随之变化</p><p>我们将Image组件移除后，就是一个随着屏幕变化的画布</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GamePanel脚本，作用于GamePanel对象中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GamePanel</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Button btnAtk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Test player;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//通过lambda表达式和匿名函数，调用开火方法</span></span><br><span class="line">        btnAtk.onClick.AddListener(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            player.Fire();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><blockquote><p>拼面板前，我们会添加一个Panel，它的锚点分布在全屏</p><p>这样面板的大小会随着屏幕的分辨率而自适应</p><p>并且拼面板前最重要的步骤</p><p>1、修改Canvas中的UI渲染模式，将其改为Scale With Screen Size</p><p>2、若是横屏游戏，就要将Match拖动到1</p></blockquote><hr><h3 id="Toggle开关控件"><a href="#Toggle开关控件" class="headerlink" title="Toggle开关控件"></a>Toggle开关控件</h3><p>Toggle是UGUI中用于<strong>处理玩家单选框或多选框相关交互</strong>的组件</p><p>Toggle组件<strong>默认为多选框</strong>，可以配合ToggleGrounp组件制作为单选框</p><p>默认创建的Toggle是由<strong>4个对象</strong>组成</p><blockquote><p>父对象中有一个Toggle组件</p><p>子对象Background中有一个Image组件表示背景图(必选)，还有一个Label对象中有一个Text组件表示说明文字(可选)</p><p>而Background组件中又有一个子对象Checkmark，它也挂载了一个Image组件用来表示选中时的图案</p></blockquote><p><img src="Unity-UGUI/image-20220527112300032.png" alt="image-20220527112300032" style="zoom:100%;" /></p><h4 id="Toggle参数"><a href="#Toggle参数" class="headerlink" title="Toggle参数"></a>Toggle参数</h4><p>参数面板如图</p><p><img src="Unity-UGUI/image-20220527112440758.png" alt="image-20220527112440758" style="zoom:100%;" /></p><ul><li><strong>Interactable</strong>：是否能被点击，效果和Button相同</li><li>Transition：点击时的过渡效果，和Button类似</li><li>Navigation：通过键盘控制多个控件，和Button类型</li></ul><blockquote><p>以上的三个参数内容和作用都与Button类似</p></blockquote><ul><li><strong>Is On</strong>：控件默认的选中状态，若勾选，则运行时为勾选状态</li><li><strong>Toggle Transition</strong>：开关图片的过度效果</li></ul><blockquote><p>默认为Fade，当我们点击Toggle时，会出现淡入淡出的勾选图案</p><p>另一个参数为None，即没有过渡效果</p><p>此处若想节约性能，就关闭过渡效果</p></blockquote><ul><li><strong>Graphic</strong>：用于关联Toggle被选中时出现的图片</li></ul><blockquote><p>这里会默认关联Checkmark对象上的图片</p><p>而我们若想更换图片，也不会在Graphic参数中更换关联</p><p>而是直接更改Checkmark对象上的图片</p></blockquote><ul><li><strong>Group</strong>：用于关联挂载Toggle Group的对象，来制作单选框</li></ul><blockquote><p>当我们拥有多个Toggle时，其实就是一个多选框，它们之间不会进行影响</p><p>若我们想添加单选框</p><p>一般会创建一个空物体ToggleGroup作为多个Toggle的父对象</p><p>然后为空物体添加Toggle Group组件</p><p>最后再将挂载Toggle Group组件的空对象与其余子对象的Group进行关联</p><p>那么被关联的子对象就会处于互斥状态，即只能被勾选一个</p></blockquote><h4 id="代码控制-4"><a href="#代码控制-4" class="headerlink" title="代码控制"></a>代码控制</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Toggle tog = <span class="keyword">this</span>.GetComponent&lt;Toggle&gt;();</span><br><span class="line">tog.isOn = <span class="literal">true</span>;<span class="comment">//改变Toggle当前的状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过ToggleGroup来得到当前处于激活状态时的控件</span></span><br><span class="line">ToggleGroup togGroup = <span class="keyword">this</span>.GetComponent&lt;ToggleGroup&gt;();</span><br><span class="line">togGroup.allowSwitchOff = <span class="literal">false</span>;<span class="comment">//可以让开关一个都不勾选</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历ToggleGroup迭代器得到当前选中的 Toggle</span></span><br><span class="line"><span class="keyword">foreach</span>(Toggle item <span class="keyword">in</span> togGroup.ActiveToggles())&#123;</span><br><span class="line">    print(item.name + <span class="string">&quot;&quot;</span> + item.isOn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="监听事件的两种方式"><a href="#监听事件的两种方式" class="headerlink" title="监听事件的两种方式"></a>监听事件的两种方式</h4><p>方式1：托脚本</p><ul><li>点击On Value Changed面板上的 + 号，就会出现如下面板</li></ul><p><img src="Unity-UGUI/image-20220527142924368.png" alt="image-20220527142924368" style="zoom:100%;" /></p><ul><li>将需要相应的Toggle对象拖入None中，就能激活Toggle对象身上的脚本</li></ul><p><img src="Unity-UGUI/image-20220527143123639.png" alt="image-20220527143123639" style="zoom:100%;" /></p><ul><li>然后就能找到Toggle脚本上对应的函数，该函数参数必须为Boolean</li></ul><img src="/blog/Unity-UGUI/image-20220527143355841.png" class="" title="image-20220527143355841"><blockquote><p>之后我们改变当前Toggle的状态，就能触发一次函数</p><p>注意：</p><p>在选择函数的过程中，应该选择上方的Dynamic bool函数</p></blockquote><p>方式2：代码添加</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    Toggle tog;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">         tog = <span class="keyword">this</span>.GetComponent&lt;Toggle&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//委托的方式添加</span></span><br><span class="line">        tog.onValueChanged.AddListener(ChangValue2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//lambda表达式方式添加，可以不用额外写函数</span></span><br><span class="line">        tog.onValueChanged.AddListener((a) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;代码监听 状态改变&quot;</span> + a);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ChangValue2</span>(<span class="params"><span class="built_in">bool</span> v</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        print(<span class="string">&quot;代码监听 状态改变&quot;</span> + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例：通过Toggle开关-控制音效"><a href="#示例：通过Toggle开关-控制音效" class="headerlink" title="示例：通过Toggle开关 控制音效"></a>示例：通过Toggle开关 控制音效</h4><p><a href="https://www.taikr.com/course/1203/task/39576/show">https://www.taikr.com/course/1203/task/39576/show</a></p><hr><h3 id="InputField文本输入"><a href="#InputField文本输入" class="headerlink" title="InputField文本输入"></a>InputField文本输入</h3><p>InputField是输入字段组件，用于UGUI中<strong>处理玩家文本输入</strong>相关的组件</p><p>默认创建的InputField由3个对象组成</p><blockquote><p>父对象是挂载了InputField组件，还有一个Iamge组件作为背景图</p><p>子对象上Placeholder上挂载了Text组件，用来提示需要输入的文本</p><p>另一个子对象Text上挂载了Text组件，用于输入文本</p></blockquote><h4 id="InputField参数"><a href="#InputField参数" class="headerlink" title="InputField参数"></a>InputField参数</h4><p>参数面板如图</p><p><img src="Unity-UGUI/image-20220527154632816.png" alt="image-20220527154632816" style="zoom:100%;" /></p><ul><li><strong>TextComponent</strong>：用于关联显示输入内容的文本组件</li></ul><blockquote><p>一般创建号InputFiled对象后，它会默认关联Text对象</p></blockquote><ul><li><strong>Text</strong>：输入框的起始默认值</li></ul><blockquote><p>在该处输入的值，在运行程序后会变成默认值</p></blockquote><ul><li><strong>Character Limit</strong>：可以输入字符长度的最大值</li></ul><blockquote><p>默认值为0.也就是没有限制。若将其改为11，则最多只能输入11个字符</p></blockquote><ul><li><strong>Content Type</strong>：输入文本的字符限制</li></ul><blockquote><p>默认为Standard：标准模式，可以输入任意字符</p><p>Autocorrected：自动更正模式。会自动提示或者替换某些词</p><p>Integer Number：整数模式。只能输入整数</p><p>Decimal Number：十进制模式。只能输入数字或者小数</p><p>Alphanumeric：字母数字模式。只能输入字母和数字</p><p>Name：名字模式。自动将每个单词首字母大写</p><p>Email Address：邮箱地址模式。允许最多输入一个@符合组成的字符</p><p>Password：密码模式。会用星号隐藏字符，<strong>允许使用符号</strong></p><p>Pin：类似密码模式，不过<strong>只能输入整数</strong></p></blockquote><ul><li>Line Type：行类型，用于定义文本格式</li></ul><blockquote><p>默认参数为Single Line：只允许单行显示，不允许空行</p><p>Multi Line Submit：允许使用多行。当宽度不够时，会自动空行</p><p>Multi Line NewLine：允许使用多行。用户按回车键空行</p></blockquote><ul><li>Placeholder：关联用于提示输入文本的对象</li></ul><blockquote><p>默认会关联Placeholder对象</p></blockquote><ul><li>Caret Blink Rate：光标闪烁速度</li></ul><blockquote><p>值越大，光标闪烁的越快，一般使用默认值</p></blockquote><ul><li><p>Custom Caret Color：自定义光标颜色</p></li><li><p>Selection Color：鼠标选中文本时所显示的颜色</p></li><li>Read Only：只读，不能修改</li></ul><blockquote><p>开启后，文本框的内容不能被修改。用于某些固定的文本，方便复制</p></blockquote><h4 id="代码控制-5"><a href="#代码控制-5" class="headerlink" title="代码控制"></a>代码控制</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputField input = <span class="keyword">this</span>.GetComponent&lt;InputField&gt;();</span><br><span class="line">input.text = <span class="string">&quot;123&quot;</span>;<span class="comment">//设置文本</span></span><br></pre></td></tr></table></figure><h4 id="监听事件的两种方式-1"><a href="#监听事件的两种方式-1" class="headerlink" title="监听事件的两种方式"></a>监听事件的两种方式</h4><p>InputFiled有两种事件监听</p><p>On Value Changed：当文本框中内容改变时，就会调用</p><p>On End edit：当文本框内容结束编辑后调用</p><blockquote><p>只要焦点不再文本框内，都算结束输入</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">InputField input = <span class="keyword">this</span>.GetComponent&lt;InputField&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//内容每次改变时调用</span></span><br><span class="line">input.onValueChanged.AddListener((str)=&gt;&#123;</span><br><span class="line">   print(<span class="string">&quot;代码监听&quot;</span>); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束编辑后调用</span></span><br><span class="line">input.OnEndEdit.AddListener((str)=&gt;&#123;</span><br><span class="line">   print(<span class="string">&quot;代码监听&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="示例：通过点击改名按钮完成改名"><a href="#示例：通过点击改名按钮完成改名" class="headerlink" title="示例：通过点击改名按钮完成改名"></a>示例：通过点击改名按钮完成改名</h4><p><a href="https://www.taikr.com/course/1203/task/39580/show">https://www.taikr.com/course/1203/task/39580/show</a></p><h3 id="Slider滑动条"><a href="#Slider滑动条" class="headerlink" title="Slider滑动条"></a>Slider滑动条</h3><p>Slider是滑动条组件，用于UGUI中<strong>处理滑动条相关</strong>交互的组件</p><p>默认创建的Slider是由4组对象组成</p><blockquote><p>父对象 Slider上挂载了Slider组件</p><p>子对象 Background挂载了Image，用于显示背景图</p><p>Fill Area和 Handle Slide Area都是空物体，只是为了设置锚点范围，真正显示图片的是它们各自的子对象</p><p>Fill 挂载了Image，用于显示填充进度图</p><p>Handle挂载了Image，用于显示滑动块</p></blockquote><h4 id="Slider参数"><a href="#Slider参数" class="headerlink" title="Slider参数"></a>Slider参数</h4><p>参数面板如图</p><p><img src="Unity-UGUI/image-20220527163611216.png" alt="image-20220527163611216" style="zoom:100%;" /></p><ul><li>FillRect：关联用于填充进度条的图像</li></ul><blockquote><p>默认关联Fill</p></blockquote><ul><li>Handle Rect：关联用于滑动的滑动块图像</li></ul><blockquote><p>默认关联Handle</p></blockquote><ul><li><strong>Direction</strong>：滑动条值增加的方向</li></ul><blockquote><p>默认从左到右增加</p></blockquote><ul><li><p><strong>Min Value、Max Value</strong>：设置滑动条在底端和顶端的最小值和最大值</p></li><li><p><strong>Whole Numbers</strong>：是否约束为整数值变化</p></li></ul><blockquote><p>开启后，滑动条的值只能在整数进行变化</p></blockquote><ul><li><strong>Value</strong>：当前滑动条代表的数值</li><li><strong>On Value Changed：滑动条值改变时执行的函数</strong></li></ul><h4 id="代码控制-6"><a href="#代码控制-6" class="headerlink" title="代码控制"></a>代码控制</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Slider s = <span class="keyword">this</span>.GetComponent&lt;Slider&gt;();</span><br><span class="line">s.<span class="keyword">value</span>;<span class="comment">//得到当前滑动块的值</span></span><br></pre></td></tr></table></figure><h4 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h4><p>Slider控件监听函数需要float参数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Slider s = <span class="keyword">this</span>.GetComponent&lt;Slider&gt;();</span><br><span class="line">s.onValueChanged.AddListener(()=&gt;&#123;</span><br><span class="line">    print(<span class="string">&quot;代码监听&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="示例：通过滑动条控制音量大小"><a href="#示例：通过滑动条控制音量大小" class="headerlink" title="示例：通过滑动条控制音量大小"></a>示例：通过滑动条控制音量大小</h4><hr><h3 id="Scrollbar滚动条"><a href="#Scrollbar滚动条" class="headerlink" title="Scrollbar滚动条"></a>Scrollbar滚动条</h3><p>Scrollbar是滚动条组件，是UGUI中<strong>用于处理滚动条相关</strong>的组件</p><p>默认是由2组对象组成</p><blockquote><p>父对象Scrollbar对象依附了Scrollbar组件，还有显示滑块的Image组件</p><p>子对象Sliding Area对象是空物体。设置了锚点范围</p><p>真正的底图是依附在Sliding Area的子对象 Handle对象上</p><p>一般情况下我们不会单独使用滚动条，都是配合ScrollView来使用</p></blockquote><h4 id="Scrollbar参数"><a href="#Scrollbar参数" class="headerlink" title="Scrollbar参数"></a>Scrollbar参数</h4><p>参数面板如图</p><p><img src="Unity-UGUI/image-20220528150359235.png" alt="image-20220528150359235" style="zoom:100%;" /></p><ul><li>Handle Rect：关联滚动条底图对象</li><li><strong>Direction</strong>：滚动条滚动的方向</li><li><strong>Value</strong>：程序运行时，滚动条的初始位置(0~1)</li><li><strong>Size</strong>：滚动块占滚动条的大小比例(0~1)</li><li>Number Of Steps：设置滚动条可以滚动多少次</li></ul><blockquote><p>初始值为0，滚动时比较平滑。若将其设置为10，则表示将滚动条平均分为10等分，每次滚动10分之一</p></blockquote><h4 id="代码控制-7"><a href="#代码控制-7" class="headerlink" title="代码控制"></a>代码控制</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Scrollbar sb = <span class="keyword">this</span>.GetComponent&lt;Scrollbar&gt;();</span><br><span class="line"><span class="comment">//一般只能通过代码控制value 和 size的值</span></span><br><span class="line">sb.<span class="keyword">value</span>;</span><br><span class="line">sb.size;</span><br></pre></td></tr></table></figure><h4 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Scrollbar sb = <span class="keyword">this</span>.GetComponent&lt;Scrollbar&gt;();</span><br><span class="line"></span><br><span class="line">sb.OnValueChanged.AddListener((v)=&gt;&#123;</span><br><span class="line">    print(<span class="string">&quot;代码监听&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h3 id="Scorll-View滚动视图"><a href="#Scorll-View滚动视图" class="headerlink" title="Scorll View滚动视图"></a>Scorll View滚动视图</h3><p>ScorllView是滚动视图组件，是UGUI中<strong>处理滚动视图相关</strong>的组件</p><p>默认创建的ScrollView是由4组对象构成</p><blockquote><p>父对象ScrollView上依附了ScorllRect组件，和一个用于显示背景图的Image</p><p>子对象</p><p>1、Viewport对象，其子对象Content用来控制滚动视图的范围和内容显示(必须保留)</p><p>2、Scrollbar Horizontal，水平滚动条(可选)</p><p>3、Scrollbar Vertical，竖直滚动条(可选)</p></blockquote><h4 id="Scorll-View参数"><a href="#Scorll-View参数" class="headerlink" title="Scorll View参数"></a>Scorll View参数</h4><p>参数面板如图</p><p><img src="Unity-UGUI/image-20220528152154300.png" alt="image-20220528152154300" style="zoom:100%;" /></p><ul><li><strong>Content</strong>：用于关联<strong>滚动视图实际所能显示的内容范围</strong>对象</li></ul><blockquote><p>该参数会默认关联Viewport下的Content</p><p>它的范围就是滚动视图的容量范围，不是滚动视图的视口范围</p><p>若它的范围增大，则可以通过滑动滚动条，看到原本视口以外的东西</p><p>它会作为所有对象的父对象存在，Scroll View当中所有的视图都会放在它下面</p></blockquote><ul><li><strong>Horizontal &amp; Vertical</strong>：启用水平拖动 和 竖直拖动</li></ul><blockquote><p>默认都是开启状态。这里要注意的是</p><p>不管开启与否，都不会影响滚动条的存在，它只是限制了滚动条的作用</p></blockquote><ul><li><strong>Movement Type</strong>：滚动视图元素的运动类型</li></ul><blockquote><p>默认为<strong>Elastic</strong>(常用)：回弹效果，当滚出边缘后，会弹回边界</p><p><strong>Clamped</strong>：夹紧效果，始终限制在范围内，没有回弹效果</p></blockquote><ul><li><strong>Inertia</strong>：移动惯性，拖动时会有一个惯性效果</li></ul><blockquote><p>默认开启，通过Deceleration Rate来控制减速效果，0没有惯性，1不会停</p></blockquote><ul><li><strong>Scroll Sensitivity</strong>：鼠标中间控制滚动条的灵敏度</li></ul><blockquote><p>默认值为1，但实际体验效果偏慢，可以将值改为5较为合适</p></blockquote><ul><li><strong>Viewport</strong>：关联滚动视图<strong>内容视口</strong>对象</li></ul><blockquote><p>Viewport是用来控制滚动视图的视口，改变它的大小，可以改变视口大小</p><p>可以将Viewport理解为杯子的杯口，杯口多大，我们看到的东西就只有多大</p><p>而Content则是杯子的容量，表示实际上可以装多少东西</p></blockquote><ul><li>Horizontal &amp; Vertical Scrollbar：用于关联水平和竖直滚动条</li></ul><blockquote><p>若当前游戏不需要滚动条，可以直接删除Horizontal &amp; Vertical Scrollbar对象，并在参数中将其置空</p><p>最后调整Spacing参数，调整视口和滚动条的间距</p></blockquote><ul><li><strong>Visbility</strong>：根据Content的大小，来判断是否要隐藏滚动条</li></ul><blockquote><p>默认为Auto Hide And Expand View，</p><p>即当Content大于Viewport时，滚动条会自动出现，并会自动扩展Viewport</p><p>即当Content小于Viewport时，滚动条会自动消失</p><p>1、parmenent：始终显示滚动条，当Content小于Viewport时，滚动条也会显示，一般不常用</p><p>2、Auto Hide：自动隐藏滚动条，但不会拓展Viewport</p></blockquote><ul><li><strong>Spacing</strong>：滚动条和视口之间的间隔</li></ul><blockquote><p>默认值为-3，表示滚动条和视口之间有重叠</p></blockquote><h4 id="代码控制-8"><a href="#代码控制-8" class="headerlink" title="代码控制"></a>代码控制</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般是通过Scorll View来得到Content，然后再视图窗口中进行动态创建对象</span></span><br><span class="line"></span><br><span class="line">ScrollRect sr = <span class="keyword">this</span>.GetComponent&lt;ScrollRect&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变内容的大小，具体可以拖动多少，都是根据它的尺寸来的</span></span><br><span class="line">sr.content.sizeDelta = <span class="keyword">new</span> Vetor(<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变位置，范围是0~1</span></span><br><span class="line">sr.normalizedPosition = <span class="keyword">new</span> Vector2(<span class="number">0</span>,<span class="number">0.5f</span>);</span><br></pre></td></tr></table></figure><h4 id="监听事件-1"><a href="#监听事件-1" class="headerlink" title="监听事件"></a>监听事件</h4><p>监听函数的<strong>参数类型为Vector2</strong>，代表当前x、y方向上移动的位置</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sr.OnValueChanged.AddListener((ver)=&gt;)&#123;</span><br><span class="line">    print(ver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>一般用Scorll View来制作<strong>背包、商店、排行榜</strong>等功能</p><p>而我们动态创建的对象，都需要放到Content下面</p><hr><h3 id="Dropdown下拉列表"><a href="#Dropdown下拉列表" class="headerlink" title="Dropdown下拉列表"></a>Dropdown下拉列表</h3><p>Dropdown是UGUI中<strong>用于处理下拉列表</strong>相关的组件</p><p>默认创建的Dropdown是由4组对象组成</p><blockquote><p>父对象Dropdown上依附了Dropdowm组件和一个显示背景的Image组件</p><p>子对象</p><p>1、Lable对象上依附了Text组件，用来显示当前选项描述</p><p>2、Arrow对象上依附了Image组件，用来显示向下的箭头图片</p><p>3、Template对象默认失活，依附了Scroll Rect组件，用来表示下拉列表选单</p></blockquote><h4 id="Dropdowm相关参数"><a href="#Dropdowm相关参数" class="headerlink" title="Dropdowm相关参数"></a>Dropdowm相关参数</h4><p>参数面板如图</p><p><img src="Unity-UGUI/image-20220528162227059.png" alt="image-20220528162227059" style="zoom:100%;" /></p><ul><li>Template：关联下拉列表对象</li><li>Caption Text：关联显示当前选择内容的文本组件</li><li>Caption Image：关联显示当前选择内容的图片组件</li></ul><blockquote><p>下拉列表除了关联文字，也还可以关联图片</p><p>当我们在这关联图片后，下拉列表就能关联到图片</p></blockquote><ul><li><strong>Value</strong>：当前所选项的索引值</li></ul><blockquote><p>若当前列表选中的是OptionA，则索引值为0，类似于数组下标</p></blockquote><ul><li>Alpha Fada Speed：下拉列表窗口时的过渡速度</li><li><strong>Options</strong>：存在的选项列表</li></ul><blockquote><p>通过修改其中的文本，就能修改下拉列表时的内容</p></blockquote><hr><h2 id="图集制作"><a href="#图集制作" class="headerlink" title="图集制作"></a>图集制作</h2><p>UGUI和NGUI使用上最大的不同 就是NGUI在<strong>使用前需要打图集</strong>，而UGUI可以之后再打图集</p><p>打图集的目的就是为了<strong>减少DrawCall 提高性能</strong></p><h3 id="Unity中自带的打图集功能"><a href="#Unity中自带的打图集功能" class="headerlink" title="Unity中自带的打图集功能"></a>Unity中自带的打图集功能</h3><p>Unity中默认的打包图集功能是关闭的，需要在</p><img src="/blog/Unity-UGUI/image-20220601213251796.png" class="" title="image-20220601213251796"><p>Edit-&gt;Project Setting-&gt;Editor中寻找到<strong>Sprite Packer</strong></p><blockquote><p>参数如下</p><p>默认为Disabled：不会打包图集</p><p>Enabled For Bulids(Legacy Sprite Packer)：仅在构建时打包图集，编辑模式下不能打包图集</p><p>Always Enabled(Legacy Sprite Packer)：任何时候都能打包图集</p><p>其中(Legacy Sprite Packer)代表传统模式，它多了一个设置图片间隔的参数</p><ul><li>Padding Power：数字参数代表小图之间的间隔像素，为2的n次方</li></ul></blockquote><h3 id="Unity图集注意事项"><a href="#Unity图集注意事项" class="headerlink" title="Unity图集注意事项"></a>Unity图集注意事项</h3><p><strong>创建图集</strong>时需要注意Unity2020中Sprite Atals被拆分到了2D中</p><img src="/blog/Unity-UGUI/image-20220601213857765.png" class="" title="image-20220601213857765"><p>Sprite Atlas参数面板如下</p><p><img src="Unity-UGUI/image-20220601214059378.png" alt="image-20220601214059378" style="zoom:100%;" /></p><ul><li>Allow Rotation：打图集时是否会自动旋转角度</li></ul><blockquote><p>若有一大一小两张图片，在打图集时，为了节约性能，可能会将大图进行旋转到合适的角度进行打包。</p><p>但是在制作UI时不建议勾选，因为它在UI中的表现会将UI也一起旋转</p></blockquote><ul><li>Tight Packing：制作UI图集时也不建议勾选</li></ul><hr><h2 id="UI事件监听接口"><a href="#UI事件监听接口" class="headerlink" title="UI事件监听接口"></a>UI事件监听接口</h2><p>目前所有的控件都只提供了常用的事件监听列表</p><p>如果想要做一些类似<strong>长按、双击、拖拽</strong>等功能是无法制作的</p><p>或者想让<strong>Image、Text、RawImage</strong>等控件响应玩家输入也是无法制作的</p><p>所以事件接口就是用来处理类似问题，<strong>让所有控件都能够添加更多的事件监听来处理对应的逻辑</strong></p><blockquote><p>比如Button按钮中自带了onClick事件监听，所以它能处理点击事件</p><p>但它就处理不了长按、双击等更多的逻辑</p></blockquote><h3 id="有哪些事件接口"><a href="#有哪些事件接口" class="headerlink" title="有哪些事件接口"></a>有哪些事件接口</h3><p><strong>鼠标点击时调用事件</strong></p><ul><li>IPointerEnterHandler - OnPointerEnter：当鼠标<strong>进入</strong>对象时调用</li><li>IPointerExitHandler - OnPointerExit：当鼠标<strong>离开</strong>时调用</li><li>IPointerDownHandler - OnPointerDowm：当鼠标<strong>按下</strong>时调用</li><li><p>IPointerUpHandler - OnPointerUp：鼠标按下<strong>松开</strong>后调用</p></li><li><p>IPointerClickHandler - OnPointerClick：鼠标点击时调用</p></li></ul><p><strong>鼠标拖拽时调用事件</strong></p><ul><li>IBeginDragHandler - OnBeginDrag：开始拖拽时调用</li><li>IDragHandler - OnDrag：拖拽中调用</li><li>IEndDragHandler - OnEndDrag：结束拖动时调用</li></ul><blockquote><p>当我们想监听这些事件时，那就继承它们的接口，然后实现该方法。最后再将脚本挂载到想要监听的对象上</p><p>当我们对对象进行操作时，就会自动调用监听函数中的逻辑</p><p>注意：</p><p>鼠标进入事件，在移动端是不存在的，因为手机并没有鼠标</p></blockquote><h3 id="使用事件监听接口"><a href="#使用事件监听接口" class="headerlink" title="使用事件监听接口"></a>使用事件监听接口</h3><ol><li>引用UnityEngine.EventSystems命名空间，然后继承MonoBehavior的脚本 继承对应的事件接口</li><li>实现接口中的内容</li><li>讲该脚本挂载到想要监听自定义事件的UI控件上</li><li>最后要确保控件的<strong>Raycast Target开启</strong>，否则将不具备射线检测的功能</li></ol><blockquote><p>以添加鼠标进入这个接口为例</p><p>1、在Mono后面继承IPointerEnterHandler接口</p><p>2、在类中实现接口，并在接口中写逻辑</p><p>3、将脚本挂载到目标组件上</p><p>代码如下</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewBehaviourScript</span> : <span class="title">MonoBehaviour</span>,<span class="title">IPointerEnterHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//接口实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerEnter</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        print(<span class="string">&quot;鼠标进入&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="PointerEventDate参数相关"><a href="#PointerEventDate参数相关" class="headerlink" title="PointerEventDate参数相关"></a>PointerEventDate参数相关</h3><ul><li><strong>pointerId</strong>：通过打印Id来判断鼠标的左、中、右等按键的点击</li><li><strong>position</strong>：当前鼠标在屏幕坐标的实时位置</li><li>pressPosition：鼠标按下时的位置</li><li><strong>delta</strong>：鼠标移动的增量，即鼠标在移动过程中两点位置的偏移</li><li><strong>clickCout</strong>：鼠标连续点击的次数</li><li>clickTime：鼠标点击时获取当前系统时间。可以根据两次点击相减，来获得点击的间隔时间</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewBehaviourScript</span> : <span class="title">MonoBehaviour</span>,<span class="title">IPointerEnterHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerEnter</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        print(<span class="string">&quot;鼠标进入&quot;</span>);</span><br><span class="line">        <span class="comment">//左键点击是-1 中键是-2 右键是-3</span></span><br><span class="line">        print(eventData.pointerId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><strong>优点</strong>：可以自定义的监听控件，实现一些长按、双击、拖拽等特殊功能</p><p>缺点：不方便管理，需要自己写脚本继承接口挂载到对应控件上</p><hr><h2 id="EventTigger事件触发器"><a href="#EventTigger事件触发器" class="headerlink" title="EventTigger事件触发器"></a>EventTigger事件触发器</h2><p>事件触发器是EventTrigger组件，它是集成了所有UI事件接口的<strong>脚本</strong></p><p>方便我们为控件添加事件监听</p><h3 id="如何使用事件触发器"><a href="#如何使用事件触发器" class="headerlink" title="如何使用事件触发器"></a>如何使用事件触发器</h3><p><strong>1、拖拽脚本进行关联</strong></p><blockquote><p>1、创建控件后，在控件中添加EventTigger脚本</p><p>2、通过Event Trigger脚本中的Add New Event Type，选择监听事件</p><p>3、在自定义的脚本中完成对应的事件监听函数，逻辑写在该监听函数中</p><p>4、创建一个Panel面板，将控件设置为面板的子对象，然后将脚本挂在到面板上</p><p>5、点击 + 号，将Panel挂在到监听事件中，然后选择自定义脚本中的监听函数</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewBehaviourScript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestPointerEnter</span>(<span class="params">BaseEventData data</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//将父类转换为子类，得到子类中的eventData中的属性和方法</span></span><br><span class="line">        PointerEventData eventData = data <span class="keyword">as</span> PointerEventData;</span><br><span class="line">        print(<span class="string">&quot;鼠标进入&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="屏幕坐标转UI相对坐标"><a href="#屏幕坐标转UI相对坐标" class="headerlink" title="屏幕坐标转UI相对坐标"></a>屏幕坐标转UI相对坐标</h2><p><strong>RectTransformUtility</strong> 是 RectTransform下的一个辅助类</p><p>主要进行一些 坐标转换等操作</p><p>目前对于我们来说 最重要的函数是 <strong>将屏幕空间上的点， 转换成UI本地坐标下的点</strong></p><blockquote><p>作用：将鼠标在屏幕上的点，转换为UI相对于父对象下的点</p><p>一般需要配合UI事件监听中的拖拽事件使用</p><p>使用场景：</p><p>1、制作摇杆</p><p>2、实现装备拖拽</p></blockquote><p>方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">参数1、相对父对象</span></span><br><span class="line"><span class="comment">参数2、屏幕点</span></span><br><span class="line"><span class="comment">参数3、摄像机</span></span><br><span class="line"><span class="comment">参数4、最终得到的点</span></span><br><span class="line"><span class="comment">//一般配合拖拽事件使用</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDrag</span><span class="params">(PointerEventDate eventDate)</span></span>&#123;</span><br><span class="line">    Vector2 nowPos;</span><br><span class="line">    RectTransformUtility.ScreenPointToLocalPointInRectangle(</span><br><span class="line">    <span class="keyword">this</span>.transform.parent as RectTransform,<span class="comment">//transform转换为RectTransform</span></span><br><span class="line">    eventData.position,<span class="comment">//鼠标在屏幕上的坐标</span></span><br><span class="line">    evenData.enterEventCamera,<span class="comment">//UI摄像机，而非主摄像机</span></span><br><span class="line">    out nowPos);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.transform.localPostion = nowPos;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈：如何实现浏览器的前进和后退功能？</title>
      <link href="blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E6%A0%88/"/>
      <url>blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="如何理解“栈”"><a href="#如何理解“栈”" class="headerlink" title="如何理解“栈”"></a>如何理解“栈”</h3><p>栈最大的特点就是<strong>先进后出，后进先出</strong></p><blockquote><p>先存放的数据后取出，后存放的数据先取出</p></blockquote><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E6%A0%88/%E6%A0%88.jpg" class=""><p>从栈的操作特性上看，<strong>栈是一种“操作受限”的线性表</strong>，<strong>只允许在一端插入和删除</strong>数据。</p><p>虽然链表和数组能够代替栈，但<strong>特定的数据结构是对应特定场景的抽象</strong>，数组和链表暴露了太多的操作接口，使用时比较不可控。</p><p><strong>使用场景</strong>：</p><p>当某个数据集合<strong>只涉及在一端插入和删除数据</strong>，<strong>并且满足后进先出、先进后出的特性</strong>，我们就应该首先想到栈</p><h3 id="如何实现一个“栈”"><a href="#如何实现一个“栈”" class="headerlink" title="如何实现一个“栈”"></a>如何实现一个“栈”</h3><p>栈主要包含两个操作，入栈和出栈，也就是在<strong>栈顶插入一个数据</strong>和 从<strong>栈顶删除一个数据</strong>。</p><ul><li>用数组实现的栈叫做<strong>顺序栈</strong></li><li>用链表实现的栈，我们叫作<strong>链式栈</strong></li></ul><p>不管是顺序栈还是链式栈，存储数据只需要一个大小为n的数组</p><p>在出栈和入栈过程中，只需要一两个临时遍历存储空间，所以<strong>空间复杂度是0(1)</strong></p><h3 id="栈的应用场景"><a href="#栈的应用场景" class="headerlink" title="栈的应用场景"></a>栈的应用场景</h3><h4 id="栈在函数调用中的应用"><a href="#栈在函数调用中的应用" class="headerlink" title="栈在函数调用中的应用"></a><strong>栈在函数调用中的应用</strong></h4><p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来<strong>存储函数调用时的临时变量</strong>。</p><p><strong>每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈</strong></p><p>以下是代码的执行过程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">1</span>; </span><br><span class="line">   <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">   ret = add(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">   res = a + ret;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, res);</span><br><span class="line">   reuturn <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">   sum = x + y;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E6%A0%88/%E6%A0%88%E5%9C%A8%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8.jpg" class=""><h4 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h4><p>对于表达式求值，比如算术表达式：3+5*8-6</p><p>实际上，编译器是通过两个栈来实现的。其中<strong>一个栈保存操作数</strong>，<strong>另一个栈保存运算符</strong>。</p><p>我们从左向右遍历表达式，当遇到数字，就直接压入操作数栈；当遇到运算符</p><p>就于运算符栈的栈顶元素比较。</p><blockquote><p>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；</p><p>如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p></blockquote><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E6%A0%88/%E6%A0%88%E5%9C%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.jpg" class="">]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表（下）：如何轻松写出正确的链表代码？</title>
      <link href="blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E9%93%BE%E8%A1%A82/"/>
      <url>blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E9%93%BE%E8%A1%A82/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="技巧一：理解指针或引用的含义"><a href="#技巧一：理解指针或引用的含义" class="headerlink" title="技巧一：理解指针或引用的含义"></a>技巧一：理解指针或引用的含义</h3><p><strong>指针也是一种变量，只不过里面存放的是其它变量的地址</strong></p><p>只要指针中存放了这个变量的地址，就指向了这个变量，就能通过指针找到这个变量</p><blockquote><p>举个例子：</p><p>p-&gt;next = q;    这行代码表示，p结点中的next指针里面存储了 q结点的地址</p><p>p-&gt;next = p-&gt;next-&gt;next; 这行代码表示，p结点的next指针中存储了p结点的下下个结点的地址</p></blockquote><h3 id="技巧二：警惕指针丢失和内存泄漏"><a href="#技巧二：警惕指针丢失和内存泄漏" class="headerlink" title="技巧二：警惕指针丢失和内存泄漏"></a>技巧二：警惕指针丢失和内存泄漏</h3><p>当我们更改链表中指针的指向时，要警惕指针丢失的问题</p><p>以单链表插入操作为例：我们希望在a、b结点中插入一个x结点</p><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E9%93%BE%E8%A1%A82/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5.jpg" class=""><p>我们一定要<strong>先让x结点指向b结点</strong>，<strong>再让a结点指向x结点</strong>。</p><blockquote><p>这是由于b结点的地址存放在a结点处</p><p>若我们先让a结点指向x结点，那么存放在b结点的地址就被x结点地址给替代了</p><p>这样就丢失了b结点的地址，导致x结点不能指向b结点</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误写法</span></span><br><span class="line">p-&gt;next = x;<span class="comment">//p结点指向x结点，b结点地址被替代</span></span><br><span class="line">x-&gt;next = p-&gt;next;<span class="comment">//错误，这里的p结点已经指向了x结点，b结点地址已经不再是p结点的下一个结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正确写法</span></span><br><span class="line">x-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = x;</span><br></pre></td></tr></table></figure><p>以上两种代码写法是有着本质的区别，当我们<strong>插入结点时，一定要注意操作顺序</strong>，不要把下一个结点地址丢失了</p><p>同时，当我们在删除结点时，在C++中一定要<strong>手动释放被删除结点的内存空间</strong>，否则，可能会出现内存泄漏的问题</p><h3 id="技巧三：利用虚拟结点简化难度"><a href="#技巧三：利用虚拟结点简化难度" class="headerlink" title="技巧三：利用虚拟结点简化难度"></a>技巧三：利用虚拟结点简化难度</h3><p>当我们对链表进行删除时，其实可以发现，是利用<strong>上一个结点指向下一个结点</strong>实现的</p><p>不过要想删除链表中头结点，而头结点没有上一个结点该怎么办呢？</p><p>这时我们可以引入一个虚拟结点，让它指向链表的头结点，这样就不需要单独拎出只有头结点的情况</p><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E9%93%BE%E8%A1%A82/%E5%B8%A6%E5%A4%B4%E9%93%BE%E8%A1%A8.jpg" class=""><h3 id="技巧四：重点留意边界条件处理"><a href="#技巧四：重点留意边界条件处理" class="headerlink" title="技巧四：重点留意边界条件处理"></a>技巧四：重点留意边界条件处理</h3><p>我们完成链表代码的编写后要注意这几个边界问题</p><ul><li>链表为空时，代码是否正常运行</li><li>链表中只有一个头结点时，代码是否正常运行</li><li>代码在处理头结点和尾结点时，代码是否能够正常运行</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表（上）：如何实现LRU缓存淘汰算法?</title>
      <link href="blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E9%93%BE%E8%A1%A8/"/>
      <url>blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h3><p>链表常常用于和数组一起比较，我们先从它们的<strong>底层的存储结构</strong>看一下</p><ul><li><p>数组：需要一块<strong>连续的内存空间</strong>，对内存的要求较高。如果我们申请一个10MB大小的数组，若内存中没有<strong>连续的</strong>、<strong>足够大</strong>的空间时，即使剩余内存可用空间大于10MB，<strong>仍会申请失败</strong></p></li><li><p>链表：并不需要一块连续的内存空间，它通过<strong>指针</strong>讲一组<strong>零散的内存块</strong>串联起来。所以申请10MB的链表就不会有问题</p></li></ul><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E5%86%85%E5%AD%98.jpg" class=""><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p><strong>结构</strong>：</p><p>链表是通过<strong>指针</strong>讲一组零散的内存块串联在一起。其中，我们把<strong>内存块</strong>成为链表的“<strong>结点</strong>”。</p><p>一个结点除了<strong>存储数据</strong>之外，还需要<strong>记录下一个结点的地址</strong>。</p><blockquote><p>所以，一个结点是由一个<strong>数据域</strong>和一个<strong>指针域</strong>构成</p></blockquote><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E9%93%BE%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8.jpg" class=""><p>其中，我们一般将链表中的第一个结点叫做<strong>头结点</strong>，它是整条链表的<strong>入口</strong>，有了它，我们就能遍历得到整条链表</p><p>我们又将最后一个结点叫做<strong>尾结点</strong>，它指向一个<strong>空地址NULL</strong>，表示整条链表的<strong>出口</strong>，也就是结束链表的遍历</p><p><strong>插入和删除</strong>：</p><p>与数组一样，链表也支持数据的查找、插入和删除操作</p><p>当我们在链表中插入或删除一个数据，并不需要连续的移动其它结点，因为链表中的存储空间本身就不是连续的。所以，<strong>链表在插入和删除数据方便特别迅速</strong>，它的时间复杂度为O(1)</p><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4.jpg" class=""><p>不过，正因为链表的存储空间不是连续的，所以它想要访问第k个元素，就需要从头结点开始，依次遍历链表，直到找到第k个元素为止。时间复杂度为O(n)</p><blockquote><p>可以将链表想象成一列队伍，指针方向就是队伍的面朝向，队伍中的人只能看见面前的人</p></blockquote><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p><strong>循环链表是一种特殊的单链表</strong>。它跟单链表唯一的区别就是，<strong>循环链表尾结点指向了头节点</strong>。</p><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E9%93%BE%E8%A1%A8/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.jpg" class=""><blockquote><p>从图中也可以看出来，它像一个环一样，首位相连，所以叫”循环”链表</p></blockquote><p><strong>优点</strong>：</p><p>从链尾到链头比较方便，当要处理数据具有<strong>环形结构</strong>特点时，就特别适合循环链表。比如<strong>约瑟夫问题</strong></p><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>在单链表的基础上，增加了一个前驱指针prev。也就是同时具有<strong>后继指针next</strong> 和 <strong>前驱指针prev</strong>的结点构成的链表</p><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E9%93%BE%E8%A1%A8/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.jpg" class=""><p>从图中也可以知道，当我们存储同样的数据时，<strong>双向链表要比单链表占用更多的内存空间</strong>。</p><p>但它的好处是<strong>支持双向遍历，更加的灵活</strong></p><h3 id="链表的删除操作"><a href="#链表的删除操作" class="headerlink" title="链表的删除操作"></a>链表的删除操作</h3><p>在实际的应用当中，从链表中删除数据，无非就是两种情况。</p><ul><li><strong>删除结点中 “值等于某个定值” 的结点</strong></li><li><strong>删除给定指针指向的结点</strong></li></ul><blockquote><p>对于第一种情况，无论是单链表还是双向链表，都需要从头结点开始遍历，直到找到定值的结点为止</p><p>但对于第二种情况，若使用单链表的情况下，还是需要从头开始遍历链表，寻找要删除结点的前驱结点，直到p-&gt;next = q 为止。这才说明p 是 q的前驱结点。</p><p>而若使用双向链表的话就不需要从头开始遍历链表。因为当前结点已经存储了上一个结点的地址</p></blockquote><p>其实除了插入和删除操作有优势之外，对于一个<strong>有序链表</strong>，双向链表的<strong>按值查询效率</strong>也比单链表要高</p><p>因为双向链表每次都可以<strong>从中间开始查找目标值p</strong></p><p>若当前值大于p则再次向前查找，否则可以从后面区间查找。这也是<strong>二分法</strong>的思想</p><blockquote><p>所以，尽管双向链表更加耗费内存，但在实际开发中也是用的更广泛。这也是<strong>空间换时间</strong>的设计思想</p></blockquote><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E9%93%BE%E8%A1%A8/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.jpg" class=""><h3 id="链表和数组"><a href="#链表和数组" class="headerlink" title="链表和数组"></a>链表和数组</h3><p>正因为内存存储的区别，它们的<strong>插入、删除、随机访问操作</strong>的时间复杂度正好相反</p><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E9%93%BE%E8%A1%A8/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.jpg" class=""><p><strong>数组优点</strong>：</p><ul><li>简单易用，在实现上使用的是<strong>连续的内存空间</strong>，可以借助<strong>CPU的缓存机制</strong>，<strong>预读数组中的数据</strong>，所以<strong>访问效率更高</strong>。</li><li>而链表在内存中并不是连续存储的，所以对CPU缓存不友好，没有办法有效预读</li></ul><p><strong>数组缺点</strong>：</p><ul><li><strong>大小固定</strong>，一经声明就要<strong>占用整块的连续内存空间</strong>，且<strong>不能动态扩容</strong>。若数组声明过大，则会可能出现<strong>内存不足</strong>的情况。若数组声明过小，则只能<strong>重新申请一块更大的内存</strong>，然后将原数组再拷贝进去，这个过程非常耗时。</li><li>而<strong>链表本身则没有大小的限制</strong>，天然的<strong>支持动态扩容</strong></li></ul><blockquote><p>虽然C++中的vector容器是支持动态扩容的，但这个动态扩容并不是我们所理解的在原有数组的基础上添加新的空间，而是从新分配一块更大的内存，再进行数据拷贝，这一过程十分的耗时</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>如果你的内存使用条件十分的刻苦，则应该考虑数组，因为链表中会多存一个指针域，占用的内存会翻倍，而且再C++中，频繁的对链表进行插入和删除、多余的结点还需要程序员手动的释放</li></ul><h3 id="LRU缓存淘汰算法"><a href="#LRU缓存淘汰算法" class="headerlink" title="LRU缓存淘汰算法"></a>LRU缓存淘汰算法</h3><p>首先让我们来了解一下，什么是<strong>LRU缓存淘汰算法</strong></p><p>它会根据数据的历史访问记录来进行淘汰数据，其核心思想是“<strong>如果数据最近被访问过，那么将来被访问的几率也更高</strong>”</p><ul><li><strong>新数据插入到链表头部</strong></li><li><strong>每当缓存数据被访问，则该数据移动到链表的头部</strong></li><li><strong>当链表空间不足时，将链表尾部的数据丢弃</strong></li></ul><h4 id="基于链表实现LRU缓存淘汰算法"><a href="#基于链表实现LRU缓存淘汰算法" class="headerlink" title="基于链表实现LRU缓存淘汰算法"></a>基于链表实现LRU缓存淘汰算法</h4><p>思路：</p><p>我们维护一个<strong>有序</strong>单链表，越靠近链表尾部的结点越早访问。当有一个新的数据被访问时，我们从头开始遍历链表。</p><ul><li>若此数据之前<strong>已经被缓存在链表</strong>中了，那么我们就<strong>遍历得到这个数据对应的结点</strong>，<strong>将它从原来的位置删除</strong>，然后<strong>插入到链表的头部</strong></li><li>若此<strong>数据没有缓存在链表</strong>中，且此时<strong>缓存未满</strong>，则可以将此结点<strong>直接插入到链表的头部</strong>。若此时的<strong>缓存已满</strong>，则可以<strong>删除链表尾结点</strong>，再<strong>将新结点插入链表头部</strong></li></ul><blockquote><p>此时不管缓存有没有满，都需要遍历一次链表，所以基于链表思路实现的LRU的缓存访问复杂度尾O(n)</p><p>但实际上，还可以继续优化这个实现思路，比如引入散列表来记录每个数据的位置，将缓存访问的时间复杂度降到O(1)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
      <url>blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="什么是数组"><a href="#什么是数组" class="headerlink" title="什么是数组"></a>什么是数组</h3><p>数组(Array) 是一种<strong>线性表数据结构</strong>。它用一组<strong>连续的内存空间</strong>，来存储一组<strong>相同类型的数据</strong></p><h4 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h4><p>线性表就是数据排列像一条线一样的结构。每个线性表上的数据最多只有<strong>前和后</strong>两个方法。</p><p><strong>数组、链表、队列、栈</strong>等也是线性数据结构</p><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E7%BA%BF%E6%80%A7%E8%A1%A8.jpg" class=""><p>而与之相对立的是<strong>非线性表</strong>，如<strong>二叉树、堆、图</strong>等</p><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A1%A8.jpg" class=""><blockquote><p>一句话概括线性表</p><p>数据在内存中的排列方式像线一样，只有前后两个方向</p></blockquote><h3 id="数组的随机访问"><a href="#数组的随机访问" class="headerlink" title="数组的随机访问"></a>数组的随机访问</h3><p>因为数组是用一组<strong>连续的内存空间</strong>，来存放一组<strong>相同类型的数据</strong>。所以保证了数组的<strong>随机访问</strong></p><blockquote><p>但为了保证数组空间的连续性，当我们<strong>插入</strong>和<strong>删除</strong>数据时，只能对大量的数据进行移动</p><p>而不能直接删除或插入一块内存，这样的话数据空间就不连续</p></blockquote><p>编译器会给每个内存单元分配一个地址，通过地址来访问内存中的数据。</p><p>当编译器要<strong>随机访问</strong>数组中的某个元素时，他会通过<strong>寻址公式</strong>，计算出该元素的内存地址，然后访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//base_address 是数组首地址。data_type_size 是当前类型所占字节</span></span><br><span class="line">a[i]_address = base_address + i * data_type_size;</span><br></pre></td></tr></table></figure><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98.jpg" class=""><blockquote><p>简单概括数组如何实现随机访问</p><p>需要访问的元素乘以 当前元素所占内存 再加上首地址</p><p>注意：</p><p>数组适合查找，这里是指通过<strong>下标随机访问实现</strong>的，这种情况下的时间复杂度才为O(1)</p></blockquote><h3 id="低效的插入和删除"><a href="#低效的插入和删除" class="headerlink" title="低效的插入和删除"></a>低效的插入和删除</h3><p>数组<strong>适合查找</strong>，但查找的时间复杂度并不是O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)</p><blockquote><p>所以，对比链表，数组查找的最大优点在于，<strong>根据下标随机访问的时间复杂度为O(1)</strong></p></blockquote><h4 id="低效的插入"><a href="#低效的插入" class="headerlink" title="低效的插入"></a>低效的插入</h4><p>假设数组长度为 <strong>n</strong>，当我们往数组中插入元素时</p><p>若插入在数组元素<strong>末尾</strong>，那就不需要移动数据，这时的时间复杂度为O(1)</p><p>若插入在数组元素的<strong>开头</strong>，那就需要<strong>将所有元素都依次后移一位</strong>，这时的时间复杂度为O(n)</p><p>由于插入的效率低下，所以我们得通过一些方法来提高插入的效率</p><blockquote><p>假设有一个数组，<strong>仅是用于存放数据的集合</strong>，数组中的数据没有任何规律。</p><p>当我们将要某个元素插入到第k个位置时，可以先将第k个位置的元素放到数组末尾，再将目标元素插入到第k个位置，这样就避免了大规模的数据后移。时间复杂度为O(1)。</p></blockquote><p>假设数组 a[10] 中存储了如下 5 个元素：a，b，c，d，e。</p><p>我们现在需要将元素 x 插入到第 3 个位置。我们只需要将 c 放入到 a[5]，将 a[2] 赋值为 x 即可。最后，数组中的元素如下： a，b，x，d，e，c。</p><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E6%8F%92%E5%85%A5%E6%8A%80%E5%B7%A7.jpg" class=""><h4 id="低效的删除"><a href="#低效的删除" class="headerlink" title="低效的删除"></a>低效的删除</h4><p>删除操作和插入类型，<strong>当我们要删除第k个位置的数据时，为了内存的连续性，就要将大量的数据向前移动，否则内存就不连续了</strong></p><p>不过实际上，再某些特殊场景下，我们可以<strong>将多次删除的操作集中在一起</strong>。这样就不需要每次删除一个元素都频繁的移动数据</p><p>数组 a[10] 中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。</p><img src="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E5%88%A0%E9%99%A4%E6%8A%80%E5%B7%A7.jpg" class=""><blockquote><p>按照常规的流程来看，当我们依次删除a，b，c三个元素时，后面的数据就要依次往前移动三次</p><p>1、先记录下当前需要删除的数据，但先不进行数据前移</p><p>2、当我们的数组内存空间不足时，再根据之前记录所需要删除的数据，执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。</p><p>这也是垃圾回收<strong>标记清除</strong>算法的核心思想</p></blockquote><h3 id="为什么数组下标从0开始"><a href="#为什么数组下标从0开始" class="headerlink" title="为什么数组下标从0开始"></a>为什么数组下标从0开始</h3><ul><li><p>从数组的内存模型来看，下标的定义应该是”<strong>偏移</strong>“，所以a[0]就是偏移为0的位置，也就是数组的首地址</p></li><li><p>如果下标从1开始的话，那么数组在寻址公式就变了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i] = base_address + (i<span class="number">-1</span>) * type_size;</span><br></pre></td></tr></table></figure><p>这样的话<strong>每次随机访问都要多做一次减法</strong>，而下标从0开始则不用。效率会更高</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp-智能指针-侯捷</title>
      <link href="blog/Cpp-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-%E4%BE%AF%E6%8D%B7/"/>
      <url>blog/Cpp-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-%E4%BE%AF%E6%8D%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="关于智能指针"><a href="#关于智能指针" class="headerlink" title="关于智能指针"></a>关于智能指针</h2><p>设计一个Class，让它的行为像一个指针</p><p>智能指针是对普通指针进行了一层封装，<strong>普通指针所允许的操作，智能指针都能使用</strong></p><p>底层代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//*运算符重载</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *px;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//-&gt;运算符重载</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> px;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造函数初始化列表,用于接收普通指针</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>(T* p) : px(p) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* px;<span class="comment">//声明一个T类型的指针</span></span><br><span class="line">    <span class="keyword">long</span>* pn;<span class="comment">//声明一个长整型的数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Foo&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>;<span class="comment">//智能指针初始化，并指向Foo</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp-虚函数与多态-侯捷</title>
      <link href="blog/Cpp-%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%A4%9A%E6%80%81-%E4%BE%AF%E6%8D%B7/"/>
      <url>blog/Cpp-%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%A4%9A%E6%80%81-%E4%BE%AF%E6%8D%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="课程回顾"><a href="#课程回顾" class="headerlink" title="课程回顾"></a>课程回顾</h2><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">List_node_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    _List_node_base* _M_next;</span><br><span class="line">_List_node_base* _M_prev;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">List_node</span> :</span> <span class="keyword">public</span> _List_node_base</span><br><span class="line">&#123;</span><br><span class="line">_Tp _M_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>子类的对象中包含了父类的成员，在内存中的图形如下</p></blockquote><img src="/blog/Cpp-%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%A4%9A%E6%80%81-%E4%BE%AF%E6%8D%B7/image-20220507115119627.png" class="" title="image-20220507115119627"><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p><strong>在任何一个成员函数之前加上virtual 关键字</strong>，它就成为了虚函数</p><ul><li>非虚函数：如果<strong>不希望</strong>子类对父类的函数进行覆盖，那就将父类的成员函数写成非虚函数</li><li>虚函数：<strong>希望子类对父类的函数进行覆盖</strong>。并且父类的函数中有默认定义，当子类不调用时使用</li><li>纯虚函数：<strong>子类必须对父类的函数进行覆盖</strong>。父类的函数中没有默认定义，所以子类必须覆盖</li></ul><blockquote><p>在继承的关系中，父类的数据和函数都能被子类继承</p><p>父类的数据被子类继承后占用子类的内存空间</p><p>但函数继承却不是从内存的角度理解，而是子类继承了父类函数的”<strong>调用权</strong>“</p></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">( )</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;<span class="comment">//绘画，每个子类都必须对其进行覆盖，所以用纯虚函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>;<span class="comment">//报错，后续报错内容可能需要子类覆盖，所以用虚函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">objectID</span><span class="params">( )</span> <span class="keyword">const</span></span>;<span class="comment">//编号，不需要子类覆盖，所有用非虚函数定义</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ellipse</span>:</span> <span class="keyword">public</span> Shape &#123; ... &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合与继承</title>
      <link href="blog/Cpp-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF-%E4%BE%AF%E6%8D%B7/"/>
      <url>blog/Cpp-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF-%E4%BE%AF%E6%8D%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>在C++中，若一个类中的成员是指针，并且指向另外一个类。那么两者就属于委托关系</p><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">....</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    B* b;<span class="comment">//类型为B的指针，它指向B这个类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>两者形成委托关系之后，就可以通过指针在任意的时间去调用class B</p></blockquote><img src="/blog/Cpp-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF-%E4%BE%AF%E6%8D%B7/image-20220507111853629.png" class="" title="image-20220507111853629"><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">List_node_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    _List_node_base* _M_next;</span><br><span class="line">_List_node_base* _M_prev;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">List_node</span> :</span> <span class="keyword">public</span> _List_node_base</span><br><span class="line">&#123;</span><br><span class="line">_Tp _M_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>语法：</strong></p><p><code>class B : public A</code></p><p><strong>内存角度：</strong></p><img src="/blog/Cpp-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF-%E4%BE%AF%E6%8D%B7/image-20220507113011597.png" class="" title="image-20220507113011597"><blockquote><p>子类的对象中包含了父类的成员</p><p>所以，构造函数是由内而外的。当我们创建子类对象时，会先调用父类的默认构造，再构造子类</p><p>析构函数是而外而内。先析构子类，然后再析构父类</p></blockquote><p><strong>注意：</strong></p><p><strong>父类的析构函数必须是虚函数</strong>，否则析构函数就不会由外而内</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>games101笔记</title>
      <link href="blog/games101%E7%AC%94%E8%AE%B0/"/>
      <url>blog/games101%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h2><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220304211010236.png" class="" title="image-20220304211010236"><p><strong>单位向量的计算方法</strong>：</p><p>向量/向量的模长</p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220304212202619.png" class="" title="image-20220304212202619"><p><strong>向量求和</strong></p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220304212302182.png" class="" title="image-20220304212302182"><p><strong>使用直角坐标描述向量</strong></p><p>认为向量永远从原点(0,0)开始，然后沿着X轴，有一些单位向量往右走，以及一些单位向量沿着Y轴，向上走</p><p>那么就可以用几个X加上几个Y来表示这个向量</p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220304213002693.png" class="" title="image-20220304213002693"><p>注意：在图形学上，向量默认是往下写，是列向量</p><h4 id="向量的点乘"><a href="#向量的点乘" class="headerlink" title="向量的点乘"></a><strong>向量的点乘</strong></h4><ul><li>向量的点乘最终得到的结果是一个<strong>数</strong></li></ul><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220304213523423.png" class=""><ul><li>点乘可以快速得到两个向量的<strong>夹角</strong></li></ul><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220304214115299.png" class="" title="image-20220304214115299"><ul><li>尤其是当两个向量都为<strong>方向向量</strong>时最为方便</li></ul><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220304214148791.png" class="" title="image-20220304214148791"><p>在<strong>直角坐标系</strong>中，两个向量进行<strong>点乘</strong>更为方便</p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220304214430433.png" class="" title="image-20220304214430433"><p><strong>投影</strong></p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220304215313954.png" class="" title="image-20220304215313954"><p><strong>a</strong>,<strong>b</strong>是两个向量，当有一束光垂直着向量<strong>a</strong>照射过来，那么向量<strong>b</strong>将会投出一个阴影在向量<strong>a</strong>上。</p><p>而投出阴影的这一段，就被称为向量<strong>b</strong>在向量<strong>a</strong>上的投影</p><ul><li>由于向量<strong>b</strong>投影在向量<strong>a</strong>上，那么该<strong>投影一定是沿着向量a方向</strong>。</li></ul><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220304215849895.png" class="" title="image-20220304215849895"><ul><li>所以只要求出k的值，就能得到向量<strong>b</strong>的投影</li></ul><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220304220034056.png" class="" title="image-20220304220034056"><ul><li>算出投影后 可以把该向量进行<strong>垂直与平行的分解</strong></li></ul><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220304220935323.png" class="" title="image-20220304220935323"><p><strong>判断两个向量的方向和接近程度</strong></p><ul><li><p>如果两个向量的点乘结果是<strong>正数</strong>，那么他们的方向<strong>基本一致</strong>，结果越接近1，就离得越近</p></li><li><p>如果两个向量的点乘结果是<strong>0</strong>，那么他们<strong>互相垂直</strong></p></li><li><p>如果两个向量的点乘结果是<strong>负数</strong>，那么他们的方向<strong>基本相反</strong>，结果越接近-1，就离得越远</p></li></ul><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220304222701553.png" class="" title="image-20220304222701553"><p><strong>总结</strong>：</p><ul><li>点乘最大的作用可以<strong>获得两个向量的夹角</strong></li><li>可以获取<strong>一个向量投影到另一个向量上的情况</strong></li><li><strong>判断两个向量的方向和接近程度</strong></li></ul><h4 id="向量的叉乘"><a href="#向量的叉乘" class="headerlink" title="向量的叉乘"></a>向量的叉乘</h4><p>概念：两个不同的向量叉乘后，会得出另一个<strong>向量</strong>，而这个向量必须垂直于原本的两个向量</p><blockquote><p>就是说两个向量叉乘后，得到了一个垂直于这两个向量的新向量</p></blockquote><ul><li>新向量一定是处于另一个平面</li></ul><p>通过右手螺旋定则判断新向量的方向</p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220304224117776.png" class="" title="image-20220304224117776"><ul><li><strong>a</strong>叉乘<strong>b</strong>，就是从<strong>a</strong>旋转到<strong>b</strong>方向，拇指对应的方向就是新向量的方向</li><li>而<strong>b</strong>叉乘<strong>a</strong>，就是从<strong>b</strong>旋转到<strong>a</strong>方向，所以叉乘并不满足交换律</li></ul><p>作用：</p><p>可以用叉乘建立一个三维空间直角坐标系</p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220304224441816.png" class="" title="image-20220304224441816"><p>在笛卡尔坐标系下的向量叉乘</p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220305230223210.png" class="" title="image-20220305230223210"><p>也可以把叉乘表示成矩阵形式</p><p>把向量<strong>a</strong>写成对应的一个矩阵，再去乘以对应的向量<strong>b</strong></p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220305230855071.png" class="" title="image-20220305230855071"><p><strong>作用</strong>：</p><p>1、<strong>判断一个向量在另一个向量的左或者右侧</strong></p><p>假设有两个向量<strong>a</strong>，<strong>b</strong>，通过两个向量的点乘就能判断向量<strong>b</strong>在<strong>a</strong>的左侧还是右侧</p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220305232620455.png" class="" title="image-20220305232620455"><ul><li>如果向量<strong>a</strong>乘以向量<strong>b</strong>，得到的<strong>z是正数</strong>，就说明<strong>b在a的左侧</strong>。反之，若z是负数，说明<strong>b在a的右侧</strong></li></ul><p>2、判断一个点，是否在三角形内部</p><p>假设有A,B,C三个点构成的向量，由逆时针排列</p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220305234450395.png" class="" title="image-20220305234450395"><ol><li>先看向量<strong>AB</strong>和<strong>AP</strong>，其叉乘结果向外，所以<strong>P点在AB的左侧</strong></li><li>做上述相同操作，用<strong>BC</strong>叉乘<strong>BP</strong>，得到<strong>P点仍在BC左侧</strong></li><li>最后用<strong>CA</strong>叉乘<strong>CP</strong>,得到<strong>P</strong>点依然在<strong>CA左侧</strong></li></ol><p>结论：</p><p>只要<strong>P点在三角形内部</strong>。就一定会在三条边的<strong>左边</strong>或者<strong>右边</strong></p><p>定义3D坐标系</p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220306000024580.png" class="" title="image-20220306000024580"><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p><strong>用来表示位置的变换</strong></p><h4 id="矩阵计算"><a href="#矩阵计算" class="headerlink" title="矩阵计算"></a><strong>矩阵计算</strong></h4><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220420223016770.png" class="" title="image-20220420222957423"><blockquote><ol><li>3×2的矩阵 乘以 2×4的矩阵，最后得到3×4的矩阵</li><li>如何确定矩阵中的元素，如新矩阵中的2行4列的值26。其实就是将第一个矩阵中的第2行和第二个矩阵中的第四列进行一个点积，就能得到新矩阵的值</li></ol></blockquote><p>总结：需要计算第几行第几列的值，就去找旧矩阵中的第几行和第几列，将两者的向量进行点积，得到的结果就是新矩阵中的值</p><h4 id="矩阵性质"><a href="#矩阵性质" class="headerlink" title="矩阵性质"></a><strong>矩阵性质</strong></h4><ul><li><p>矩阵的乘积不具备交换律</p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220420224631934.png" class="" title="image-20220420224631934"></li><li><p>但具备结合律和分配律</p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220420224655015.png" class="" title="image-20220420224655015"></li></ul><p><strong>矩阵和向量相乘</strong></p><p>向量可以看成(m×1)的矩阵，只要改矩阵为(? × m)，就可以实现矩阵和向量相乘</p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220420225138992.png" class="" title="image-20220420225138992"><p>通过该矩阵乘以(x,y)向量，就能按y轴进行对称操作</p><p><strong>矩阵的转置</strong></p><p>就是将矩阵原本的行列进行互换</p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220420225604441.png" class="" title="image-20220420225604441"><p>注意：</p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220420225742688.png" class="" title="image-20220420225742688"><blockquote><p>如果要对两个相乘的矩阵进行转置，就相当于先对后一个矩阵转置，再乘以前一个矩阵转置</p></blockquote><p><strong>单位矩阵</strong></p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220420225932456.png" class="" title="image-20220420225932456"><blockquote><p>单位矩阵，只有对角线上有非零元素</p></blockquote><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220420230138801.png" class="" title="image-20220420230138801"><blockquote><p>若两个矩阵相乘，得到一个单位矩阵，说明两个矩阵互逆</p></blockquote><hr><p><strong>向量点乘和叉乘写成矩阵形式</strong></p><p>点乘写成矩阵</p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220420230656135.png" class="" title="image-20220420230656135"><blockquote><p>a向量乘b向量，可以写成a转置乘b。即若a原本为列向量，转置后变为行向量。1行3列乘3行一列，就能得到一行一列，也就是一个数</p></blockquote><p>叉乘写成矩阵</p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220420231250963.png" class="" title="image-20220420231250963"><h2 id="Transformation-变换"><a href="#Transformation-变换" class="headerlink" title="Transformation(变换)"></a>Transformation(变换)</h2><p><strong>课程回顾</strong></p><ul><li>向量点乘</li></ul><blockquote><p>向量点乘的结果是一个数，可以用来判断另一个物体位置的前后</p><p>点乘结果为正，另一个物体在前方</p><p>点乘结果为负，另一个物体在后方</p></blockquote><ul><li>向量叉乘</li></ul><blockquote><p> 向量叉乘结果是一个新向量，可以用来判断另一个物体的相对左右关系</p><p>若新向量的结果大于0，根据右手定则判断，则另一个物体在左边</p><p>若新向量的结果小于0，根据右手定则判断，则另一个物体在右边</p></blockquote><ul><li>矩阵</li></ul><blockquote><p>用来表示位置的变换</p></blockquote><h3 id="2D-变换"><a href="#2D-变换" class="headerlink" title="2D 变换"></a>2D 变换</h3><h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220506220710135.png" class="" title="image-20220506220710135"><blockquote><p>如果将一个图片进行缩放，就是将其的x、y 坐标缩放s 倍。在数学上的形式就是：</p><p>x’ = sx;</p><p>y’ = sy;</p><p>若将这两个式子写成矩阵形式：</p></blockquote><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220506223318676.png" class="" title="image-20220506223318676"><blockquote><p>第一个矩阵是2行1列，第三个矩阵也是是2行一列，所以第二个矩阵就是2行2列，多出的用0补齐</p><p>这样的话也能满足</p><p>x‘ 是一行一列，它等于(s,0)向量和(x,y)向量的点乘，也就是sx</p><p>y’ 是二行一列，它等于(0,s)向量和(x,y)向量的点乘，也就是sy</p><p>所以这里的[s,0,0,s] 对角阵矩阵就被称为<strong>缩放矩阵</strong>，当s 等于0.5时，就对应着图像会缩放0.5倍</p></blockquote><p><strong>x、y不等比缩放</strong></p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220506224848203.png" class="" title="image-20220506224848203"><blockquote><p>对于x，y不等比缩放的情况，只需要将对角阵矩阵中的s对应修改就可以</p></blockquote><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220506225016005.png" class="" title="image-20220506225016005"><h4 id="对称"><a href="#对称" class="headerlink" title="对称"></a><strong>对称</strong></h4><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220506225212749.png" class="" title="image-20220506225212749"><blockquote><p>图片相对于y轴进行反转，就能得到相对于y轴的对称图形，数学形式表示如下</p><p>x’ = -x</p><p>y’ = y</p><p>若写成矩阵形式则表示如下</p></blockquote><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220506225840974.png" class="" title="image-20220506225840974"><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220506225943927.png" class="" title="image-20220506225943927"><blockquote><p>相当于拖着图片的上面那条边，向右沿着水平方向拖拽，图片发生形变。</p><p>由于是沿着水平方向拖拽，所以图片的y轴并没有发生改变</p><p>就能先得到y‘ = y</p><p>然后分析x轴，图片处于x轴坐标上的这条边位置变化为 0，而只有上面的边平移了a</p><p>也就是y = 0时 x轴变化为0，y = 1时 x变化为a，则水平方向移动了ay</p><p>所以能得到x’ = x + ay</p><p>用矩阵表示如下</p></blockquote><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220506231928622.png" class="" title="image-20220506231928622"><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220506232414740.png" class="" title="image-20220506232414740"><blockquote><p>当我们不说其它条件时，就是默认绕着<strong>原点</strong>(0,0)进行<strong>逆时针旋转</strong></p><p> 图像旋转后，原本(1,0)的点，变成了(cosθ,sinθ)</p><p>再通过矩阵的计算，可以得到旋转后的矩阵</p><p>cosθ -sinθ</p><p>sinθ cosθ</p></blockquote><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220608203553268.png" class="" title="image-20220608203553268"><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220608203705822.png" class="" title="image-20220608203705822"><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>上述的变换都可以写成x’ = ax + by      y‘ = cx + dy的形式</p><p>矩阵形式如下</p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220608204735340.png" class="" title="image-20220608204735340"><blockquote><p>如果我们可以把变换写成 一个矩阵去乘以一个输入的坐标，可以得到输出的坐标</p><p>那我们就将这种变换称为线性变换 </p><p>x‘ = M x</p><p>注意：这里需要用相同维度的矩阵去乘以该变量</p></blockquote><h3 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h3><p>当我们遇到一种特殊的变换时，就需要用到齐次坐标的概念</p><h4 id="平移变换"><a href="#平移变换" class="headerlink" title="平移变换"></a>平移变换</h4><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220608205900064.png" class="" title="image-20220608205900064"><blockquote><p>当图片进行平移时，数学形式的表示如下</p><p>x’ = x + tx</p><p>y’ = y + ty</p></blockquote><p>而平移变换的矩阵形式如下</p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220608210045660.png" class="" title="image-20220608210045660"><p>说明了<strong>平移矩阵并不属于线性变换</strong>，所以引入了齐次坐标来解决这个问题</p><h4 id="齐次坐标-1"><a href="#齐次坐标-1" class="headerlink" title="齐次坐标"></a>齐次坐标</h4><p>引入齐次坐标的目的就是为了<strong>将变换都能写成矩阵乘以向量的形式</strong></p><p>将二维的点或者向量，增加一个维度</p><ul><li><p>用(x,y,1)来表示二维的点</p></li><li><p>用(x,y,0)来表示二维的向量</p></li></ul><p>通过齐次坐标将平移写成了矩阵乘以向量的形式</p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220608211035843.png" class="" title="image-20220608211035843"><blockquote><p>注意：这里为什么要将向量和点进行区别对待</p><p>因为向量具有平移不变性，将一个向量平移到另一个地方，本质上还是那个向量</p></blockquote><p>在齐次坐标下，有以下概念</p><ul><li>向量 + 向量 = 向量</li><li>点 - 点 = 向量</li><li>点 + 向量 = 点</li><li>点 + 点 = 这两个点的中点</li></ul><h4 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h4><p>对于任何的一种变换若能写成<strong>线性变换加上平移</strong>，那么我们称之为仿射变换</p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220608211919859.png" class="" title="image-20220608211919859"><p>而所有的仿射变换，都能够写成齐次坐标的形式</p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220608211949391.png" class="" title="image-20220608211949391"><blockquote><p>如果我们用齐次坐标去表示二维的仿射变换</p><p>那么<strong>它的最后一行，一定是(0 0 1)</strong></p><p>平移的坐标一定是写在<strong>最后一列的头两个数</strong></p><p>然后剩余左边的<strong>2 × 2矩阵是 原来线性变换矩阵的值</strong></p></blockquote><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220608212353485.png" class="" title="image-20220608212353485"><p><strong>注意：</strong>只有用齐次坐标表示二维的仿射变换它的矩阵最后一行才是(0 0 1)</p><h3 id="其它变换"><a href="#其它变换" class="headerlink" title="其它变换"></a>其它变换</h3><h4 id="逆变换"><a href="#逆变换" class="headerlink" title="逆变换"></a>逆变换</h4><p>将一个操作的变换反过来，就被称为逆变换</p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220608212826148.png" class="" title="image-20220608212826148"><blockquote><p>逆变换在数学上所对应的<strong>乘以该变换的逆矩阵</strong></p><p><strong>一个矩阵乘以它的逆矩阵一定等于单位矩阵</strong></p></blockquote><h4 id="组合变换"><a href="#组合变换" class="headerlink" title="组合变换"></a>组合变换</h4><ul><li>复杂的变换可以通过简单的变换得到</li><li>变换过程种的先后顺序非常重要，会影响到变换结果</li></ul><p>假设，我们想要将得到下图</p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220608213248486.png" class="" title="image-20220608213248486"><p>若是先平移再进行旋转，则不能得到目标结果</p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220608213322952.png" class="" title="image-20220608213322952"><p>若是<strong>先旋转再平移</strong>，则能够得到目标结果</p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220608213355040.png" class="" title="image-20220608213355040"><blockquote><p>虽说上述两种方法做的单个事情一样，但组合后的顺序不一样，则得到的结果也不一样。</p><p>这个可以通过矩阵的乘法理解，变换就是在<strong>某个向量前乘以一个矩阵</strong>，若再变换一次，就再从前面乘以一个矩阵。</p><p>若矩阵相乘的顺序改变了，它不满足交换律，所以结果也改变了</p></blockquote><p><strong>组合矩阵的计算顺序</strong></p><p>当一个向量前面乘了多个矩阵，它会依次<strong>从右到左</strong>开始计算</p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220608214039269.png" class="" title="image-20220608214039269"><p>  <strong>变换的分解</strong></p><p>若我们不以原点进行旋转，而是以c点进行旋转，我们可以先将c点移动到原点上，再进行旋转，之后再平移回去</p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220608215600276.png" class="" title="image-20220608215600276"><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220608215740179.png" class="" title="image-20220608215740179"><h3 id="3D-变换"><a href="#3D-变换" class="headerlink" title="3D 变换"></a>3D 变换</h3><p>3D变换就是在2D变化的基础上增加了一个维度，与2D变换类似</p><p>3D 点 = (x,y,z,1)</p><p>3D 向量=(x,y,z,0)</p><p>三维空间中的齐次坐标表示仿射变换</p><img src="/blog/games101%E7%AC%94%E8%AE%B0/image-20220608220635005.png" class="" title="image-20220608220635005"><blockquote><p>规律和二维类型</p><p>最后一行是(0 0 0 1)</p><p>最后一列的头三个数表示</p><p>左边剩下的3×3矩阵就是三维空间中的线性变换</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 图形学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> games101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>static</title>
      <link href="blog/static/"/>
      <url>blog/static/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h2><p>在成员变量前，加上<strong>static</strong>关键字，那么它就会变成了静态成员变量，就<strong>不再属于栈上某个对象</strong>上的数据。而是存放静态常量区当中</p><blockquote><p>当我们创建多个对象时，每个对象都会在内存中创建相应的成员变量</p><p>而非静态成员变量只有一份，并且不在对象的内存中创建</p></blockquote><img src="/blog/static/image-20220503101214836.png" class="" title="image-20220503101214836"><h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><p>在成员函数前，加上static关键字。它就变成了静态成员函数。</p><blockquote><p>成员函数和静态成员函数都不在对象的内存中创建，不会因为创建多个对象而创建多个函数</p><p>静态成员函数没有this指针，所以不能访问对象上的非静态成员变量</p></blockquote><img src="/blog/static/image-20220503101132364.png" class="" title="image-20220503101132364"><ul><li>通过<strong>类名</strong>直接调用静态成员函数</li><li>通过<strong>对象</strong>调用</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>this指针总结</title>
      <link href="blog/this%E6%8C%87%E9%92%88/"/>
      <url>blog/this%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">int</span> a, <span class="keyword">char</span> b) :m_age(a), m_sex(b) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_age&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSex</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_sex&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">char</span> m_sex</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>,<span class="string">&#x27;男&#x27;</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="什么是this指针"><a href="#什么是this指针" class="headerlink" title="什么是this指针"></a>什么是this指针</h2><p>this指针是一种代称，它<strong>隐含</strong>在每个<strong>非静态成员函数</strong>内，它指向的是<strong>被调用成员函数所在的对象内存空间</strong></p><ul><li>this指针不需要定义，也不能定义，它能在成员函数中<strong>直接使用</strong></li></ul><blockquote><p>比如，在上述代码中构造函数 Person(int a, char b)，实际上是<strong>Person(this,int a, char b)</strong></p><p>也就是创建了一块名为p1的内存，然后this指向p1的起始位置，并且分配了4个字节的空间给m_age，1个字节的空间给m_sex</p><p>所以即使当形参与成员变量同名，也能清除的区分</p></blockquote><img src="/blog/this%E6%8C%87%E9%92%88/image-20220501211752269.png" class=""><h2 id="this指针的作用"><a href="#this指针的作用" class="headerlink" title="this指针的作用"></a>this指针的作用</h2><p>对象和成员函数之间，就是通过this指针连接的</p><img src="/blog/this%E6%8C%87%E9%92%88/image-20220503094001878.png" class="" title="image-20220503094001878"><blockquote><p>c1.real() 实际上是 complex::real(&amp;c1)</p><p>该过程就是因为成员函数中隐含了this指针，而c1又将地址放入了this指针当中。</p><p>所以，通过对象传入的地址不同，成员函数能够通过this指针，准确的调用其中的数据</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈、堆以及内存管理</title>
      <link href="blog/%E6%A0%88%E3%80%81%E5%A0%86%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>blog/%E6%A0%88%E3%80%81%E5%A0%86%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈(stack)"></a>栈(stack)</h2><p><strong>定义</strong>：</p><p>存在于某个<strong>作用域</strong>中的一块内存空间，一般<strong>定义的程序块</strong>运行时才存在</p><ul><li><strong>局部变量</strong></li><li><strong>函数参数</strong></li><li><strong>非static对象</strong></li></ul><p><strong>生命周期：</strong></p><p>栈的生命周期在<strong>作用域内</strong>，<strong>离开作用域</strong>后栈内的空间就会被<strong>自动清理</strong></p><blockquote><p>在对象前加上 static，就能将该对象的作用域提升到全局，这样它只有在程序结束时才会被清理</p></blockquote><hr><h2 id="什么是堆-Heap"><a href="#什么是堆-Heap" class="headerlink" title="什么是堆(Heap)"></a>什么是堆(Heap)</h2><p><strong>定义：</strong></p><p>由<strong>操作系统提供</strong>的一块内存空间，堆内的对象是<strong>动态分配</strong>的，而且要<strong>手动销毁</strong></p><ul><li>利用 <strong>new</strong> 创建对象。<strong>delete</strong> 销毁对象</li></ul><p><strong>生命周期：</strong></p><p>堆的生命周期和程序相同，若不及时用delete 清理堆中的内容，就会造成内存泄漏</p><blockquote><p><strong>内存泄漏</strong>：就是对该块内存失去控制</p><p>假设：void test(){Complex* p = new Complex；}</p><p>当作用域结束后，p所指的堆中的对象仍然存在，但指针p的生命周期却结束了</p><p>那就再也没有机会清理堆中的对象了</p><p>所以：指针p被清理之前，先delete堆中的对象</p></blockquote><hr><h2 id="new的内部操作"><a href="#new的内部操作" class="headerlink" title="new的内部操作"></a>new的内部操作</h2><p>当我们使用new 去创建任何一个对象的时候，都会<strong>先分配空间</strong>，再<strong>调用指针</strong>。编译器会将new分解成三个步骤</p><ol><li><strong>分配内存</strong>。通过调用<strong>operator new</strong> 在堆中分配一块内存空间，该函数在内部实际上会调用<strong>malloc()</strong></li><li>转型。将<strong>void指针</strong>类型<strong>转换</strong>为<strong>类指针</strong>类型</li><li><strong>构造函数</strong>。通过指针调用构造函数</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设：</span></span><br><span class="line">Complex* pc = <span class="keyword">new</span> Complex(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译器会将new分解成三个步骤</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、分配内存。</span></span><br><span class="line"><span class="keyword">void</span>* mem = <span class="keyword">operator</span> <span class="keyword">new</span>( <span class="keyword">sizeof</span>(Complex) );</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、转型</span></span><br><span class="line">pc = <span class="keyword">static_cast</span>&lt;Complex*&gt;(men);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、构造函数</span></span><br><span class="line">pc-&gt;Complex::Complex(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/blog/%E6%A0%88%E3%80%81%E5%A0%86%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220501170621562.png" class=""><blockquote><p>Complex* pc = new Complex(1,2)</p><p>就是在堆中开辟一个空间</p><p>然后用指针pc在空间中进行构造函数</p></blockquote><h2 id="delete的内部操作"><a href="#delete的内部操作" class="headerlink" title="delete的内部操作"></a>delete的内部操作</h2><p>使用delete时，它会<strong>先调用析构函数</strong>，然后<strong>再释放内存</strong></p><ol><li><strong>调用析构函数</strong>。<strong>删除对象内存中指针所指的数据</strong></li><li><strong>释放内存</strong>。通过调用<strong>operator delete()</strong> 函数，它内部会调用<strong>free()</strong>函数去<strong>删除对象本身</strong></li></ol><blockquote><p>注意：</p><p>析构函数清理的是对象内存中指针所指的数据，并不会清理对象本身</p><p>而operator delete 才是释放对象本身的内存</p></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> pc;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译器会转换为下面的步骤</span></span><br><span class="line">Complex::~Complex(pc);<span class="comment">//析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pc)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="new-一定要搭配-delete"><a href="#new-一定要搭配-delete" class="headerlink" title="new[] 一定要搭配 delete[]"></a>new[] 一定要搭配 delete[]</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String* p = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><blockquote><p>因为String类型中存放的是一个指针，若此时只用delete，就会造成内存泄漏</p><p>若使用的是delete，那么系统就不知道内存中有一个数组，它只会调用一次析构函数去删除String中的数据。之后调用operator delete()函数清理堆中内存时，还有其它的String没有析构，所以就会造成内存泄漏。</p><p>但若使用的是delete[],它就会调用多次析构函数。此时再清理堆中的内存，就不会造成内存泄漏</p></blockquote><img src="/blog/%E6%A0%88%E3%80%81%E5%A0%86%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220502224104827.png" class="" title="image-20220502224104827"><p><strong>总结：</strong></p><ul><li>如果通过new[ ]创建的对象内有<strong>指针</strong>，那就必须使用delete[]</li><li>若不使用delete[]，那么泄漏的内存不是堆中内存的对象本身，而是<strong>对象中指针所指的数据</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp-三大函数-侯捷</title>
      <link href="blog/Cpp-%E4%B8%89%E5%A4%A7%E5%87%BD%E6%95%B0-%E4%BE%AF%E6%8D%B7/"/>
      <url>blog/Cpp-%E4%B8%89%E5%A4%A7%E5%87%BD%E6%95%B0-%E4%BE%AF%E6%8D%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="三大函数：拷贝构造、拷贝赋值、析构"><a href="#三大函数：拷贝构造、拷贝赋值、析构" class="headerlink" title="三大函数：拷贝构造、拷贝赋值、析构"></a>三大函数：拷贝构造、拷贝赋值、析构</h2><p>字符串的本质：</p><blockquote><p>一般来说，字符串内只有一个<strong>指针</strong></p><p>当<strong>字符串初始化</strong>时，才会<strong>创建一个变量来存放字符本身</strong>，然后指针指向该变量。</p></blockquote><p><strong>手写String示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    String(<span class="keyword">const</span> <span class="keyword">char</span>* cstr = <span class="number">0</span>);<span class="comment">//String的默认构造函数</span></span><br><span class="line">    String(<span class="keyword">const</span> String&amp; str);<span class="comment">//拷贝构造，接收String对象</span></span><br><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; str);<span class="comment">//拷贝赋值</span></span><br><span class="line">    ~String();<span class="comment">//析构</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">get_c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> m_data;&#125;<span class="comment">//函数体内不改变data，函数名后面加const</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造函数声明在类外</span></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">String:: String(<span class="keyword">const</span> <span class="keyword">char</span>* cstr = <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cstr)&#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cstr)+<span class="number">1</span>];<span class="comment">//strlen()获取传入字符的长度</span></span><br><span class="line">        <span class="built_in">strcpy</span>(m_data,cstr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//字符串未指定初值，为空字符串</span></span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">        *m_data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">String::String(<span class="keyword">const</span> String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">m_data = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];<span class="comment">//在堆中申请空间</span></span><br><span class="line"><span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝赋值</span></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str)<span class="comment">//检测自我赋值，</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">delete</span>[] m_data;</span><br><span class="line">m_data = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line"><span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">String:: ~String()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data; <span class="comment">//删除存放字符的变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">String <span class="title">s1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">s2</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">s3</span><span class="params">(s2)</span></span>;<span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    String s3 = s2;<span class="comment">//调用拷贝赋值函数</span></span><br><span class="line">    </span><br><span class="line">    String* p = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h3><p>当类的成员中<strong>包含指针</strong>，那么就必须<strong>重写拷贝构造函数</strong>，在堆区申请空间。否则就会产生<strong>两个指针指向同一块内存区域</strong>的问题，这也就是<strong>深浅拷贝</strong>问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span></span><br><span class="line">String::String(<span class="keyword">const</span> String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">m_data = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];<span class="comment">//在堆中申请空间</span></span><br><span class="line"><span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>浅拷贝</strong>：编译器调用了默认的拷贝构造函数</p><ul><li>首先 浅拷贝只是拷贝了一个<strong>指针</strong>，并<strong>没有新开辟一块地址</strong></li><li>所以 就导致了新对象拷贝过来的指针和原对象的指针<strong>指向同一块地址</strong></li><li>最后 就会造成<strong>资源重复释放的错误</strong></li></ul><p><strong>深拷贝</strong>：<strong>重写拷贝构造函数</strong>，在<strong>堆区申请空间</strong></p><ul><li>而深拷贝则是在<strong>堆区新开辟了一个内容空间</strong>，让新对象的<strong>指针指向新开辟的空间</strong></li><li>这样即使原对象被析构掉，也不会影响到新对象所得到的值</li></ul><h3 id="拷贝赋值"><a href="#拷贝赋值" class="headerlink" title="拷贝赋值"></a>拷贝赋值</h3><p>若存在a = b，则会调用拷贝赋值操作</p><ul><li>首先 清理a的内存空间</li><li>然后 根据b的内存空间大小，给a分配相同的空间</li><li>最后 将b中的数据拷贝到a中</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str)<span class="comment">//检测自我赋值</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">delete</span>[] m_data;</span><br><span class="line">m_data = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line"><span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>检测自我赋值很关键，若真的存在两个对象的指针指向同一块内存，那么就直接返回</p><p>否则后续将会产生不确定性</p></blockquote><img src="/blog/Cpp-%E4%B8%89%E5%A4%A7%E5%87%BD%E6%95%B0-%E4%BE%AF%E6%8D%B7/image-20220429145226508.png" class="" title="image-20220429145226508">]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="blog/%E7%AE%97%E6%B3%95/"/>
      <url>blog/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><img src="/blog/%E7%AE%97%E6%B3%95/image-20220429164520442.png" class="" title="image-20220429164520442"><blockquote><p>head-&gt;next 是<strong>根据head指针域的地址访问下一个节点</strong></p><p>也就能通过 head-&gt;next-&gt;val 访问下一个节点的数据</p><p>还能通过 head-&gt;next-&gt;next 根据下一个节点的指针域地址访问下下个节点</p></blockquote><h2 id="基本技能"><a href="#基本技能" class="headerlink" title="基本技能"></a>基本技能</h2><p>链表相关的核心点。遇到链表相关题型，最好能够画出来</p><ul><li>dummy node 虚拟节点</li></ul><blockquote><p>当涉及到头节点可能被删除的问题，就需要引入一个虚拟节点，作为整个链表的虚拟头结点</p><p>而指向虚拟头结点的指针就可以认为是连接整个链表的“针”</p></blockquote><ul><li>快慢指针</li><li>插入一个节点到排序链表</li><li>从链表中移除一个节点</li><li>反转链表</li></ul><blockquote><p>元素位置不变，完成链表指向的反转</p></blockquote><ul><li>合并两个链表</li><li>找到链表的中间节点</li></ul><h2 id="常见题型"><a href="#常见题型" class="headerlink" title="常见题型"></a>常见题型</h2><h3 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h3><p>给定一个已排序的链表的头 <code>head</code> ，删除所有重复的元素，使每个元素只能出现一次，返回已经排序的链表</p><blockquote><p>思路：</p><p>由于链表已经排好序，所以可以比较两个相邻的节点，然后指向相同节点的后一个节点。</p><p>这样就能保证在删除重复元素时，还能使每个元素出现一次</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span><span class="comment">//定义链表节点的结构体</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;<span class="comment">//链表为空</span></span><br><span class="line">            <span class="keyword">return</span> head;    <span class="comment">//直接返回空表</span></span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val == cur-&gt;next-&gt;val)&#123;</span><br><span class="line">                ListNode* temp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;<span class="comment">//删除节点后，伴随着指针下一个节点的变化</span></span><br><span class="line">                <span class="keyword">delete</span> temp;<span class="comment">//手动删除内存</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur-&gt;next;<span class="comment">//遍历链表</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></h3><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除原始链表中所有重复数字的节点，只留下不同的数字</em> 。返回 <em>已排序的链表</em> 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span><span class="comment">//定义链表节点的结构体</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当链表的节点个数小于2，就不会发生删除节点的操作，所以直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//虚拟节点</span></span><br><span class="line">        dummyHead-&gt;next = head;<span class="comment">//虚拟节点指向头结点，充当虚拟头节点</span></span><br><span class="line">        ListNode* cur = dummyHead;<span class="comment">//指向虚拟头结点的头指针</span></span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next)&#123;<span class="comment">//存在两个相邻的节点</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next-&gt;val == cur-&gt;next-&gt;next-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = cur-&gt;next-&gt;val;<span class="comment">//记录链表中出现的重复数字</span></span><br><span class="line">                <span class="keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val ==x)&#123; <span class="comment">//当头指针的下一个节点存在并且该值是重复数字</span></span><br><span class="line">                    ListNode* temp = cur-&gt;next;</span><br><span class="line">                    cur-&gt;next = cur-&gt;next-&gt;next;<span class="comment">//删除该链表</span></span><br><span class="line">                    <span class="keyword">delete</span> temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur-&gt;next;<span class="comment">//b</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h3><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><blockquote><p>思路：</p><p>通过修改节点的指向操作，来达到反转链表的目标。图片如下</p></blockquote><img src="/blog/%E7%AE%97%E6%B3%95/image-20220503230847048.png" class="" title="image-20220503230847048"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span><span class="comment">//定义链表节点的结构体</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//双指针        </span></span><br><span class="line">        ListNode* cur = <span class="literal">NULL</span>;<span class="comment">//存放上一个节点的指针</span></span><br><span class="line">        ListNode* pre = head;<span class="comment">//定义遍历指针，用来结束遍历</span></span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            ListNode* temp = pre-&gt;next;<span class="comment">//存放下一个节点的指针，以免找不到后续链表</span></span><br><span class="line">            pre-&gt;next = cur;<span class="comment">//当前指针指向上一个节点</span></span><br><span class="line">            cur = pre;<span class="comment">//移动上一个节点指针，更新需要被连接的上一个节点地址</span></span><br><span class="line">            pre = temp;         <span class="comment">//移动当前指针，更新当前节点的地址</span></span><br><span class="line">        &#125;</span><br><span class="line">        head = cur;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h3><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p><blockquote><p>思路：</p><p>1、由于是反转链表子区间，所以必须要记录该区间的<strong>前驱节点</strong>和<strong>后继节点</strong></p><p>2、链表子区间从链表中移除，就变成了反转整个子区间链表问题。所以还要记录<strong>left</strong>和<strong>righ</strong>节点</p><p>3、最后用前驱节点指向left节点，right节点指向后继节点</p></blockquote><img src="/blog/%E7%AE%97%E6%B3%95/image-20220506160317656.png" class="" title="image-20220506160317656"><img src="/blog/%E7%AE%97%E6%B3%95/image-20220506161151458.png" class="" title="image-20220506161151458"><img src="/blog/%E7%AE%97%E6%B3%95/image-20220506161202698.png" class="" title="image-20220506161202698"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span><span class="comment">//定义链表节点的结构体</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、头节点可能改变，添加虚拟头节点</span></span><br><span class="line">        ListNode* dummyNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);        </span><br><span class="line">        dummyNode-&gt;next = head;</span><br><span class="line">        <span class="keyword">auto</span> pre = dummyNode;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2、找到left的前驱节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> leftNode = pre-&gt;next;<span class="comment">//得到left节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3、找到right的后继节点</span></span><br><span class="line">        <span class="keyword">auto</span> rightNode = pre;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; right - left + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            rightNode = rightNode-&gt;next;<span class="comment">//得到了right节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> cur = rightNode-&gt;next;<span class="comment">//得到right的后继节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4、切断需要反转的链表</span></span><br><span class="line">        pre-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        rightNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5、同206题，反转链表的子区间</span></span><br><span class="line">        ListNode* h = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* leftPtr = leftNode;</span><br><span class="line">        <span class="keyword">while</span>(leftPtr != <span class="literal">NULL</span> )&#123;          </span><br><span class="line">            <span class="keyword">auto</span> temp = leftPtr-&gt;next;</span><br><span class="line">           leftPtr-&gt;next = h;</span><br><span class="line">            h = leftPtr;</span><br><span class="line">            leftPtr = temp;           </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6、连接已经完成反转的链表子区间</span></span><br><span class="line">        pre-&gt;next = rightNode;</span><br><span class="line">        leftNode-&gt;next = cur;                </span><br><span class="line">        <span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h3><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><img src="/blog/%E7%AE%97%E6%B3%95/image-20220608151244183.png" class="" title="image-20220608151244183"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2</span><br><span class="line">输出：[2,1,4,3,5]</span><br></pre></td></tr></table></figure><blockquote><p>方法：递归</p><p>思路：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *int val;</span></span><br><span class="line"><span class="comment"> *struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">//1、设置尾结点,将头结点和尾结点当作一组</span></span><br><span class="line">        ListNode* tail = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="comment">//如果不足k时，到达了链表尾，则直接返回，不进行翻转</span></span><br><span class="line">            <span class="keyword">if</span>(tail == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2、设置反转所需的当前结点和上一个结点</span></span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur != tail)&#123;</span><br><span class="line">            ListNode* temp  = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3、反转后head变为了尾结点，用来连接下一组</span></span><br><span class="line">        head-&gt;next = reverseKGroup(tail,k);</span><br><span class="line">        <span class="keyword">return</span> pre;<span class="comment">//全部反转完毕后，pre就是头结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h3><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><blockquote><p>思路：</p><p>1、需要添加一个虚拟头节点，用来确定合并后升序链表的头节点</p><p>2、在两个链表都不为空的情况下，不断比较list1链表和list2链表当中的最小元素，然后通过cur指针将两个链表连接起来</p><p>3、最后当有一个链表为空时，就可以直接连接到另外一个链表</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span><span class="comment">//定义链表节点的结构体</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//1、虚拟头节点</span></span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(list1 &amp;&amp; list2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1-&gt;val &lt; list2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有一个链表全部合并后将会退出循环，这时就可以将另一个链表直接连到后面</span></span><br><span class="line">        cur-&gt;next = list1 == <span class="literal">nullptr</span> ? list2 : list1;   <span class="comment">//如果list1链表为空，那就直接连接到list2链表，反之则连接到list1</span></span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a><a href="https://leetcode.cn/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></h3><p>给定一个头结点为 <code>head</code> 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><blockquote><p>思路：通过快指针fast 和慢指针slow一起遍历链表</p><p>1、slow一次走一步，fast一次走两步</p><p>2、当fast到达链表末尾时，slow必然位于中间</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a><a href="https://leetcode-cn.com/problems/partition-list/">86. 分隔链表</a></h3><p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 <strong>小于</strong> x 的节点都出现在 <strong>大于或等于</strong> x 的节点之前。</p><p>你应当 保留 两个分区中每个节点的初始相对位置。</p><blockquote><p>思路1：找到第一个大于等于x的节点 往它前面按顺序插入后面碰到的小于x的节点</p><p>1、利用虚拟头结点确定头节点的位置</p><p>2、利用指向虚拟头结点的链表指针进行移动</p><p>3、将合适的”边界”节点设置为哨兵</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x),next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、设置虚拟头节点</span></span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* h = dummyHead;</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、找到第一个大于或等于x的节点，特定节点之后所有的节点都会插入到前面</span></span><br><span class="line">        <span class="keyword">while</span>(h-&gt;next &amp;&amp; h-&gt;next-&gt;val &lt; x)&#123;</span><br><span class="line">            h = h-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3、哨兵p是插入节点的前驱节点，会随着节点的插入而改变。q是插入节点的后继节点</span></span><br><span class="line">        <span class="keyword">auto</span> p = h;</span><br><span class="line">        <span class="keyword">auto</span> q = h-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、链表指针h移动,将小于x的节点插入到哨兵p，q之间</span></span><br><span class="line">        <span class="keyword">while</span>(h-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(h-&gt;next-&gt;val &lt; x)&#123;</span><br><span class="line">                <span class="keyword">auto</span> temp = h-&gt;next-&gt;next;<span class="comment">//插入之前要先记录后面节点的地址</span></span><br><span class="line">                p-&gt;next = h-&gt;next;<span class="comment">//哨兵p指向该节点</span></span><br><span class="line">                h-&gt;next-&gt;next = q; <span class="comment">//该节点指向哨兵q。这两步就完成了节点的插入</span></span><br><span class="line">                p = p-&gt;next;<span class="comment">//移动哨兵p，方便插入新节点</span></span><br><span class="line">                h-&gt;next = temp;<span class="comment">//将链表连接到下一个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                h = h-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>思路二：以特定值x为分界，通过两个虚拟节点，依次将小于x的节点重新连成一个链表l1，又将大于或等于x的节点连成另外一个链表l2。最后链表l1 连接到链表l2即可</p><p>1、分别创建虚拟节点dummyHead1、dummyHead2和指向他们的指针dh1、dh2</p><p>2、创建指向链表头节点的移动指针h。</p><p>3、移动指针h遍历链表，将小于x 的结点用dh1连接成新链表。将大于或等于x 的结点用dh2连接成另一条新链表。h遍历完链表后，就将它以x为分界一分为二。</p><p>4、最后再将两条排序好的链表合二为一，返回dummyHead1指向的节点即可</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、虚拟节点</span></span><br><span class="line">        ListNode* dummyHead1 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* dh1 = dummyHead1;</span><br><span class="line">        </span><br><span class="line">        ListNode* dummyHead2 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* dh2 = dummyHead2;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2、移动指针</span></span><br><span class="line">        <span class="keyword">auto</span> h = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、移动指针遍历链表</span></span><br><span class="line">        <span class="keyword">while</span>(h)&#123;</span><br><span class="line">            <span class="keyword">if</span>(h-&gt;val &lt; x)&#123;</span><br><span class="line">                dh1-&gt;next = h;</span><br><span class="line">                dh1 = dh1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dh2-&gt;next = h;</span><br><span class="line">                dh2 = dh2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            h = h-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//4、合并链表</span></span><br><span class="line">        dh1-&gt;next = dummyHead2-&gt;next; <span class="comment">//让dh1链表的尾节点指向dh2链表的头节点</span></span><br><span class="line">        dh2-&gt;next = <span class="literal">NULL</span>;<span class="comment">//dh2链表的尾节点置空，断开与原链表的连接</span></span><br><span class="line">        <span class="keyword">return</span> dummyHead1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：</p><ul><li><p>方法1效率低，占用内存低</p></li><li><p>方法2效率高，占用内存高</p></li></ul><h3 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></h3><p>在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序。请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong></p><blockquote><p>思路：时间复杂度是 O(n log n) 的排序算法包括<strong>归并排序</strong>、<strong>堆排序</strong>和<strong>快速排序</strong>（快速排序的最差时间复杂度是 O(n^2)，其中最适合链表的排序算法是<strong>归并排序</strong></p><p>1、通过快慢指针，找到链表的中点，以中点为界，将链表拆分成两个子链表</p><p>2、对两个子链表分别排序</p><p>3、将排完序后的子链表合并</p></blockquote><h3 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a href="https://leetcode.cn/problems/reorder-list/">143. 重排链表</a></h3><p>给定一个单链表 L 的头节点 head ，单链表 L 表示为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L0 → L1 → … → Ln - 1 → Ln</span><br></pre></td></tr></table></figure><p>请将其重新排列后变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</span><br></pre></td></tr></table></figure><blockquote><p>思路：目标链表是原链表的左边和反转后的右边串起来的结果</p><p>找中点+反转后半部分+合并前后两部分</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;       </span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* mid = middleNode(head);<span class="comment">//找中点</span></span><br><span class="line">        </span><br><span class="line">        ListNode* l1 = head;        <span class="comment">//链表1</span></span><br><span class="line">        ListNode* l2 = mid-&gt;next;   <span class="comment">//链表2</span></span><br><span class="line">        mid-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//断开中点</span></span><br><span class="line">        </span><br><span class="line">        l2 = reverseList(l2);   <span class="comment">//反转l2链表，并更新头结点</span></span><br><span class="line"></span><br><span class="line">        mergeList(l1,l2);   <span class="comment">//合并l1和反转后的l2</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1、快慢指针找中点</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next !=<span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;               </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、反转l2链表</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode* per = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            ListNode* temp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = per;</span><br><span class="line">            per = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> per; <span class="comment">//返回当前链表头结点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、合并链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeList</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//记录原链表l1下个地址</span></span><br><span class="line">            ListNode* l1_temp = l1-&gt;next;</span><br><span class="line">            <span class="comment">//记录原链表l2下个地址         </span></span><br><span class="line">            ListNode* l2_tmep = l2-&gt;next;</span><br><span class="line"></span><br><span class="line">            l1-&gt;next = l2;</span><br><span class="line">            l1 = l1_temp;</span><br><span class="line"></span><br><span class="line">            l2-&gt;next = l1;</span><br><span class="line">            l2 = l2_tmep;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h3><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><blockquote><p>思路：通过快慢指针的方法来判断，若链表中没有环，则快指针一定在慢指针前面。若有环，则它们一定会在某一时刻相遇</p><p>细节：这里的慢指针要在head，而快指针要在head-&gt;next</p><p>若快慢指针都在head，则一开始就相遇了，会直接退出while循环</p><p>1、先判断链表为空的情况</p><p>2、设置快慢指针</p><p>3、当快慢指针不相等，如果快指针提前为空了，说了链表已经“跑完”，则不为环形链表。否则将继续“跑下去”，直到相遇为止</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//若链表为空，或只有一个结点，则不可能有环</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* fast = head-&gt;next;<span class="comment">//快指针</span></span><br><span class="line">        ListNode* slow = head;<span class="comment">//慢指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="BM7-链表中环的入口结点"><a href="#BM7-链表中环的入口结点" class="headerlink" title="BM7 链表中环的入口结点"></a><a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=295&amp;tqId=23449&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=%2Fexam%2Foj">BM7 链表中环的入口结点</a></h3><p>给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。</p><blockquote><p>方法：快慢指针</p><p>思路：</p><p>1、先判断链表是否为空</p><p>2、判断链表有没有环</p><p>3、用慢指针接收，没有环，则直接返回空。若有环，则记录慢指针的位置</p><p>4、将快指针回到头结点，让快慢指针同时移动一个结点，直到相遇时就能找到入口</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//判断有没有环，返回相遇的地方</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123; </span><br><span class="line">        <span class="comment">//先判断链表为空的情况</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//快慢双指针</span></span><br><span class="line">        ListNode* fast = head; </span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="comment">//如果没环快指针会先到链表尾</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)&#123; </span><br><span class="line">            <span class="comment">//快指针移动两步</span></span><br><span class="line">            fast = fast-&gt;next-&gt;next; </span><br><span class="line">            <span class="comment">//慢指针移动一步</span></span><br><span class="line">            slow = slow-&gt;next; </span><br><span class="line">            <span class="comment">//相遇则有环</span></span><br><span class="line">            <span class="keyword">if</span>(fast == slow) </span><br><span class="line">                <span class="comment">//返回相遇的地方</span></span><br><span class="line">                <span class="keyword">return</span> slow; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//到末尾则没有环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = hasCycle(pHead);</span><br><span class="line">        <span class="comment">//没有环</span></span><br><span class="line">        <span class="keyword">if</span>(slow == <span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//快指针回到表头</span></span><br><span class="line">        ListNode* fast = pHead; </span><br><span class="line">        <span class="comment">//再次相遇即是环入口</span></span><br><span class="line">        <span class="keyword">while</span>(fast != slow)&#123; </span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a><a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h3><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><blockquote><p>思路：</p><p>1、先遍历出链表的总长度n</p><p>2、若链表长度n小于k，则返回空</p><p>3、通过n-k找到倒数第k个结点</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pHead, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、算出链表n的长度</span></span><br><span class="line">        ListNode* tail = pHead;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(tail != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n &lt; k)&#123;    <span class="comment">//若链表长度小于倒数第k个结点，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2、通过n-k找到倒数第k个结点的</span></span><br><span class="line">        ListNode* cur = pHead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - k; i++)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="BM9-删除链表的倒数第n个节点"><a href="#BM9-删除链表的倒数第n个节点" class="headerlink" title="BM9 删除链表的倒数第n个节点"></a>BM9 删除链表的倒数第n个节点</h3><p>给定一个链表，删除链表的倒数第 n 个节点并返回链表的头指针</p><blockquote><p>思路：</p><p>1、要考虑可能会删除头节点，所以引入虚拟节点</p><p>2、遍历链表，求出链表的长度len</p><p>3、以len - n为条件开始遍历，就能定位到倒数第n个节点的前一个结点</p><p>4、最后用倒数第n个结点的前一个结点指向后一个结点，然后返回虚拟头节点的下一个结点</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1、可能会删除头结点，所以引入虚拟结点</span></span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* tail = dummyHead;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2、遍历链表的长度</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;<span class="comment">//</span></span><br><span class="line">        <span class="keyword">while</span>(tail != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            tail = tail-&gt;next;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3、移动到要删除结点的前一个结点</span></span><br><span class="line">        tail = dummyHead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - n; i++)&#123;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* temp = tail-&gt;next-&gt;next;    <span class="comment">//记录要删除结点的后一个结点</span></span><br><span class="line">        tail-&gt;next = temp;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="BM11-链表相加"><a href="#BM11-链表相加" class="headerlink" title="BM11 链表相加"></a>BM11 链表相加</h3><p>假设链表中每一个节点的值都在 0 - 9 之间，那么链表整体就可以代表一个整数。</p><p>给定两个这种链表，请生成代表两个整数相加值的结果链表。</p><blockquote><p>方法：反转链表</p><p>思路：</p><p>1、如果有链表为空，则直接返回另一个链表</p><p>2、反转两个链表</p><p>3、为相加后的链表创建表头，并记录进位符</p><p>4、只要链表还存在，或进位符存在，就取出链表中结点的值，与进位符进行相加</p><p>5、 carry = temp / 10重置进位符，以及temp %= 10 对相加结果取余</p><p>6、将结果添加到新创建的链表中</p><p>7、移动两个链表中各自的结点，进行下一个结点计算</p><p>8、最后反转新建链表</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* per = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            ListNode* temp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = per;</span><br><span class="line">            per = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> per;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">addInList</span><span class="params">(ListNode* head1, ListNode* head2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head1 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head2 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head1;</span><br><span class="line">        &#125;</span><br><span class="line">        head1 = ReverseList(head1);</span><br><span class="line">        head2 = ReverseList(head2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//为相加后的链表添加表头</span></span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* head = dummyHead;</span><br><span class="line">        <span class="comment">//记录进位符</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head1 != <span class="literal">NULL</span> || head2 != <span class="literal">NULL</span> || carry != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//链表不为空则取值</span></span><br><span class="line">            <span class="keyword">int</span> val1 = head1 == <span class="literal">NULL</span> ? <span class="number">0</span> : head1-&gt;val;</span><br><span class="line">            <span class="keyword">int</span> val2 = head2 == <span class="literal">NULL</span> ? <span class="number">0</span> : head2-&gt;val;</span><br><span class="line">            <span class="comment">//相加</span></span><br><span class="line">            <span class="keyword">int</span> temp = val1 + val2 + carry;</span><br><span class="line">            carry = temp / <span class="number">10</span>;</span><br><span class="line">            temp %= <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//添加元素</span></span><br><span class="line">            head-&gt;next = <span class="keyword">new</span> ListNode(temp);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="comment">//移动两个链表到下一个结点</span></span><br><span class="line">            <span class="keyword">if</span>(head1 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                head1 = head1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(head2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                head2 = head2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="comment">//反转结果</span></span><br><span class="line">        <span class="keyword">return</span> ReverseList(dummyHead-&gt;next);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="BM12-单链表排序"><a href="#BM12-单链表排序" class="headerlink" title="BM12 单链表排序"></a>BM12 单链表排序</h3><p>给定一个节点数为n的无序单链表，对其按升序排序。时间复杂度为<em>O</em>(<em>n<strong>l</strong>o<strong>g</strong>n</em>)</p><blockquote><p>方法：归并排序</p><p>思路：</p><ul><li>step 1：首先判断链表为空或者只有一个元素，直接就是有序的。</li><li>step 2：准备三个指针，快指针right每次走两步，慢指针mid每次走一步，前序指针left每次跟在mid前一个位置。三个指针遍历链表，当快指针到达链表尾部的时候，慢指针mid刚好走了链表的一半，正好是中间位置。</li><li>step 3：从left位置将链表断开，刚好分成两个子问题开始递归。</li><li>step 4：将子问题得到的链表合并</li></ul><p>其中递归的三个条件</p><ul><li><strong>终止条件：</strong> 当子链表划分到为空或者只剩一个节点时，不再继续划分，往上合并。</li><li><strong>返回值：</strong> 每次返回两个排好序且合并好的子链表。</li><li><strong>本级任务：</strong> 找到这个链表的中间节点，从前面断开，分为左右两个子链表，进入子问题排序。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//合并两段有序链表</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span> </span>&#123; </span><br><span class="line">        <span class="comment">//一个已经为空了，直接返回另一个</span></span><br><span class="line">        <span class="keyword">if</span>(pHead1 == <span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">if</span>(pHead2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        <span class="comment">//加一个表头</span></span><br><span class="line">        ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">0</span>); </span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="comment">//两个链表都要不为空</span></span><br><span class="line">        <span class="keyword">while</span>(pHead1 &amp;&amp; pHead2)&#123; </span><br><span class="line">            <span class="comment">//取较小值的节点</span></span><br><span class="line">            <span class="keyword">if</span>(pHead1-&gt;val &lt;= pHead2-&gt;val)&#123; </span><br><span class="line">                cur-&gt;next = pHead1;</span><br><span class="line">                <span class="comment">//只移动取值的指针</span></span><br><span class="line">                pHead1 = pHead1-&gt;next; </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = pHead2;</span><br><span class="line">                <span class="comment">//只移动取值的指针</span></span><br><span class="line">                pHead2 = pHead2-&gt;next; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//指针后移</span></span><br><span class="line">            cur = cur-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//哪个链表还有剩，直接连在后面</span></span><br><span class="line">        <span class="keyword">if</span>(pHead1) </span><br><span class="line">            cur-&gt;next = pHead1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur-&gt;next = pHead2;</span><br><span class="line">        <span class="comment">//返回值去掉表头</span></span><br><span class="line">        <span class="keyword">return</span> head-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">sortInList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//链表为空或者只有一个元素，直接就是有序的</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* left = head; </span><br><span class="line">        ListNode* mid = head-&gt;next;</span><br><span class="line">        ListNode* right = head-&gt;next-&gt;next;</span><br><span class="line">        <span class="comment">//右边的指针到达末尾时，中间的指针指向该段链表的中间</span></span><br><span class="line">        <span class="keyword">while</span>(right != <span class="literal">NULL</span> &amp;&amp; right-&gt;next != <span class="literal">NULL</span>)&#123; </span><br><span class="line">            left = left-&gt;next;</span><br><span class="line">            mid = mid-&gt;next;</span><br><span class="line">            right = right-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左边指针指向左段的左右一个节点，从这里断开</span></span><br><span class="line">        left-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line">        <span class="comment">//分成两段排序，合并排好序的两段</span></span><br><span class="line">        <span class="keyword">return</span> merge(sortInList(head), sortInList(mid)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h3><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><h3 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></h3><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><blockquote><p>思路：快慢指针。将链表后半部分反转，然后依次和前半部分比较</p><p>1、找到链表的中点</p><p>2、反转链表后半部分</p><p>3、判断是否回文</p><p>4、返回结果</p><p>这里需要注意</p><p>当原链表为偶数，那么断开后的链表长度一样，则可能是回文链表。</p><p>当原链表为奇数时，那么后半部分链表必然比前半部分多一个结点，则肯定不是回文链表</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1、找中点</span></span><br><span class="line">        ListNode* fast = head-&gt;next;<span class="comment">//这里不是fast = head</span></span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="comment">//方便下面能在偶数个结点时，取到前面的zhong&#x27;dian</span></span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、反转后半部分链表</span></span><br><span class="line">        ListNode* cur = slow-&gt;next;</span><br><span class="line">        ListNode* per = <span class="literal">NULL</span>;       </span><br><span class="line">        slow-&gt;next = <span class="literal">NULL</span>;    <span class="comment">//断开中点</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            ListNode* temp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = per;</span><br><span class="line">            per = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、比较两个链表，判断是否回文        </span></span><br><span class="line">        ListNode* l1 = head;</span><br><span class="line">        ListNode* l2 = per;</span><br><span class="line">        <span class="keyword">bool</span> result = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//l2的长度一定大于或等于l1</span></span><br><span class="line">        <span class="keyword">while</span>(result &amp;&amp; l2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val != l2-&gt;val)&#123;</span><br><span class="line">                result = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="二分查找-排序"><a href="#二分查找-排序" class="headerlink" title="二分查找/排序"></a>二分查找/排序</h1><h3 id="BM17二分查找"><a href="#BM17二分查找" class="headerlink" title="BM17二分查找"></a><a href="https://www.nowcoder.com/practice/d3df40bd23594118b57554129cadf47b?tpId=295&amp;tqId=1499549&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=%2Fexam%2Foj">BM17二分查找</a></h3><p>请实现无重复数字的升序数组的二分查找</p><blockquote><p>思路：二分查找</p><p>方法：</p><p>1、low = 0，high = nums.size() - 1;</p><p>2、low &lt;= high , mid = low + (high - low) / 2</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="BM18-二维数组中的查找"><a href="#BM18-二维数组中的查找" class="headerlink" title="BM18 二维数组中的查找"></a><a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=295&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=0&amp;sourceUrl=%2Fexam%2Foj">BM18 二维数组中的查找</a></h3><p>在一个二维数组array中（每个一维数组的长度相同），每一行都按照<strong>从左到右递增</strong>的顺序排序，每一列都按照从<strong>上到下递增</strong>的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数</p><blockquote><p>思路1：左上与右下肯定是最小值和最大值。所以从左下角为起点，</p><p>若当前值小于目标值，就可以往右边找</p><p>若当前值大于目标值，就可以往上边找</p><p>方法：</p><p>1、首先获取矩阵的两个边长，判断特殊情况</p><p>2、从左下角为起点，若是它小于目标元素，则往右移动去找大的，若它小于目标元素，则往上移动去找小的</p><p>3、若移动到了矩阵边界都没找到，说明不存在目标值</p><p>时间复杂度：O(m+n)</p><p>空间复杂度：O(1)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果二维数组行中中没有元素，则直接返回false</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录数组行中元素个数</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">array</span>.size();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果二维数组列中没有元素，则直接返回false</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[<span class="number">0</span>].size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录数组列中的元素个数</span></span><br><span class="line">        <span class="keyword">int</span> m = <span class="built_in">array</span>[<span class="number">0</span>].size();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//i代表行，j代表列</span></span><br><span class="line">        <span class="keyword">int</span> i = n - <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( i &gt;= <span class="number">0</span> &amp;&amp; j &lt; m )&#123;</span><br><span class="line">            <span class="comment">//当前值大于目标值，就往上找</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i][j] &gt; target)&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前值小于目标值，就往右找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[i][j] &lt; target)&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;               </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="BM19-寻找峰值"><a href="#BM19-寻找峰值" class="headerlink" title="BM19 寻找峰值"></a><a href="https://www.nowcoder.com/practice/fcf87540c4f347bcb4cf720b5b350c76?tpId=295&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=0&amp;sourceUrl=%2Fexam%2Foj"><strong>BM19</strong> <strong>寻找峰值</strong></a></h3><p>给定一个长度为n的数组nums，请你找到峰值并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个所在位置即可。</p><blockquote><p>思路：</p><p>因为寻找的是峰值，那么数组的两端就不可能形成山峰</p><p>所以可以把它们当作其中一端，然后不断往高处走</p><p>直到找到下一个点不能再高时，就找到了最高峰</p><p>方法：</p><p>1、二分查找确定中间值</p><p>2、如果中间值大于右边的元素，那么右边就不一定有峰值，所以收缩区间往左边靠</p><p>3、如果中间值小于右边的元素，那么左边不一定有峰值，所以收缩区间往右边靠</p><p>时间复杂度是(log n)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[mid + <span class="number">1</span>])&#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> high;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="BM21-旋转数组的最小数字"><a href="#BM21-旋转数组的最小数字" class="headerlink" title="BM21 旋转数组的最小数字"></a><a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=295&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=0&amp;sourceUrl=%2Fexam%2Foj"><strong>BM21</strong> <strong>旋转数组的最小数字</strong></a></h3><p>有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值</p><p>要求：空间复杂度：O(1)<em>O</em>(1) ，时间复杂度：O(logn)</p><blockquote><p>思路：二分法</p><p>由于数组为非降序，所以可能出现连续元素值相等的情况</p><p>所以要考虑除了尾元素值大于首元素值之外，还有一种特殊可能。</p><p>那就是数组全是相同元素，这样首元素值和尾元素值就相等，最小值就可以直接返回首元素值即可</p><p>方法：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//二分查找法</span></span><br><span class="line">        <span class="comment">//分析：数组为非降序，所以可能出现连续元素值相等的情况</span></span><br><span class="line">        <span class="comment">//而这里，要么就是尾元素大于首元素，要么就全是相同元素</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;    <span class="comment">//首元素下标</span></span><br><span class="line">        <span class="keyword">int</span> right = rotateArray.size() - <span class="number">1</span>;    <span class="comment">//尾元素下标</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;    <span class="comment">//尾元素大于首元素值</span></span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//而尾元素值大于首元素值也有两种情况</span></span><br><span class="line">            <span class="keyword">if</span>(rotateArray[mid] &gt; rotateArray[right])&#123; </span><br><span class="line">                <span class="comment">//第一种常规情况，中间值大于尾元素值</span></span><br><span class="line">                left = mid + <span class="number">1</span>;<span class="comment">//更改首元素的值，正常二分即可</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid] == rotateArray[right])&#123;</span><br><span class="line">                <span class="comment">//另一种情况，中间值正好等于尾元素值</span></span><br><span class="line">                <span class="comment">//比如[1,1,1,1,3]-&gt;[1,1,1,3,1]</span></span><br><span class="line">                right--;<span class="comment">//更改尾元素值，继续二分    </span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//这种时候就出现了第三种情况，这时尾元素值大于中间值</span></span><br><span class="line">                right = mid;    <span class="comment">//我们将中间值赋值给尾元素值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//要么就全是相同元素，最小值返回首元素即可</span></span><br><span class="line">        <span class="keyword">return</span> rotateArray[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h3 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a></h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的 min 函数，输入操作时保证 pop、top 和 min 函数操作时，栈中一定有元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//栈1用于出栈和入栈</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    <span class="comment">//栈2用于存放最小值</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        s1.push(value);</span><br><span class="line">        <span class="comment">//如果栈2为空，或者栈2的栈顶元素更小</span></span><br><span class="line">        <span class="keyword">if</span>(s2.empty() || s2.top() &gt; value)&#123;</span><br><span class="line">            <span class="comment">//将该元素同时压入栈2中</span></span><br><span class="line">            s2.push(value);</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//该处不能省略，因为栈1出栈时，可能将最小值给出栈了</span></span><br><span class="line">            s2.push(s2.top());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s1.pop();</span><br><span class="line">        s2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.top();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s2.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="BM42-用两个栈实现队列"><a href="#BM42-用两个栈实现队列" class="headerlink" title="BM42 用两个栈实现队列"></a>BM42 用两个栈实现队列</h3><p>用两个栈来实现一个队列，使用n个元素来完成 n 次在队列尾部插入整数(push)和n次在队列头部删除整数(pop)的功能。 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。</p><p>数据范围： n≤1000</p><p>要求：存储n个元素的空间复杂度为 O(n) ，插入与删除的时间复杂度都是 O(1)</p><blockquote><p>思路：</p><p>1、栈和队列都是”先进”的特性，所以入队就是入栈</p><p>2、而栈的后出的特性，会让出栈的元素逆序，所以可以再利用一个栈，让其中元素再出栈一次，这样元素就是正序出栈</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、因为栈和队列都是先进,所以入栈和入队没什么不同</span></span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">            <span class="comment">//栈2中存入栈1的栈顶元素</span></span><br><span class="line">            stack2.push(stack1.top());</span><br><span class="line">            <span class="comment">//栈1的元素出栈</span></span><br><span class="line">            stack1.pop();           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//栈2的栈顶就是队列的队首</span></span><br><span class="line">        <span class="keyword">int</span> res = stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        <span class="keyword">while</span>(!stack2.empty())&#123;</span><br><span class="line">            <span class="comment">//栈1中存储栈2的栈顶元素</span></span><br><span class="line">            stack1.push(stack2.top());</span><br><span class="line">            <span class="comment">//栈2元素出栈</span></span><br><span class="line">            stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="BM49-表达式求值"><a href="#BM49-表达式求值" class="headerlink" title="BM49 表达式求值"></a><strong>BM49</strong> <strong>表达式求值</strong></h3><p>请写一个整数计算器，支持加减乘三种运算和括号。</p><blockquote><p>思路：</p><p>1、处理运算符优先级问题</p><p>2、处理括号问题</p><p>方法：</p><p>1、</p></blockquote><hr><h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><h3 id="BM50-两数之和"><a href="#BM50-两数之和" class="headerlink" title="BM50 两数之和"></a><strong>BM50</strong> <strong>两数之和</strong></h3><h1 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h1><h2 id="常见二进制操作"><a href="#常见二进制操作" class="headerlink" title="常见二进制操作"></a>常见二进制操作</h2><p>使用<strong>位运算符</strong>来对二进制进行操作</p><ol><li>任何数和 0 做异或运算，结果仍然是原来的数，即 a^0 = a</li><li>任何数和其自身做异或运算，结果是 0，即 a^a = 0</li><li>异或运算满足交换律和结合律，即 a^b^a = b^a^a = b^(a^a) = b^0 = b</li></ol><h3 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a href="https://leetcode.cn/problems/single-number/">136. 只出现一次的数字</a></h3><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp_操作符重载_侯捷</title>
      <link href="blog/Cpp-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD-%E4%BE%AF%E6%8D%B7/"/>
      <url>blog/Cpp-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD-%E4%BE%AF%E6%8D%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="课程回顾"><a href="#课程回顾" class="headerlink" title="课程回顾"></a>课程回顾</h2><p>在编写C++程序中，尽量要遵循以下规范</p><ul><li>对于构造函数，应使用<strong>初始化列表</strong>的形式进行初始化。该方法<strong>效率更高，速度更快</strong></li><li>数据都应该以Private的形式进行存储</li><li>若成员函数的作用，仅用于返回作用，那么<strong>函数名后面加上const</strong></li><li>当<strong>返回值不是局部变量</strong>时，可以用<strong>引用</strong>来接收函数的返回值</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">complex</span> (<span class="keyword">double</span> r = <span class="number">0</span>, <span class="keyword">double</span> i = <span class="number">0</span>): re (r), im (i) &#123; &#125;<span class="comment">//用初始化列表构造函数</span></span><br><span class="line"><span class="built_in">complex</span>&amp; <span class="keyword">operator</span> += (<span class="keyword">const</span> <span class="built_in">complex</span>&amp;);</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">real</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> re; &#125;<span class="comment">//不希望成员函数的返回值修改</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">imag</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> im; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">double</span> re, im;</span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">complex</span>&amp; __doapl (<span class="built_in">complex</span>*, <span class="keyword">const</span> <span class="built_in">complex</span>&amp;); <span class="comment">//友元函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="值类型和引用类型的使用场景"><a href="#值类型和引用类型的使用场景" class="headerlink" title="值类型和引用类型的使用场景"></a><strong>值类型和引用类型的使用场景</strong></h3><ul><li>在<strong>传参</strong>时，若仅为了追求<strong>效率</strong>，我们都尽可能的以<strong>引用的方式传递</strong>。</li></ul><blockquote><p>并且我们还需要明确规范一点</p><p>若该参数我们不希望修改，即该参数在函数中仅用于赋值，那么我们就应该在引用前加上const。</p><p>若该参数我们希望修改，即通过函数修改参数内容，那么就不用在引用前加const</p><p>好处：这样就能通过const，初步判断该引用在进行传参时，是否会发生改变</p></blockquote><ul><li>引用是可以作为<strong>函数的返回值</strong></li></ul><blockquote><p>但是返回的对象不能是局部变量，因为局部变量在出函数之后就会被释放，这样对其引用就会报错</p></blockquote><hr><h2 id="操作符重载与临时对象"><a href="#操作符重载与临时对象" class="headerlink" title="操作符重载与临时对象"></a>操作符重载与临时对象</h2><p>编译器在遇到操作符后</p><p>会判断左边的变量是否对该操作符进行了定义</p><p>若定义，则该行式子就会被编译成定义过的函数</p><h3 id="成员函数中的运算符重载"><a href="#成员函数中的运算符重载" class="headerlink" title="成员函数中的运算符重载"></a>成员函数中的运算符重载</h3><p>成员函数中有this指针，所以运算符重载的<strong>返回值类型可以为引用</strong></p><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span>&amp;<span class="comment">//运算符重载函数返回值用引用类型，速度快，效率高</span></span><br><span class="line">__doapl(<span class="built_in">complex</span>* ths, <span class="keyword">const</span> <span class="built_in">complex</span>&amp; r)</span><br><span class="line">&#123;</span><br><span class="line">ths-&gt;re += r.re;<span class="comment">//c2的实部</span></span><br><span class="line">ths-&gt;im += r.im;<span class="comment">//c2的虚部</span></span><br><span class="line"><span class="keyword">return</span> *ths;<span class="comment">//返回c2指针所指的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c2在操作符左边，传入函数的this指针中，不显示</span></span><br><span class="line"><span class="comment">//c1在操作符右边，传入函数的 const complex&amp; r 参数中</span></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span>&amp;</span><br><span class="line"><span class="built_in">complex</span>::<span class="keyword">operator</span> += (<span class="keyword">const</span> <span class="built_in">complex</span>&amp; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> __doapl (<span class="keyword">this</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="built_in">complex</span> <span class="title">c1</span><span class="params">(<span class="number">2</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">complex</span> <span class="title">c2</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">c2 += c1;<span class="comment">//+= 被定义，所以会编译complex::operator += ()函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>运算符重载函数的返回值类型，最好使用引用类型，速度快，效率高</li></ul><blockquote><p>若出现连续赋值的情况，则运算符重载的返回值类型不能为void</p></blockquote><h3 id="非成员函数中的运算符重载"><a href="#非成员函数中的运算符重载" class="headerlink" title="非成员函数中的运算符重载"></a>非成员函数中的运算符重载</h3><p>非成员函数中没有this指针，所得的数据只能放在typename()所创建的<strong>临时变量</strong>中</p><p>当函数return后，该临时变量就会被销毁，所以该运算符重载函数的返回值类型不能为引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span></span><br><span class="line"><span class="keyword">operator</span> + (<span class="keyword">const</span> <span class="built_in">complex</span>&amp; x, <span class="keyword">const</span> <span class="built_in">complex</span>&amp; y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">complex</span> (real (x) + real (y), imag (x) + imag (y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span></span><br><span class="line"><span class="keyword">operator</span> + (<span class="keyword">const</span> <span class="built_in">complex</span>&amp; x, <span class="keyword">double</span> y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">complex</span> (real (x) + y, imag (x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span></span><br><span class="line"><span class="keyword">operator</span> + (<span class="keyword">double</span> x, <span class="keyword">const</span> <span class="built_in">complex</span>&amp; y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">complex</span> (x + real (y), imag (y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp_Primer要点总结</title>
      <link href="blog/Cpp-Primer%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>blog/Cpp-Primer%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="第1章：开始"><a href="#第1章：开始" class="headerlink" title="第1章：开始"></a>第1章：开始</h1><h3 id="1-1-编写一个简单的C-程序"><a href="#1-1-编写一个简单的C-程序" class="headerlink" title="1.1 编写一个简单的C++程序"></a>1.1 编写一个简单的C++程序</h3><ul><li>每个C++程序必须包含<strong>一个</strong>或<strong>多个</strong>函数，其中一个必须命名为<strong>main</strong>，操作系统通过调用main来运行C++程序。</li><li>一个函数定义包括四个部分，<strong>返回值类型</strong>，<strong>函数名</strong>，<strong>形参列表</strong>，以及<strong>函数体</strong></li><li>main函数的返回类型必须是<strong>int</strong>。</li><li>main的返回值通常被用来指示状态，<strong>返回值0表示成功</strong>，非0的含义由系统定义，通常用来指出错误类型</li></ul><p><strong>程序源文件命名约定</strong></p><ul><li>不同编译器使用不同的后缀命名约定</li></ul><hr><h3 id="1-2-初识输入输出"><a href="#1-2-初识输入输出" class="headerlink" title="1.2 初识输入输出"></a>1.2 初识输入输出</h3><ul><li><p>C++并未定义任何输入输出语句，而是包含了一个全面的<strong>标准库</strong>来提供IO机制</p></li><li><p>iostream库包含了两个基础类型<strong>istream</strong>和<strong>ostream</strong>，分别表示<strong>输入流</strong>和<strong>输出流</strong></p></li></ul><p><strong>标准输入输出对象</strong></p><ul><li><strong>cin</strong>，将程序从窗口读入</li><li><strong>cout</strong>，将数据写入窗口</li><li><strong>cerr</strong>，在窗口输出警告和错误信息</li><li><strong>clog</strong>，在窗口输出程序运行日志</li></ul><p><strong>一个使用IO库的程序</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter two numbers:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> v1 = <span class="number">0</span>, v2 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;This sum of&quot;</span> &lt;&lt; v1 &lt;&lt; <span class="string">&quot;and&quot;</span> &lt;&lt; v2 &lt;&lt; <span class="string">&quot;is&quot;</span> &lt;&lt; v1 + v2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>iostream是一个头文件，使用标准库的程序都必须包含头文件</li></ul><p><strong>向流写入数据</strong></p><p><code>std::cout &lt;&lt; &quot;Enter two numbers:&quot; &lt;&lt; std::endl;</code></p><ul><li><p><strong>输出运算符</strong>(<strong>&lt;&lt;</strong>)左侧对象必须是<strong>ostream对象</strong>，它会将右侧的值<strong>写入</strong>左侧ostream中，并且计算结果为<strong>写入值的ostream对象</strong></p></li><li><p><strong>endl</strong>被称为<strong>操纵符</strong>，其效果是<strong>结束当前行</strong>，并将<strong>缓冲区中的内容刷到设备中</strong></p></li></ul><p><strong>使用标准库中的名字</strong></p><ul><li>标准库定义的<strong>所有名字</strong>都在命名空间中</li><li>命名空间可以<strong>避免库中相同名字导致的冲突</strong></li></ul><p><strong>从流读取数据</strong></p><p><code>std::cin &gt;&gt; v1 &gt;&gt; v2;</code></p><ul><li><strong>输入运算符</strong>(<strong>&gt;&gt;</strong>)通过左侧的istream对象，将读入的数据存入右侧的对象中</li></ul><hr><h1 id="第2章：变量和基本数据类型"><a href="#第2章：变量和基本数据类型" class="headerlink" title="第2章：变量和基本数据类型"></a>第2章：变量和基本数据类型</h1><h2 id="2-1-基本内置数据类型"><a href="#2-1-基本内置数据类型" class="headerlink" title="2.1 基本内置数据类型"></a>2.1 基本内置数据类型</h2><p>C++的内置数据类型包括了<strong>算数类型</strong>和<strong>空类型</strong></p><h3 id="2-1-1-算术类型"><a href="#2-1-1-算术类型" class="headerlink" title="2.1.1 算术类型"></a>2.1.1 算术类型</h3><p>算数数据有两类：</p><ul><li><strong>整形</strong>（这里面包括了字符型(char)和布尔类型(T or F)）</li><li>浮点型(单精度float，双精度double)</li></ul><p>其中char占一个字节，int占四个字节</p><p><strong>注意</strong>：当使用浮点数运算时一般用<strong>double</strong>，因为float通常精度不够，而两者实际的计算代价相差无几</p><h3 id="2-1-2-类型转换"><a href="#2-1-2-类型转换" class="headerlink" title="2.1.2 类型转换"></a>2.1.2 类型转换</h3><p> 当我们将两种不同的数据类型进行运算时，程序会自动的进行类型转换</p><p>这种类型转换被称为<strong>强制类型转换</strong></p><img src="/blog/Cpp-Primer%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/QQ%E6%88%AA%E5%9B%BE20220221212915.png" class="" title="QQ截图20220221212915"><h3 id="2-1-3-字面值常量"><a href="#2-1-3-字面值常量" class="headerlink" title="2.1.3 字面值常量"></a>2.1.3 字面值常量</h3><p>字面值常量的<strong>形式和值</strong>决定了它的数据类型，我们可以通过它一眼看出值的类型</p><p>比如：看到42就知道整形，4.2是浮点型</p><p><strong>字符和字符串字面值</strong></p><p>而<strong>字符</strong>型的字面值则是由<strong>单引号</strong>括起来，如  <strong>‘a’</strong></p><p><strong>字符串</strong>的字面值则是由<strong>双引号</strong>括起来，如 <strong>“abcd”</strong></p><p><strong>注意</strong>：</p><ul><li>字符串实际上是由<strong>常量字符构成的数组</strong></li><li>编译器会在字符串的<strong>结尾添加一个空字符</strong>(‘\0’)，因此字符串的<strong>实际长度要比所含字符多一个长度</strong></li></ul><p>如：(字符串)<strong>“A”</strong> ,实际上所占两个字符，分别为本身的字符 <strong>‘A’</strong>和编译器添加的 <strong>‘\0’</strong></p><p>而字符 <strong>‘A’</strong>,实际上所占就是本身一个字符 </p><p><strong>转义序列</strong></p><img src="/blog/Cpp-Primer%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/QQ%E6%88%AA%E5%9B%BE20220221214913.png" class="" title="QQ截图20220221214913"><h2 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h2><p>变量的本质是一个<strong>拥有名字</strong>，可以<strong>操作</strong>的<strong>存储空间</strong>。</p><blockquote><p>可以将它理解为大型商场里的一排排<strong>”储物柜“</strong>，变量<strong>存储空间的大小</strong>就相当于<strong>”储物柜“的大小</strong>，<strong>不同的数据类型的变量</strong>就相当于<strong>不同种类的”储物柜“</strong>。</p><p>而对象则更像是一种<strong>特殊的变量</strong>，因为对象的定义就是<strong>具有某种数据类型的内存空间</strong>。</p></blockquote><h3 id="2-2-1-变量定义"><a href="#2-2-1-变量定义" class="headerlink" title="2.2.1 变量定义"></a>2.2.1 变量定义</h3><p><strong>定义与声明的区别</strong></p><p>定义语法：<code>数据类型 变量名</code></p><p>声明语法：<code>extern 数据类型 变量名</code></p><p>在C++中定义与声明是有所<strong>区别</strong></p><ul><li><p><strong>定义</strong>变量时，系统会<strong>开辟一块存储空间</strong>，然后还有一串16进制的数字来表示空间地址，我们就通过<strong>变量名</strong>代替这串数字来访问这块空间。</p><blockquote><p>可以简单理解为 我们新开了一个<strong>”储物柜“</strong>，并有着与其对应编号的钥匙。而<strong>变量名</strong>就是这个<strong>带编号的钥匙</strong>，我们可以根据钥匙的编号，找到对应的储物柜，对其进行操作</p></blockquote></li><li><p><strong>声明</strong>变量时，系统并不会开辟新空间，而是告诉编译器，这个变量已经存在了，接下来可以直接使用</p></li></ul><blockquote><p>声明变量并不是新开一个”储物柜“，而是提醒编译器，在之前已经有一个一样的”储物柜“了</p></blockquote><p>声明的作用，为了实现多个文件中的代码共享，<strong>仅定义一次变量后</strong>，可以通过<strong>多次声明在不同的文件中使用</strong></p><p>所以，我们在<strong>声明</strong>变量的时候<strong>不会为其显示初始化</strong>，因为这样就变成了<strong>定义</strong>，而失去了<strong>声明</strong>原本的意义</p><p><strong>初始值</strong></p><p>当<strong>定义变量</strong>的时候<strong>获得一个特定值</strong>，它就被<strong>初始化</strong>了</p><ul><li>初始化的值不一定要求数值型，也<strong>可以是任意复杂的表达式</strong></li><li>如果我们<strong>不显式的给出初始值</strong>，<strong>内置的数据类型</strong>变量会根据<strong>定义的位置</strong>决定<ul><li>定义在<strong>函数外</strong>的变量都会被<strong>初始化为0</strong></li><li>定义在函数内则<strong>不初始化</strong></li></ul></li></ul><p>如：<code>double price=109.99,discount=price*0.16</code></p><p><strong>初始化和赋值的区别</strong></p><p>在C++中，初始化和赋值是两种不同的操作</p><p><code>int a=1; //定义变量的时候得到了一个初值1，这是初始化</code></p><p><code>int b;//根据位置，可能初始化，也可能不初始化</code></p><p><code>b=2;//擦去原有的值，用2代替，这就是赋值</code></p><ul><li>初始化是在<strong>创建变量时给其一个初始值</strong></li><li>赋值是把<strong>当前变量的值擦除</strong>，而用一个<strong>新值代替</strong></li></ul><blockquote><p>这里要注意的是，<strong>赋值并不是把一个“柜子”里的物品移动到另外一个“柜子”</strong>,而是单独拿一份一模一样的物品<strong>拷贝</strong>过去。</p></blockquote><h3 id="2-2-2-标识符"><a href="#2-2-2-标识符" class="headerlink" title="2.2.2 标识符"></a>2.2.2 标识符</h3><p>C++标识符由<strong>字母，数字</strong>以及<strong>下划线</strong>组成，其中必须以<strong>字母或下划线</strong>开头</p><p>不能使用关键字作为标识符</p><hr><h2 id="2-3-复合类型"><a href="#2-3-复合类型" class="headerlink" title="2.3 复合类型"></a>2.3 复合类型</h2><p>一条语句是由<strong>基本数据类型</strong>和<strong>一个或多个声明</strong>符组成</p><p>基于其他类型定义的类型，<strong>指针和引用</strong>就是复合类型。<strong>引用的本质是指针常量，占用4个字节的空间</strong></p><h3 id="2-3-1-引用"><a href="#2-3-1-引用" class="headerlink" title="2.3.1 引用"></a>2.3.1 引用</h3><p>引用是为变量起<strong>另一个名字</strong>。</p><p>当我们把<strong>变量</strong>当成一个<strong>”储物柜“</strong>，<strong>变量名</strong>就是<strong>”带编号的钥匙“</strong>，而定义引用就相当于给<strong>“储物柜”</strong>再设置一个<strong>备用钥匙</strong>。</p><blockquote><p>比如：“储物柜”原本的编号是01，现在我们再给“储物柜”贴上一个“one”的标签，然后制作一个编号为“one”的钥匙，这样就可以通过两个钥匙找到同一个储物柜了</p></blockquote><p><strong>语法</strong>：</p><p><code>int a=10;</code></p><p><code>int &amp;A=a;    //A是a的另一个名字</code></p><p><code>int &amp;A;    //错误，引用必须初始化</code></p><ul><li>为引用赋值，实际上是把值赋给了<strong>与引用绑定的对象</strong></li></ul><blockquote><p>这里的意思是，我们通过<strong>备用钥匙</strong>来操作”储物柜”的存取等功能，实际对象还是<strong>原本的”储物柜“</strong></p></blockquote><p><strong>定义：</strong></p><p><strong>大部分引用</strong>的<strong>数据类型</strong>要和所绑定的变量<strong>严格匹配</strong>，并且<strong>只能绑定在变量</strong>上，不能绑定字面量等。</p><p><strong>注意</strong>：</p><ul><li>当我们<strong>定义引用</strong>时，引用的初始值就与变量<strong>绑定</strong>在一起，就<strong>不能</strong>将引用<strong>重新绑定</strong>在其他变量上。</li></ul><blockquote><p>就是说，当我们给一个<strong>“储物柜”</strong>设置一个<strong>“备用钥匙”</strong>之后，该<strong>“备用钥匙”</strong>作用于当前<strong>“储物柜”</strong>使用</p></blockquote><ul><li><strong>引用定义时就必须为其初始化</strong></li></ul><blockquote><p>我们在配置备用钥匙的时候，必须要有原本的钥匙才行</p></blockquote><ul><li><strong>强调：引用并非变量，而是将已有的变量起另外一个名字</strong></li></ul><blockquote><p>引用只是备用钥匙，而不是柜子</p></blockquote><h3 id="2-3-2-指针"><a href="#2-3-2-指针" class="headerlink" title="2.3.2 指针"></a>2.3.2 指针</h3><p><strong>指针本身就是一个变量</strong>，存放的其他变量的<strong>地址</strong>，允许对指针<strong>赋值</strong>和<strong>拷贝</strong>，可以先后指向不同变量。</p><blockquote><p>所以指针本身也是一个小柜子。只不过内部只存放其他变量的地址，也就是“柜子”的“钥匙”</p></blockquote><p><strong>获取对象地址</strong></p><p>指针存放着某个变量的<strong>地址</strong>，使用<strong>取地址符</strong>（<strong>&amp;</strong>）获取地址。</p><p><strong>语法</strong>：</p><p><code>int a=10;</code></p><p><code>int *p;</code></p><p><code>int *p=&amp;a;</code></p><p>上述这段话的意思，可以将其理解为，<strong>“将a柜子的钥匙，放到p柜子里”</strong></p><p><strong>注意</strong>：</p><ul><li>大部分指针类型要和它指向的变量类型严格匹配</li></ul><p><strong>指针值</strong></p><p>指针的值(地址)应属于下列4种状态</p><ol><li>指向一个对象（放着柜子的钥匙）</li><li>指向紧邻对象所占空间的下一个位置(放着不知道哪的钥匙)</li><li>空指针(没钥匙)</li><li>无效指针，上述之外的情况</li></ol><p>注意：</p><ul><li>尽管2，3种形式的指针有效，但它们并没有指向任何具体对象，所以此类指针<strong>不能被访问</strong></li></ul><p><strong>利用指针访问对象</strong></p><p>如果指针指向了一个对象，则运行用<strong>解引用符</strong>（<strong>*</strong>）来访问该对象</p><p><code>int a=42;</code></p><p><code>int *p=&amp;a;</code></p><p><code>cout&lt;&lt;*p //输出 42</code></p><p><strong>注意</strong>：</p><p><strong>&amp;</strong>和<strong>*</strong>的多重含义</p><p><code>int i=10;</code></p><ul><li><p>如果<strong>&amp;</strong> 跟着类型名出现，是引用    <code>int &amp;r=i;</code></p></li><li><p>如果<strong>*</strong> 跟着类型名出现，是指针    <code>int *p;</code></p></li><li><p>如果<strong>&amp;</strong> 出现在表达式中，就是取地址符    <code>p=&amp;i;</code></p></li><li><p>如果<strong>*</strong> 出现在表达式中，就是解引用符    <code>*p=i;</code></p></li></ul><p>解引用仅适用于确实指向某个对象的<strong>有效指针</strong></p><p><strong>空指针</strong></p><p>空指针不指向任何对象，在试图使用一个指针代码之前，先检查其是否为空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1=<span class="literal">nullptr</span>;<span class="comment">//等价于int *p1=0;</span></span><br><span class="line"><span class="keyword">int</span> *p2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p3=<span class="literal">NULL</span>;<span class="comment">//等价于int *p1=0;</span></span><br></pre></td></tr></table></figure><p>注意：<strong>初始化所有指针</strong></p><p>如果使用了未初始化的指针，则它当前所占内存空间将被看作一个地址值，去访问一个本不存在的对象</p><p><strong>赋值和指针</strong></p><ul><li><p><strong>赋值永远改变的是等号左侧的对象</strong></p></li><li><p><strong>指针里面只能存放地址</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="comment">//int *p=a;//错误 指针里面只能存放地址</span></span><br><span class="line"><span class="keyword">int</span> *p=&amp;a;<span class="comment">//正确，指针p的初始值改变，现在指向a的地址</span></span><br><span class="line">*p=<span class="number">20</span>;<span class="comment">//正确, 指针p解引用，实际改变a的值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-3-3-理解复合类型的声明"><a href="#2-3-3-理解复合类型的声明" class="headerlink" title="2.3.3 理解复合类型的声明"></a>2.3.3 理解复合类型的声明</h3><p><strong>指向指针的指针</strong></p><p>通过<strong>*</strong>的个数，可以区分指针的级别，<strong>**</strong>表示<strong>指向指针的指针</strong></p><blockquote><p>就是将<strong>“钥匙”</strong>到第一个指针内，然后将第一个指针的<strong>“钥匙”</strong>放到第二个指针内</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *pi=&amp;a;<span class="comment">//将a的钥匙放入p内</span></span><br><span class="line"><span class="keyword">int</span> **ppi=&amp;pi<span class="comment">//将pi的钥匙放入ppi内</span></span><br></pre></td></tr></table></figure><p><strong>总结</strong>：</p><p>面对复杂的语句，从<strong>右到左</strong>阅读是最简单的方法，离<strong>变量名最近的声明符对变量的类型影响最大</strong></p><hr><h2 id="2-4-const限定符"><a href="#2-4-const限定符" class="headerlink" title="2.4 const限定符"></a>2.4 const限定符</h2><p>使用关键字<strong>const</strong>对变量的类型修饰后，该变量的<strong>值不能被改变</strong>，所以<strong>const对象必须初始化</strong></p><p><strong>初始化和const</strong></p><p>注意：</p><p>上面指的值不能被改变，指的是const对象<strong>不能被赋值</strong>，它还是<strong>可以初始化</strong>和<strong>访问</strong>的。</p><blockquote><p>实际上，常量是在内存四区中的代码区，我们可以将其简单的理解为，被const修饰之后，该对象就会被到另一片区域展览，我们只有查看的权力，而不能做出修改</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci=i;<span class="comment">//正确；const初始化,将i的值拷贝给了ci(将物品i放入ci柜子后，再拿去展览)</span></span><br><span class="line"><span class="keyword">int</span> j=ci<span class="comment">//正确；将ci的值拷贝给j，并没有对ci的值进行操作(查看ci柜子的物品，将它照搬一份到j柜子，并没有对ci柜子进行操作)</span></span><br><span class="line">ci=<span class="number">10</span>；<span class="comment">//错误；因为给ci赋值的过程中，要先把原来的值擦除，但因为加了const限定，不能修改</span></span><br></pre></td></tr></table></figure><h3 id="2-4-1-const的引用"><a href="#2-4-1-const的引用" class="headerlink" title="2.4.1 const的引用"></a>2.4.1 const的引用</h3><p>可以把<strong>引用绑定到const对象</strong>上，我们称之为<strong>对常量的引用</strong></p><p>与普通引用不同的是，const引用绑定对象后就<strong>不能被修改</strong></p><blockquote><p>常量引用的本质是系统自动开辟一个<strong>临时变量</strong>，然后将临时变量<strong>初始化</strong>，最后再限定变量的<strong>值不能被修改</strong>。而常量名字其实就是临时变量的引用</p><p>我们可以常量引用理解为，新开了一个<strong>临时柜子</strong>，然后将其他柜子的物品<strong>拷贝</strong>过来，或者干脆自己放一些物品让它进行<strong>初始化</strong>操作，再给这个柜子设置一个<strong>备用钥匙</strong>，最后再给备用钥匙上贴上<strong>“标签”</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1=i;<span class="comment">//正确,拷贝其他柜子物品放到临时柜子中做初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2=<span class="number">42</span>;<span class="comment">//正确，自己放置物品做初始化</span></span><br><span class="line"><span class="keyword">int</span> &amp;r3=<span class="number">42</span>;<span class="comment">//错误，非常量引用只是“钥匙”,不能放物品</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//系统默认执行操作</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp=i;<span class="comment">//系统自动开一个临时的柜子，并用复制其他柜子物品初始化，给&quot;钥匙&quot;temp贴上标签</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1=temp;<span class="comment">//给柜子设置一个备用钥匙，并给r1钥匙贴上标签</span></span><br></pre></td></tr></table></figure><p>所以由上我们可以知道：</p><ul><li><p>初始化<strong>常量引用</strong>时运行用<strong>任意表达式</strong>作为初始值</p></li><li><p><strong>常量引用</strong>可以引用<strong>非常量的对象</strong></p></li></ul><h3 id="2-4-2-指针和const"><a href="#2-4-2-指针和const" class="headerlink" title="2.4.2 指针和const"></a>2.4.2 指针和const</h3><p><strong>指向常量的指针</strong>，就被称为<strong>常量指针</strong>，书中也叫<strong>底层const</strong>。<strong>常量指针</strong>不能用于改变<strong>其对象</strong>的值。</p><p>想要存放<strong>常量对象的地址</strong>，只能使用<strong>指向常量的指针</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> A=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p=&amp;A;</span><br><span class="line">*p=<span class="number">20</span>;<span class="comment">//错误，指针柜中的钥匙A被const加以限制，不能对柜子A的数据进行修改</span></span><br><span class="line"> A=<span class="number">20</span>;<span class="comment">//正确，</span></span><br></pre></td></tr></table></figure><blockquote><p>因为常量指针就是为了指向常量所定义的，所以不管该对象是否为常量，都不能通过常量指针去改变对象</p></blockquote><p>注意：</p><ul><li>要想存放<strong>常量对象</strong>的地址，只能使用<strong>常量指针</strong></li><li>指针的类型必须与其所指对象保持一致，但允许<strong>指针常量指向非常量对象</strong>。</li><li><strong>指针常量</strong>仅仅是<strong>不能通过指针改变对象的值</strong>，但用<strong>其他方式改变对象的值</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p1=&amp;a;<span class="comment">//错误，非常量指针没有const加以限制，就导致可以对常量进行修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1=&amp;a;<span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2=&amp;b;<span class="comment">//正确，因为const限制的是指针柜中的钥匙a,而不是钥匙p</span></span><br><span class="line"></span><br><span class="line">*p2=<span class="number">30</span>;<span class="comment">//错误，因为const限制的是指针柜中的钥匙a，并没有限制原本的钥匙a</span></span><br><span class="line">b=<span class="number">20</span>;<span class="comment">//正确</span></span><br></pre></td></tr></table></figure><p><strong>指针常量</strong></p><p>当<strong>指针本身是常量</strong>时，就被称为<strong>指针常量</strong>。那么当前指针的<strong>值就不能改变</strong>，也就是指针<strong>指向的对象的地址不能变</strong>。</p><blockquote><p>也就是说，const这个警告“标签”,是贴在“指针柜”的钥匙上的</p></blockquote><img src="/blog/Cpp-Primer%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F.png" class="" title="指针常量"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> A=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p=&amp;A;</span><br><span class="line">*p=<span class="number">20</span>;<span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> B=<span class="number">30</span>；</span><br><span class="line"> p=&amp;B;<span class="comment">//错误，指针柜所对应的钥匙被限制，不能修改指针贵的内容  </span></span><br></pre></td></tr></table></figure><p>总结：如何判断是常量指针，还是指针常量</p><p>从变量名开始，右往左读，判断const 和 * 的位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p=&amp;a;<span class="comment">//const在前，*在后，就是常量指针</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p=&amp;a;<span class="comment">//*在前 ，const在后，就是指针常量</span></span><br></pre></td></tr></table></figure><h2 id="2-5-处理类型"><a href="#2-5-处理类型" class="headerlink" title="2.5 处理类型"></a>2.5 处理类型</h2><h3 id="2-5-1-类型别名"><a href="#2-5-1-类型别名" class="headerlink" title="2.5.1 类型别名"></a>2.5.1 类型别名</h3><p>类型别名是一个名字，它是某种<strong>类型</strong>的同义词</p><p>语法：</p><p><code>typedef</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;<span class="comment">//wages 是 double 的同义词</span></span><br><span class="line">wages a=<span class="number">1.0</span>;</span><br></pre></td></tr></table></figure><p>作用：</p><p>含有typedef的声明语句定义的 不是变量 而<strong>是类型别名</strong></p><p>也可以使用<strong>别名声明</strong>来实现同样的操作</p><p>语法：</p><p><code>using</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> a = <span class="keyword">int</span> ;</span><br><span class="line">a b = <span class="number">10</span>;<span class="comment">//正确，a是int的同义词 b是变量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-5-2-auto-类型说明符"><a href="#2-5-2-auto-类型说明符" class="headerlink" title="2.5.2 auto 类型说明符"></a>2.5.2 auto 类型说明符</h3><p>auto类型说明符，能让编译器通过初始值来<strong>推算变量的类型</strong>，所以auto定义的变量必须有初始值</p><p>因为一条声明语句中只能有<strong>一个基本数据类型</strong>，所以auto能在一条语句中声明<strong>多个变量</strong></p><p><strong>复合类型、常量和auto</strong></p><p>编译器会<strong>适当的改变</strong>auto类型的<strong>结果</strong> 使其更符合初始化</p><p>列如：</p><p>当引用被当作初始值时，真正参与初始化对象的是<strong>引用对象的值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r=i;</span><br><span class="line"><span class="keyword">auto</span> b=r;<span class="comment">//auto将推导出整型</span></span><br></pre></td></tr></table></figure><hr><h1 id="第3章：字符串、向量和数组"><a href="#第3章：字符串、向量和数组" class="headerlink" title="第3章：字符串、向量和数组"></a>第3章：字符串、向量和数组</h1><h2 id="3-1-命名空间"><a href="#3-1-命名空间" class="headerlink" title="3.1 命名空间"></a>3.1 命名空间</h2><p>我们所用到的库函数，基本上都属于命名空间std，使用<strong>using声明</strong>后，就可以<strong>直接访问命名空间的名字</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> :: <span class="built_in">std</span>;<span class="comment">//或者using namespace std;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-2-标准库类型string"><a href="#3-2-标准库类型string" class="headerlink" title="3.2 标准库类型string"></a>3.2 标准库类型string</h2><p>string表示<strong>可变长的字符序列</strong>，使用string类型必须包含string头文件(但实际使用VS编程中，不包含似乎也可以？)</p><h3 id="3-2-1-定义和初始化string对象"><a href="#3-2-1-定义和初始化string对象" class="headerlink" title="3.2.1 定义和初始化string对象"></a>3.2.1 定义和初始化string对象</h3><p><strong>string初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1;<span class="comment">//默认初始化，s1是一个空字符串</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s2=s1;<span class="comment">//将s1中的字符拷贝到s2中</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s3=<span class="string">&quot;hiya&quot;</span><span class="comment">//将该字面值拷贝到s3中</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">string</span> s4(<span class="number">10</span>,<span class="string">&#x27;c&#x27;</span>)<span class="comment">//s4的内容是cccccccccc</span></span><br></pre></td></tr></table></figure><p><strong>直接初始化和拷贝初始化</strong></p><ul><li><p>如果<strong>使用</strong>等号初始化一个变量，实际上就是执行<strong>拷贝初始化</strong></p></li><li><p>如果<strong>不使用</strong>等号，则执行的直接初始化</p></li></ul><h3 id="3-2-2-string对象上的操作"><a href="#3-2-2-string对象上的操作" class="headerlink" title="3.2.2 string对象上的操作"></a>3.2.2 string对象上的操作</h3><p><strong>读写string对象</strong></p><ul><li>string读写单个对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> s1;<span class="comment">//初始化空字符串</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s1;<span class="comment">//从键盘上输入的内容读入s1中</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出s1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当我们输入&quot;   Hello World&quot;时，只会输出&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure><ul><li>string读写多个对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> s1;<span class="comment">//初始化空字符串</span></span><br><span class="line"><span class="built_in">string</span> s2;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s1&gt;&gt;s2;<span class="comment">//从键盘上输入的内容读入s1中</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt;s2&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出s1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当我们输入&quot;   Hello World&quot;时 会输出&quot;HelloWorld&quot; 中间并不会有空格</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：string对象会<strong>忽略开头的空白</strong>，并从<strong>第一个真正的字符</strong>开始读取，直到遇到<strong>下一处空白</strong>为止</p><p><strong>使用getline读取一整行</strong></p><ul><li>getline函数的<strong>参数</strong>是一个<strong>输入流</strong>和一个<strong>string对象</strong></li><li>函数从给定的输入流中读取内容，直到遇见换行符为止(<strong>换行符也读取进来</strong>),然后将内容再存入到string对象中(<strong>不存换行符</strong>)</li><li>getline只要一遇见换行符就结束，如果一开始输入的是换行符，那么就会得到一个空字符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> line;</span><br><span class="line"><span class="keyword">while</span> (getline(<span class="built_in">cin</span>,line))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; line &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>string 的 empty和size</strong></p><h2 id="3-3-标准库类型-vector"><a href="#3-3-标准库类型-vector" class="headerlink" title="3.3 标准库类型 vector"></a>3.3 标准库类型 vector</h2><p><strong>vector</strong> 表示<strong>类型相同</strong>的对象的<strong>集合</strong>。每个对象都有一个与之对应的<strong>索引</strong>，用于<strong>访问对象</strong></p><p>注意：</p><ul><li>vector是<strong>类模板</strong>，而非类型</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所以由vector生成的类型必须包含vector中元素的类型</span></span><br><span class="line">vector&lt;<span class="built_in">int</span>&gt; a;</span><br></pre></td></tr></table></figure><ul><li>因为引用不是对象，所以vector<strong>不能容纳引用作为对象</strong></li></ul><h3 id="3-3-1-定义和初始化vector对象"><a href="#3-3-1-定义和初始化vector对象" class="headerlink" title="3.3.1 定义和初始化vector对象"></a>3.3.1 定义和初始化vector对象</h3><p><strong>定义vector对象的常用方法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;T&gt; v1;<span class="comment">//定义空的vector，潜在元素是T类型的，执行默认初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;T&gt; <span class="title">v2</span><span class="params">(v1)</span></span>;<span class="comment">//将v1中所有元素拷贝到v2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;T&gt; <span class="title">v3</span><span class="params">(n)</span></span>;<span class="comment">//v3中包含了n个元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;T&gt; <span class="title">v4</span><span class="params">(n,<span class="number">4</span>)</span></span>;<span class="comment">//v4中包含n个元素，每个元素的值都为4</span></span><br></pre></td></tr></table></figure><p>作用：</p><ul><li>先定义一个空的vector，然后运行时 再逐一添加元素</li><li>也可以定义vector对象时就指定元素的初始值，但对象的<strong>类型必须相同</strong></li></ul><p><strong>列表初始化vector对象</strong></p><p>用<strong>花括号</strong>括起来的0个或者多个初始元素值将被赋给vector对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v1&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;an&quot;</span>,<span class="string">&quot;the&quot;</span>&#125;;<span class="comment">//列表初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">v2</span><span class="params">(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;an&quot;</span>,<span class="string">&quot;the&quot;</span>)</span></span>;<span class="comment">//错误，是花括号，不是圆括号</span></span><br></pre></td></tr></table></figure><p><strong>值初始化</strong></p><p>概念：</p><p>一般在创建vector对象时，可以<strong>只提供元素数量</strong>，而<strong>不用给其初始化</strong>。</p><p>因为库会根据元素的<strong>类型</strong> 自动进行 <strong>值初始化</strong>操作</p><ul><li>如果是内置的数据类型，如int，那么元素的初始值就为0</li><li>如果是类 类型，如 string，那么元素就由类默认初始化</li></ul><p>列表初始化还是元素数量？</p><ul><li>圆括号：可以说提供的值是用来<strong>构造vector对象</strong>的</li><li>花括号：<strong>优先</strong>进行<strong>列表初始化操作</strong>，只有确认<strong>无法执行</strong>列表初始化后，才尝试<strong>构造对象</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//v1有10个元素，每个元素都是0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2&#123;<span class="number">10</span>&#125;;<span class="comment">//v2有1个元素，值为10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;v3&#123;<span class="number">10</span>&#125;;<span class="comment">//v3无法进行初始化列表操作，会尝试构造对象，所以有10个默认构造的元素</span></span><br></pre></td></tr></table></figure><h3 id="3-3-2-向vector对象中添加元素"><a href="#3-3-2-向vector对象中添加元素" class="headerlink" title="3.3.2 向vector对象中添加元素"></a>3.3.2 向vector对象中添加元素</h3><p>对于vector对象来说，直接初始化一般适用于三种情况</p><ol><li>初始值已知且数量少(直接赋值)</li><li>初始值是另一个vector对象的副本(拷贝)</li><li>所有元素的初始值相同(初始化列表)</li></ol><p>其他情况，一般是 创建一个<strong>空vector</strong>，然后再利用成员函数<strong>push_back</strong>向其添加元素</p><p><strong>push_back</strong>：负责把一个<strong>值</strong> 当成vector对象的<strong>尾元素 **</strong>压倒尾端**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;<span class="comment">//创建空vector对象</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;num)<span class="comment">//读入数据</span></span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(num);<span class="comment">//将数据依次赋予元素并压入栈中</span></span><br><span class="line">sum++;<span class="comment">//计算容器中目前的元素</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;v1中的值为：&quot;</span> &lt;&lt; v1[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-迭代器"><a href="#3-4-迭代器" class="headerlink" title="3.4 迭代器"></a>3.4 迭代器</h2><p>与指针类似，迭代器提供了对象的<strong>间接</strong>访问。其<strong>对象是</strong>容器中的<strong>元素</strong>或者string对象中的<strong>字符</strong></p><p>作用：</p><p>使用迭代器可以<strong>间接访问某个元素</strong>，也能从<strong>一个元素移动到另外一个元素</strong></p><p>注意：</p><p>迭代器有 有效和无效之分</p><p>有效：</p><ul><li>指向某个元素</li><li>指向容器尾元素的下一个位置</li></ul><p>其余都是无效</p><h3 id="3-4-1-使用迭代器"><a href="#3-4-1-使用迭代器" class="headerlink" title="3.4.1 使用迭代器"></a>3.4.1 使用迭代器</h3><p>和指针不一样，迭代器不适用取地址符。</p><p>而是返回迭代器的<strong>begin</strong>和<strong>end</strong>成员</p><ul><li><strong>begin</strong>成员负责指向第一个元素</li><li><strong>end</strong>成员负责指向尾元素的下一个位置，即end成员如果<strong>返回空</strong>，说明已经处理完<strong>所有元素</strong></li><li>如果 容器为空，那么<strong>begin</strong>和<strong>end</strong>返回<strong>同一个迭代器</strong></li></ul><h2 id="3-5-数组"><a href="#3-5-数组" class="headerlink" title="3.5 数组"></a>3.5 数组</h2><p>数组是存放<strong>类型相同</strong>对象的<strong>容器</strong>，这些对象本身没有名字，需要通过其所在的<strong>位置</strong>访问</p><p>数组的<strong>大小</strong>是确定<strong>不变</strong>，不能随意向数组中增加元素</p><h3 id="3-5-1-定义和初始化内置数组"><a href="#3-5-1-定义和初始化内置数组" class="headerlink" title="3.5.1 定义和初始化内置数组"></a>3.5.1 定义和初始化内置数组</h3><p>数组的声明：<code>a[d]</code></p><ul><li>其中a是数组的名字，d是数组的<strong>个数</strong></li><li><p>数组元素的<strong>个数</strong>在编译时应该是<strong>已知</strong>的</p></li><li><p><strong>定义数组时必须指定它的类型</strong>，并且其元素应为<strong>对象</strong>，所以<strong>不存在引用的数组</strong></p></li></ul><p><strong>显式初始化数组元素</strong></p><ul><li>如果<strong>没有</strong>给定数组<strong>个数</strong>，那么编译器会根据<strong>初始值的数量推测</strong>出来</li><li>如果<strong>给定</strong>了数组个数，那么初始值的总数就<strong>不能超出指定大小</strong></li><li>如果数组个数<strong>大于</strong>初始值总数，那么剩下的元素会被<strong>初始化成默认值</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr1[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//编译器会自动推测数组个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr2[<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//错误，数组越界</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>arr3[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;<span class="comment">//最后的数组为&#123;1,2,3,0,0&#125;</span></span><br></pre></td></tr></table></figure><p><strong>字符数组的特殊性</strong></p><ul><li>当使用<strong>字符串</strong>对<strong>字符数组</strong>进行<strong>初始化</strong>时，字符串结尾处的<strong>空字符</strong>也会拷贝进去</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> arr1[]=&#123;<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;+&#x27;</span>&#125;;<span class="comment">//正确，列表初始化，没有空字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> arr2[]=&#123;<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;<span class="comment">//正确，列表初始化，含有显示的空字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> arr3[<span class="number">3</span>]=<span class="string">&quot;C++&quot;</span>;<span class="comment">//错误，没有多余的空间存放字符串结尾处的空字符</span></span><br></pre></td></tr></table></figure><p><strong>不允许拷贝和赋值</strong></p><ul><li>不能将数组的内容拷贝给其他数组作为初始值，也不能给其他数组赋值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr1[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> arr2[]=a;<span class="comment">//错误，不允许将一个数组初始化其他数组</span></span><br><span class="line">arr2=arr1;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure><p><strong>理解复杂的数组声明</strong></p><p>指针数组：存放指针的数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> d = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p1 = &amp;a;</span><br><span class="line"><span class="keyword">int</span>* p2 = &amp;b;</span><br><span class="line"><span class="keyword">int</span>* p3= &amp;c;</span><br><span class="line"><span class="keyword">int</span>* p4 = &amp;d;</span><br><span class="line"><span class="keyword">int</span>* ptr[<span class="number">4</span>] = &#123; p1,p2,p3,p4 &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p1 &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//指针所指对象的地址</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ptr[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//指针所指对象的地址</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ptr &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//指针所指对象的地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;p1 &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//0号位指针本身的地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;*ptr[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//解引用0号位指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/Cpp-Primer%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84.png" class="" title="指针数组"><p><strong>数组指针</strong>：</p><p>指向数组的指针，其<strong>数组名就是指针本身</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">4</span>] = &#123; <span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span> &#125;;<span class="comment">//定义数组</span></span><br><span class="line"><span class="keyword">int</span>(*ptr)[<span class="number">4</span>] = &amp;arr;<span class="comment">//定义指向数组的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>(*ptr)[<span class="number">5</span>]=&amp;arr;<span class="comment">//错误,数组和数组指针的元素个数必须相同</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;* (*ptr) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//通过数组指针解引用访问数组的0号元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/Cpp-Primer%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88.png" class="" title="数组指针"><p>注意：</p><ul><li><strong>数组</strong>和<strong>数组指针</strong>的元素<strong>个数</strong>必须<strong>相同</strong></li><li>可以通过<strong>数组指针解引用访问数组</strong></li></ul><p><strong>总结</strong>：</p><p>面对复杂的数组声明，应该由<strong>数组名</strong>开始然后<strong>从右往左</strong>读</p><h3 id="3-5-2-访问数组元素"><a href="#3-5-2-访问数组元素" class="headerlink" title="3.5.2 访问数组元素"></a>3.5.2 访问数组元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将10学生的成绩存入数组中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> grade;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; grade;</span><br><span class="line">arr[i] = grade;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-3-指针和数组"><a href="#3-5-3-指针和数组" class="headerlink" title="3.5.3 指针和数组"></a>3.5.3 指针和数组</h3><p>在C++中，使用数组的时候，编译器一般会把它<strong>转换成指针</strong></p><p><strong>本质</strong>：</p><ul><li>在使用到<strong>数组名</strong>的地方，编译器会自动的将其<strong>替换</strong>为一个<strong>指向数组首元素</strong>的<strong>指针</strong></li></ul><blockquote><p>所以，在一些情况下，数组的操作实际上是指针的操作</p></blockquote><ul><li>指针也是<strong>迭代器</strong>，vector和string支持的运算，数组的指针也全部支持</li></ul><p>特点：</p><ol><li>当数组作为一个<strong>auto</strong> 变量的初始值时，得到的推断<strong>是指针</strong>，而<strong>不是</strong>数组。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr1[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">arr2</span><span class="params">(arr1)</span></span>;<span class="comment">//arr2 是一个整型指针，指向arr1的第一个元素</span></span><br><span class="line">arr2=<span class="number">4</span>;<span class="comment">//错误，arr2 是指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//编译器内部实际上发生了以下的转换</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">arr2</span><span class="params">(&amp;arr[<span class="number">0</span>])</span></span>;<span class="comment">//所以arr2 是int* 类型</span></span><br></pre></td></tr></table></figure><ol><li>通过指针也能遍历数组中的元素，我们只需要得到数组<strong>第一个元素</strong>的指针和尾元素<strong>下一个位置</strong>的指针</li></ol><blockquote><p>在C++ 11 中引入了begin 和 end 函数，其功能与容器中的两个同名成员函数类似</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* beg = begin(arr);<span class="comment">//指向arr首元素的指针</span></span><br><span class="line"><span class="keyword">int</span>* last = end(arr);<span class="comment">//指向arr尾元素的下一个位置指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">while</span> (beg != last) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *beg &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">beg++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>给指针加上某个整数，结果仍为指针。</p></li><li><p>两个指针<strong>相减</strong>的结果是他们之间的<strong>距离</strong>。参与运算的两个指针必须指向<strong>同一个数组</strong>当中的元素</p></li></ol><blockquote><p>如果两个指针分别指向不相关的对象，则不能比较他们。</p></blockquote><p><strong>总结</strong>：</p><ul><li>使用<strong>数组类型</strong>的对象，实际上是使用一个<strong>指向</strong>该<strong>数组首元素</strong>的<strong>指针</strong></li><li>指针也是<strong>迭代器</strong>。所以给指针加上某个整数，相当于新指针位移了改整数的位置</li></ul><h1 id="第6章：函数"><a href="#第6章：函数" class="headerlink" title="第6章：函数"></a>第6章：函数</h1><p>函数是一个<strong>有名字的代码块</strong>，我们通过调用函数执行相应代码，函数有<strong>0个</strong>或者<strong>多个</strong>参数，通常产生<strong>一个</strong>结果。</p><h2 id="6-1-函数基础"><a href="#6-1-函数基础" class="headerlink" title="6.1 函数基础"></a>6.1 函数基础</h2><p>一个函数包括以下部分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;<span class="comment">//返回类型 函数名 0个或多个形参组成的函数体</span></span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;<span class="comment">//语句块</span></span><br></pre></td></tr></table></figure><p>函数调用完成两项工作：</p><ul><li>用实参初始化对应的形参</li><li>将控制权转移给被调函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=b;</span><br><span class="line">    b=a;</span><br><span class="line">    a=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">5</span>;</span><br><span class="line">    swap(A,B);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行函数时，实参会用<strong>字面值 </strong> <strong>隐式</strong>的定义并初始化它的形参。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">3</span>;<span class="comment">//实参隐式初始化形参</span></span><br><span class="line"><span class="keyword">int</span>b=<span class="number">5</span>;</span><br></pre></td></tr></table></figure><p><strong>形参和实参</strong></p><p>实参是形参的<strong>初始值</strong>。二者因为作用域不同，所以可以同名，但实际上是两个不同的变量</p><ul><li>形参<strong>类型</strong>和<strong>个数</strong>要与形参相匹配。(类型隐式转换也可以)</li></ul><hr><h1 id="第7章：类"><a href="#第7章：类" class="headerlink" title="第7章：类"></a>第7章：类</h1><p>在C++中，我们使用<strong>类</strong> <strong>定义</strong> <strong>自己</strong>的数据类型。通过自定义的数据类型解决更多问题</p><p>类的基本思想是<strong>数据抽象</strong>和<strong>封装</strong></p><ul><li>数据抽象是一种依赖于<strong>接口</strong>和<strong>实现</strong>分离的编程，<strong>封装</strong>实现了该步骤</li><li>封装后的类隐藏了它的实现细节，只能使用接口而无法访问实现部分</li></ul><h2 id="7-1-定义抽象数据类型"><a href="#7-1-定义抽象数据类型" class="headerlink" title="7.1 定义抽象数据类型"></a>7.1 定义抽象数据类型</h2><h3 id="7-1-1-类和对象"><a href="#7-1-1-类和对象" class="headerlink" title="7.1.1 类和对象"></a>7.1.1 类和对象</h3><p><strong>类</strong>是一种<strong>自定义</strong>数据类型的声明，而<strong>对象</strong>是类这种数据类型的一个<strong>变量</strong></p><blockquote><p>可以将类理解为图纸，而对象就是根据图纸建造起来的房间</p></blockquote><p><strong>this 指针</strong></p><blockquote><p>当对象访问成员函数时，函数内部会<strong>隐式</strong>的将 该对象的地址存放在一个名为<strong>this</strong>的<strong>常量</strong>指针内</p></blockquote><ul><li>this指针中存放的是<strong>对象地址</strong></li><li><strong>对象</strong>访问其中的成员<strong>变量</strong>使用<strong>点</strong>运算符(<strong>.</strong>)</li><li>在成员函数<strong>内部</strong>，可以<strong>直接</strong>使用对象的成员，因为任何对类成员的直接访问都被看成<strong>this指针的隐式引用</strong></li><li>this指针是一个<strong>常量</strong>指针，所以不允许改变其中保存的地址</li></ul><h3 id="7-1-4-构造函数"><a href="#7-1-4-构造函数" class="headerlink" title="7.1.4 构造函数"></a>7.1.4 构造函数</h3><p>定义：</p><p>类通过<strong>一个或几个</strong>特殊的成员函数来<strong>控制其对象的初始化</strong>过程</p><p>作用：</p><p>初始化类对象的数据成员，只要类的对象被创建，就会执行构造函数</p><p>特征：</p><ul><li>构造函数的名字和<strong>类名相同</strong></li><li><strong>没有返回值</strong></li><li>构造函数可以有参数，可以发生重载</li><li>一个类可以包含多个构造函数</li><li>构造函数不能被声明成const</li></ul><blockquote><p>const对象在构造函数完成初始化之后，才能真正取得其“常量”属性。所以const对象在初始化的过程中可以修改它的值</p></blockquote><p><strong>默认构造函数</strong></p><p>定义：</p><p>类通过一个特殊的构造函数来控制默认初始化的过程</p><p>作用：</p><p>当我们的类没有显示的定义构造函数时，编译器会隐式的定义默认构造函数</p><p>语法：</p><p>默认构造函数无需任何实参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Room</span>&#123;</span></span><br><span class="line">    Room()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>构造函数初始值列表</strong></p><p>它负责为新创建对象的一个或多个数据成员赋初值</p><p>语法：<code>构造函数():属性1(值1),属性2(值2)...&#123;&#125;</code></p><h3 id="7-1-5-拷贝、赋值和析构"><a href="#7-1-5-拷贝、赋值和析构" class="headerlink" title="7.1.5 拷贝、赋值和析构"></a>7.1.5 拷贝、赋值和析构</h3><hr><h2 id="7-2-访问控制与封装"><a href="#7-2-访问控制与封装" class="headerlink" title="7.2 访问控制与封装"></a>7.2 访问控制与封装</h2><p> 在C++中，使用<strong>访问说明符</strong>加强类的封装性</p><p><strong>访问权限</strong>：</p><ul><li><strong>public</strong>成员定义<strong>类的接口</strong>，使得该说明符之后的成员在<strong>整个程序可以被访问</strong></li><li><strong>private</strong> 部分隐藏了类的实现细节，只有类的成员可以访问，类外不能访问</li></ul><p><strong>class</strong>和<strong>struct</strong>：</p><p>在C++中，class和struct 的唯一区别就是，两者<strong>默认的访问权限不一样</strong></p><ul><li>class 关键字默认访问权限是<strong>private</strong>，在继承时也是<strong>私有继承</strong></li><li>而struct 关键字默认访问权限是<strong>public</strong>，在继承时是<strong>公有继承</strong></li></ul><h3 id="7-2-1-友元"><a href="#7-2-1-友元" class="headerlink" title="7.2.1 友元"></a>7.2.1 友元</h3><p>类可以<strong>允许其它类或者函数访问它的非公有成员</strong>，只需要在该类或该函数前加 <strong>friend</strong> 关键字</p><p><strong>作用</strong>：</p><p><strong>在私有访问权限下，能够访问类中的成员</strong></p><p><strong>特点</strong>：</p><ul><li>友元声明只能出现在<strong>类定义的内部</strong></li><li>友元<strong>不是类成员</strong>，不受类中的访问控制权限的影响</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>封装的好处：</p><ul><li>确保代码不会无意破坏对象的状态</li><li>被封装的类的具体实现细节可以随时改变</li></ul><hr><h2 id="7-3-类的其它特性"><a href="#7-3-类的其它特性" class="headerlink" title="7.3 类的其它特性"></a>7.3 类的其它特性</h2><h3 id="7-3-1-内联函数"><a href="#7-3-1-内联函数" class="headerlink" title="7.3.1 内联函数"></a>7.3.1 内联函数</h3><p>一些<strong>规模较小</strong>的函数适合于被声明成<strong>内联函数</strong>，而类内部的<strong>成员函数</strong>是自动 <strong>inline </strong>的</p><p><strong>作用</strong>：</p><p><strong>加快程序允许时的效率</strong></p><p>特点：</p><ul><li>类内部的<strong>成员函数</strong>默认都是内联函数</li><li>也可以在<strong>类外部</strong>用 <strong>inline</strong> 关键字显示声明内联函数 </li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、将普通函数声明为内联函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、</span></span><br></pre></td></tr></table></figure><h1 id="第12章：动态内存"><a href="#第12章：动态内存" class="headerlink" title="第12章：动态内存"></a>第12章：动态内存</h1><p><strong>常量存储区</strong>：特殊的区域，里面存放常量</p><p><strong>静态内存</strong>：static对象在<strong>使用之前分配</strong>，在<strong>程序结束时销毁</strong></p><ol><li><strong>静态变量</strong></li><li><strong>全局变量</strong></li></ol><p><strong>栈内存</strong>：仅在<strong>定义的程序块</strong>运行时才存在</p><ol><li>保存<strong>函数内的非static对象</strong>，一般是局部变量和函数参数等</li></ol><p><strong>堆内存</strong>：堆内的对象是<strong>动态分配</strong>的，必须由程序员手动销毁</p><ol><li>利用 <strong>new</strong> 运算符创建的对象。delete 销毁对象</li></ol><p>总结：</p><ol><li>静态内存和栈内存都是由<strong>编译器自动创建和销毁</strong></li><li><strong>堆内存</strong>由程序<strong>手动创建和手动销毁</strong></li></ol><h2 id="12-1-动态内存与智能指针"><a href="#12-1-动态内存与智能指针" class="headerlink" title="12.1 动态内存与智能指针"></a>12.1 动态内存与智能指针</h2><p>C++中使用 <strong>new</strong> 运算符 在动态内存中<strong>为对象分配空间</strong>，并<strong>返回一个指向该对象的指针</strong></p><img src="/blog/Cpp-Primer%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/image-20220324104614405.png" class="" title="image-20220324104614405"><p>使用 <strong>delete</strong> 运算符 <strong>接受一个动态对象的指针</strong>，<strong>销毁该对象</strong>，并<strong>释放与之关联的内存</strong></p><blockquote><p>由于使用动态内存很容易出现问题，当我们忘记释放内存时，就会造成内存泄漏。</p><p>所以新标准库提供了两种智能指针来动态管理对象</p></blockquote><p><strong>智能指针的作用：</strong></p><ul><li>可以<strong>自动释放所指向的对象</strong></li></ul><h3 id="12-1-1-shared-ptr类"><a href="#12-1-1-shared-ptr类" class="headerlink" title="12.1.1 shared_ptr类"></a>12.1.1 shared_ptr类</h3><p>智能指针也是<strong>模板</strong>。所以，当我们创建智能指针时，必须提供 <strong>指针可以指向的类型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p1;<span class="comment">//可以指向string</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; p2;<span class="comment">//可以指向int的list</span></span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ul><li>shared_ptr <strong>允许多个指针指向同一个对象</strong></li><li><strong>默认初始化</strong>的智能指针是一个空指针</li></ul><p><strong>使用方法：</strong></p><ul><li>智能指针的使用方法与普通指针类似</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//智能指针都能支持的操作</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;T&gt; p;<span class="comment">//初始化一个空智能指针，可以指向类型为T的对象</span></span><br><span class="line"><span class="keyword">if</span>(p)&#123;&#125;<span class="comment">//将p作为一个判断条件，若p指向了一个对象，则为true</span></span><br><span class="line">*p;<span class="comment">//解引用p，获得它指向的对象</span></span><br><span class="line">p-&gt;mem;<span class="comment">//等价于(*p).mem</span></span><br><span class="line">p.get();<span class="comment">//返回智能指针中保存的指针。若智能指针释放了其对象，返回的指针所指向对象也就消失</span></span><br><span class="line"></span><br><span class="line">swap(p,q);<span class="comment">//交换两个智能指针中的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//shared_ptr独有的操作</span></span><br><span class="line">make_shared&lt;T&gt;(args);<span class="comment">//返回一个shared_ptr,指向一个动态分配类型为T的对象，并用args初始化此对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;T&gt;p(q);<span class="comment">//p是 shared_ptr q的拷贝。此操作会递增q中的计数器</span></span><br></pre></td></tr></table></figure><p><strong>make_shared 函数</strong></p><p>最安全的分配和使用动态内存的方法，就是调用<strong>make_shared</strong> 标准库函数</p><p>该函数会<strong>在动态内存中分配一个对象并初始化它</strong>，<strong>返回指向此对象的shared_ptr</strong>。</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p3指向一个值为42的int类型的shared_ptr</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p3 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//p4指向一个值为&quot;999&quot;的</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p4 = make_shared&lt;<span class="built_in">string</span>&gt;(<span class="number">3</span>,<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过使用auto定义一个对象来保存make_shared的结果</span></span><br><span class="line"><span class="keyword">auto</span> p5 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br></pre></td></tr></table></figure><blockquote><p>当我们传递int时，make_shared<int>就会调用相应的构造函数</p><p>若不传递任何参数，对象就会进行值初始化</p></blockquote><p><strong>shared_ptr的拷贝和赋值</strong></p><p>每个shared_ptr都有一个关联的引用计数。它表示<strong>当前有多少的shared_ptr指向同一对象</strong></p><p>当增加一个shared_ptr指向同一个对象，引用计数就会递增</p><p>若shared_ptr指向了其它对象，或者被销毁时，引用计数就会递减</p><p>一旦shared_ptr的计数器变为0，它就会自动释放自己所管理的对象</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">q</span><span class="params">(p)</span></span>;<span class="comment">//q拷贝p中的地址，与p指向同一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> r = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">r = q;<span class="comment">//将q的地址赋值给r，这样r就会跟p，q指向同一个对象，但r原来的对象没有引用者，会自动释放</span></span><br></pre></td></tr></table></figure><img src="/blog/Cpp-Primer%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/image-20220505221922334.png" class="" title="image-20220505221922334"><p><strong>shared_ptr 自动销毁管理对象并释放内存</strong></p><p>当指向对象的最后一个shared_ptr 被销毁时，shared_ptr 类就会调用<strong>析构函数</strong>完成销毁工作，并释放内存</p><p>所以当我们需要销毁对象时，只需要销毁指向它的所有shared_ptr 就行，否则程序仍会正确允许，浪费内存</p><p><strong>使用动态生存期的资源的类</strong></p><p>程序一般出于以下三种原因使用动态内存：</p><ul><li>不知道自己需要使用多少对象</li><li>不知道所需对象的准确类型</li><li>需要在多个对象间共享数据</li></ul><p><strong>容器类</strong>是出于第一种原因而使用动态内存的典型例子</p><p>而类的<strong>拷贝构造和拷贝赋值</strong>就是出于第三种原因而使用动态内存的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;<span class="built_in">string</span>&gt; b1;</span><br><span class="line">&#123;<span class="comment">//设置一个作用域</span></span><br><span class="line">    Blob&lt;<span class="built_in">string</span>&gt; b2 = &#123;<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>&#125;;</span><br><span class="line">    b1 = b2;<span class="comment">//调用拷贝赋值函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出作用域后，b2被销毁，但b1仍然指向数据</span></span><br></pre></td></tr></table></figure><img src="/blog/Cpp-Primer%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/image-20220506110829177.png" class="" title="image-20220506110829177"><h1 id="第15章：面向对象程序设计"><a href="#第15章：面向对象程序设计" class="headerlink" title="第15章：面向对象程序设计"></a>第15章：面向对象程序设计</h1><p>核心思想是<strong>封装、继承和多态</strong></p><h2 id="15-1-OPP：概述"><a href="#15-1-OPP：概述" class="headerlink" title="15.1 OPP：概述"></a>15.1 OPP：概述</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h3><p><strong>菱形继承概念</strong>：</p><p>两个派生类同时继承一个基类，并且又有某个类同时继承这个两个派生类</p><p><strong>典型的菱形继承案例</strong>：</p><img src="/blog/Cpp-Primer%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/image-20211201085720326.png" class="" title="image-20211201085720326"><p><strong>菱形继承问题</strong>：</p><blockquote><p>在动物类中声明一个年龄</p></blockquote><p>1.羊和驼都继承了动物年龄，所以当羊驼调用年龄时，会面临来自继承羊的年龄和驼的年龄，这时会产生二义性，</p><p>2.羊驼重复继承了动物的两个年龄，会在该类中开辟两块内存空间继承同一种数据，造成空间资源浪费。</p><img src="/blog/Cpp-Primer%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/image-20211201094336466.png" class="" title="image-20211201094336466"><p><strong>引入虚继承解决菱形继承问题</strong>：</p><p>即在派生类的继承前加上==virtual==关键字  使之变为虚继承<br>Animal类称为 虚基类</p><ul><li>使用虚继承后，内存中只有一份数据，所以子类访问原有父类的成员时，则不再具有二义性，也不会造成空间浪费</li></ul><p><strong>虚继承的内存模型结构</strong>：</p><img src="/blog/Cpp-Primer%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/image-20211201105430191.png" class="" title="image-20211201105430191"><img src="/blog/Cpp-Primer%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/image-20211201110516699.png" class="" title="image-20211201110516699"><blockquote><p>引入虚继承后，羊驼类不再从羊类和驼类直接继承m_Age，而是声明一个虚基类来存放m_Age</p><p>现在羊驼类只继承来自羊类和驼类vbptr(虚基类指针)</p><p>羊驼类中的vbptr(虚基类指针)会指向存放在羊类和驼类中vbtable(虚基类表)的地址</p><p>而vbtable(虚基类表)中存放的是指针偏移的字节数，羊类vbtable中是8个字节，驼类是4个字节，vbptr(虚基类指针)加上对应的字节后就能恰好指向virtual下的m_Age</p></blockquote><img src="/blog/Cpp-Primer%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/image-20211201115327378.png" class="" title="image-20211201115327378"><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>在C++中，若子类不希望直接继承父类的函数，而是希望对其进行修改，那么就可以在父类中将这些函数设置为虚函数</p><p>多态发生的条件：</p><ol><li><strong>有继承关系</strong></li><li><strong>子类重写父类中的虚函数</strong></li></ol><p>多态发生的时机：</p><p><strong>父类的指针或引用 调用一个虚函数时</strong>，将发生多态</p><h2 id="15-2-定义基类和派生类"><a href="#15-2-定义基类和派生类" class="headerlink" title="15.2 定义基类和派生类"></a>15.2 定义基类和派生类</h2><h3 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a><strong>定义基类</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    Quote() = <span class="keyword">default</span>;<span class="comment">//C++ 11中的默认构造函数</span></span><br><span class="line">    Quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book, <span class="keyword">double</span> sales_price) :</span><br><span class="line">    bookNo(book),price(sales_price)&#123;&#125;<span class="comment">//初始化列表</span></span><br><span class="line">    <span class="comment">//成员属性</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookNo;<span class="comment">//返回给定数量的书籍的销售总额</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n * price;<span class="comment">//派生类负责改写使用不同的折扣计算算法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;<span class="comment">//虚析构</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;<span class="comment">//书籍编号</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">0.0</span>;<span class="comment">//代表普通状态下不打折的价格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>若子类需要修改父类中的方法，那么就需要将该方法设置为<strong>虚函数</strong>，并在子类中进行重写</li><li>父类中通常需要定义一个<strong>虚析构函数</strong></li></ul><p><strong>成员函数和继承</strong></p><p><strong>当子类继承父类中的虚函数时，必须对其进行重写</strong>。</p><ul><li>任何<strong>构造函数之外</strong>的<strong>非静态函数</strong>，都可以是虚函数</li><li>关键字virtual 只能出现在<strong>类内部声明语句之前</strong></li><li>父类中声明一个虚函数，那么该函数在子类中隐式的也是虚函数</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
